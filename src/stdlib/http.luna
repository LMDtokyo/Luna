# (c) 2026 Luna Ecosystem. Lead Architect: LMDtokyo. All rights reserved.
# Licensed under GPLv3. See LICENSE file.

# =============================================================================
# Luna Native HTTP Server Module v4.1
# =============================================================================
# HTTP/1.1 server with request parsing, response building, and routing.
# Port of src/stdlib/web.rs (1,091 lines) to pure Luna.
#
# Features:
#   - HTTP/1.1 request parsing (method, path, headers, query, cookies, body)
#   - Response builder with status, headers, body
#   - URL encoding/decoding
#   - Route matching with path parameters (:id)
#   - Content-type detection by file extension
#   - Form data parsing (application/x-www-form-urlencoded)
#   - Status code table
#
# TCP socket binding stays as extern fn from net.luna.
# All HTTP protocol logic is pure Luna.
#
# Build: luna compile --release http.luna -o http.o
# =============================================================================

import types
import net

# =============================================================================
# SECTION 1: CONSTANTS
# =============================================================================

# HTTP Methods
const METHOD_GET: int = 0
const METHOD_POST: int = 1
const METHOD_PUT: int = 2
const METHOD_DELETE: int = 3
const METHOD_PATCH: int = 4
const METHOD_HEAD: int = 5
const METHOD_OPTIONS: int = 6
const METHOD_UNKNOWN: int = 7

# HTTP Status Codes
const STATUS_OK: int = 200
const STATUS_CREATED: int = 201
const STATUS_NO_CONTENT: int = 204
const STATUS_MOVED: int = 301
const STATUS_FOUND: int = 302
const STATUS_NOT_MODIFIED: int = 304
const STATUS_BAD_REQUEST: int = 400
const STATUS_UNAUTHORIZED: int = 401
const STATUS_FORBIDDEN: int = 403
const STATUS_NOT_FOUND: int = 404
const STATUS_METHOD_NOT_ALLOWED: int = 405
const STATUS_CONFLICT: int = 409
const STATUS_INTERNAL_ERROR: int = 500
const STATUS_NOT_IMPLEMENTED: int = 501
const STATUS_BAD_GATEWAY: int = 502
const STATUS_UNAVAILABLE: int = 503

# Content Types
const CT_HTML: int = 0
const CT_JSON: int = 1
const CT_TEXT: int = 2
const CT_CSS: int = 3
const CT_JS: int = 4
const CT_PNG: int = 5
const CT_JPEG: int = 6
const CT_FORM: int = 7
const CT_OCTET: int = 8

# Limits
const MAX_HEADERS: int = 64
const MAX_HEADER_NAME_LEN: int = 128
const MAX_HEADER_VAL_LEN: int = 1024
const MAX_PATH_LEN: int = 2048
const MAX_BODY_LEN: int = 65536
const MAX_QUERY_PARAMS: int = 64
const MAX_ROUTES: int = 128
const MAX_COOKIES: int = 32
const MAX_PATH_PARAMS: int = 16

# Result codes
const HTTP_OK: int = 0
const HTTP_ERROR: int = -1

# =============================================================================
# SECTION 2: REQUEST DATA STRUCTURES
# =============================================================================

# Request parsing
meow @req_method: int = METHOD_GET
meow @req_path: [int; 2048] = [0; 2048]
meow @req_path_len: int = 0
meow @req_version: [int; 16] = [0; 16]
meow @req_version_len: int = 0

# Headers
meow @req_hdr_names: [int; 8192] = [0; 8192]      # MAX_HEADERS * MAX_HEADER_NAME_LEN
meow @req_hdr_name_lens: [int; 64] = [0; 64]
meow @req_hdr_values: [int; 65536] = [0; 65536]    # MAX_HEADERS * MAX_HEADER_VAL_LEN
meow @req_hdr_val_lens: [int; 64] = [0; 64]
meow @req_hdr_count: int = 0

# Query parameters
meow @req_qp_keys: [int; 8192] = [0; 8192]
meow @req_qp_key_lens: [int; 64] = [0; 64]
meow @req_qp_vals: [int; 8192] = [0; 8192]
meow @req_qp_val_lens: [int; 64] = [0; 64]
meow @req_qp_count: int = 0

# Cookies
meow @req_cookie_names: [int; 4096] = [0; 4096]
meow @req_cookie_name_lens: [int; 32] = [0; 32]
meow @req_cookie_vals: [int; 4096] = [0; 4096]
meow @req_cookie_val_lens: [int; 32] = [0; 32]
meow @req_cookie_count: int = 0

# Body
meow @req_body: [int; 65536] = [0; 65536]
meow @req_body_len: int = 0

# Raw request buffer
meow @req_buf: [int; 131072] = [0; 131072]
meow @req_buf_len: int = 0

# =============================================================================
# SECTION 3: RESPONSE DATA STRUCTURES
# =============================================================================

meow @resp_status: int = 200
meow @resp_hdr_names: [int; 8192] = [0; 8192]
meow @resp_hdr_name_lens: [int; 64] = [0; 64]
meow @resp_hdr_values: [int; 65536] = [0; 65536]
meow @resp_hdr_val_lens: [int; 64] = [0; 64]
meow @resp_hdr_count: int = 0
meow @resp_body: [int; 65536] = [0; 65536]
meow @resp_body_len: int = 0

# Serialized response buffer
meow @resp_buf: [int; 131072] = [0; 131072]
meow @resp_buf_len: int = 0

# =============================================================================
# SECTION 4: ROUTING
# =============================================================================

meow @route_methods: [int; 128] = [0; 128]
meow @route_patterns: [int; 262144] = [0; 262144]   # MAX_ROUTES * MAX_PATH_LEN
meow @route_pat_lens: [int; 128] = [0; 128]
meow @route_handler_ids: [int; 128] = [0; 128]
meow @route_count: int = 0

# Path params extracted from route match
meow @path_param_names: [int; 2048] = [0; 2048]   # MAX_PATH_PARAMS * MAX_HEADER_NAME_LEN
meow @path_param_name_lens: [int; 16] = [0; 16]
meow @path_param_vals: [int; 2048] = [0; 2048]
meow @path_param_val_lens: [int; 16] = [0; 16]
meow @path_param_count: int = 0

# =============================================================================
# SECTION 5: HTTP REQUEST PARSER
# =============================================================================

fn http_reset_request()
    @req_method = METHOD_GET
    @req_path_len = 0
    @req_version_len = 0
    @req_hdr_count = 0
    @req_qp_count = 0
    @req_cookie_count = 0
    @req_body_len = 0
    @path_param_count = 0

fn http_reset_response()
    @resp_status = 200
    @resp_hdr_count = 0
    @resp_body_len = 0
    @resp_buf_len = 0

fn parse_method(@buf: [int; 131072], @pos: int) -> int
    # Parse HTTP method and return new position
    # Method ends at first space
    @start = @pos
    orbit @i in 0..16
        if @buf[@pos] == 32  # space
            nova
        @pos = @pos + 1

    @len = @pos - @start
    if @len == 3
        if @buf[@start] == 71  # 'G'
            if @buf[@start + 1] == 69  # 'E'
                if @buf[@start + 2] == 84  # 'T'
                    @req_method = METHOD_GET
    if @len == 4
        if @buf[@start] == 80  # 'P'
            if @buf[@start + 1] == 79  # 'O'
                @req_method = METHOD_POST
            if @buf[@start + 1] == 85  # 'U'
                @req_method = METHOD_PUT
        if @buf[@start] == 72  # 'H'
            @req_method = METHOD_HEAD
    if @len == 5
        if @buf[@start] == 80  # 'P'
            @req_method = METHOD_PATCH
    if @len == 6
        if @buf[@start] == 68  # 'D'
            @req_method = METHOD_DELETE
    if @len == 7
        if @buf[@start] == 79  # 'O'
            @req_method = METHOD_OPTIONS

    return @pos + 1  # skip space

fn parse_path(@buf: [int; 131072], @pos: int) -> int
    # Parse request path (until space or ?)
    @path_start = @pos
    @req_path_len = 0

    orbit @i in 0..MAX_PATH_LEN
        @ch = @buf[@pos]
        if @ch == 32  # space
            nova
        if @ch == 63  # '?'
            nova
        @req_path[@req_path_len] = @ch
        @req_path_len = @req_path_len + 1
        @pos = @pos + 1

    # Parse query string if present
    if @buf[@pos] == 63
        @pos = @pos + 1
        @pos = parse_query_string(@buf, @pos)

    # Skip to end of line (past HTTP version)
    orbit @i in 0..64
        if @buf[@pos] == 10  # '\n'
            nova
        if @buf[@pos] == 13  # '\r'
            nova
        @pos = @pos + 1

    # Skip \r\n
    if @buf[@pos] == 13
        @pos = @pos + 1
    if @buf[@pos] == 10
        @pos = @pos + 1

    return @pos

fn parse_query_string(@buf: [int; 131072], @pos: int) -> int
    # Parse query string: key=value&key2=value2
    orbit @iter in 0..MAX_QUERY_PARAMS
        if @req_qp_count >= MAX_QUERY_PARAMS
            nova
        @ch = @buf[@pos]
        if @ch == 32
            nova
        if @ch == 13
            nova
        if @ch == 10
            nova

        # Read key
        @q_idx = @req_qp_count
        @k_off = @q_idx * MAX_HEADER_NAME_LEN
        @k_len = 0
        orbit @j in 0..MAX_HEADER_NAME_LEN
            @ch = @buf[@pos]
            if @ch == 61  # '='
                nova
            if @ch == 38  # '&'
                nova
            if @ch == 32
                nova
            @req_qp_keys[@k_off + @k_len] = @ch
            @k_len = @k_len + 1
            @pos = @pos + 1
        @req_qp_key_lens[@q_idx] = @k_len

        # Read value (after '=')
        @v_off = @q_idx * MAX_HEADER_NAME_LEN
        @v_len = 0
        if @buf[@pos] == 61
            @pos = @pos + 1
            orbit @j in 0..MAX_HEADER_NAME_LEN
                @ch = @buf[@pos]
                if @ch == 38
                    nova
                if @ch == 32
                    nova
                if @ch == 13
                    nova
                if @ch == 10
                    nova
                @req_qp_vals[@v_off + @v_len] = @ch
                @v_len = @v_len + 1
                @pos = @pos + 1
        @req_qp_val_lens[@q_idx] = @v_len
        @req_qp_count = @req_qp_count + 1

        if @buf[@pos] == 38
            @pos = @pos + 1
        eclipse
            nova

    return @pos

fn parse_headers(@buf: [int; 131072], @pos: int) -> int
    # Parse HTTP headers until empty line
    orbit @iter in 0..MAX_HEADERS
        if @req_hdr_count >= MAX_HEADERS
            nova
        # Check for empty line (end of headers)
        if @buf[@pos] == 13
            if @buf[@pos + 1] == 10
                @pos = @pos + 2
                nova
        if @buf[@pos] == 10
            @pos = @pos + 1
            nova

        @h_idx = @req_hdr_count
        # Read header name (until ':')
        @n_off = @h_idx * MAX_HEADER_NAME_LEN
        @n_len = 0
        orbit @j in 0..MAX_HEADER_NAME_LEN
            @ch = @buf[@pos]
            if @ch == 58  # ':'
                nova
            # Convert to lowercase
            if @ch >= 65
                if @ch <= 90
                    @ch = @ch + 32
            @req_hdr_names[@n_off + @n_len] = @ch
            @n_len = @n_len + 1
            @pos = @pos + 1
        @req_hdr_name_lens[@h_idx] = @n_len
        @pos = @pos + 1  # skip ':'

        # Skip optional space
        if @buf[@pos] == 32
            @pos = @pos + 1

        # Read header value (until \r\n)
        @v_off = @h_idx * MAX_HEADER_VAL_LEN
        @v_len = 0
        orbit @j in 0..MAX_HEADER_VAL_LEN
            @ch = @buf[@pos]
            if @ch == 13
                nova
            if @ch == 10
                nova
            @req_hdr_values[@v_off + @v_len] = @ch
            @v_len = @v_len + 1
            @pos = @pos + 1
        @req_hdr_val_lens[@h_idx] = @v_len
        @req_hdr_count = @req_hdr_count + 1

        # Skip \r\n
        if @buf[@pos] == 13
            @pos = @pos + 1
        if @buf[@pos] == 10
            @pos = @pos + 1

    return @pos

fn parse_cookies()
    # Parse cookies from Cookie header
    orbit @i in 0..@req_hdr_count
        @n_off = @i * MAX_HEADER_NAME_LEN
        @n_len = @req_hdr_name_lens[@i]
        # Check if header name is "cookie"
        if @n_len == 6
            @is_cookie = 1
            if @req_hdr_names[@n_off] != 99
                @is_cookie = 0
            if @req_hdr_names[@n_off + 1] != 111
                @is_cookie = 0
            if @req_hdr_names[@n_off + 2] != 111
                @is_cookie = 0
            if @req_hdr_names[@n_off + 3] != 107
                @is_cookie = 0
            if @req_hdr_names[@n_off + 4] != 105
                @is_cookie = 0
            if @req_hdr_names[@n_off + 5] != 101
                @is_cookie = 0
            if @is_cookie == 1
                # Parse cookie value: name=val; name2=val2
                @v_off = @i * MAX_HEADER_VAL_LEN
                @v_len = @req_hdr_val_lens[@i]
                @cpos = 0
                orbit @ci in 0..MAX_COOKIES
                    if @cpos >= @v_len
                        nova
                    if @req_cookie_count >= MAX_COOKIES
                        nova

                    # Skip spaces
                    orbit @ws in 0..8
                        if @cpos < @v_len
                            if @req_hdr_values[@v_off + @cpos] == 32
                                @cpos = @cpos + 1

                    @c_idx = @req_cookie_count
                    @ck_off = @c_idx * MAX_HEADER_NAME_LEN
                    @ck_len = 0
                    # Read name
                    orbit @j in 0..128
                        if @cpos >= @v_len
                            nova
                        @ch = @req_hdr_values[@v_off + @cpos]
                        if @ch == 61  # '='
                            nova
                        @req_cookie_names[@ck_off + @ck_len] = @ch
                        @ck_len = @ck_len + 1
                        @cpos = @cpos + 1
                    @req_cookie_name_lens[@c_idx] = @ck_len

                    @cv_off = @c_idx * MAX_HEADER_NAME_LEN
                    @cv_len = 0
                    if @cpos < @v_len
                        if @req_hdr_values[@v_off + @cpos] == 61
                            @cpos = @cpos + 1
                            orbit @j in 0..128
                                if @cpos >= @v_len
                                    nova
                                @ch = @req_hdr_values[@v_off + @cpos]
                                if @ch == 59  # ';'
                                    nova
                                @req_cookie_vals[@cv_off + @cv_len] = @ch
                                @cv_len = @cv_len + 1
                                @cpos = @cpos + 1
                    @req_cookie_val_lens[@c_idx] = @cv_len
                    @req_cookie_count = @req_cookie_count + 1

                    # Skip '; '
                    if @cpos < @v_len
                        if @req_hdr_values[@v_off + @cpos] == 59
                            @cpos = @cpos + 1

fn http_parse_request(@raw: *u8, @raw_len: int) -> int
    # Parse a raw HTTP request
    # Returns HTTP_OK on success
    http_reset_request()

    if @raw_len <= 0
        return HTTP_ERROR
    if @raw_len > 131072
        return HTTP_ERROR

    # Copy to buffer
    orbit @i in 0..@raw_len
        @req_buf[@i] = types::ptr_read_byte(@raw, @i)
    @req_buf_len = @raw_len

    @pos = 0
    @pos = parse_method(@req_buf, @pos)
    @pos = parse_path(@req_buf, @pos)
    @pos = parse_headers(@req_buf, @pos)
    parse_cookies()

    # Parse body (remaining bytes)
    @req_body_len = 0
    orbit @i in @pos..@raw_len
        if @req_body_len < MAX_BODY_LEN
            @req_body[@req_body_len] = @req_buf[@i]
            @req_body_len = @req_body_len + 1

    return HTTP_OK

# =============================================================================
# SECTION 6: URL ENCODING/DECODING
# =============================================================================

fn hex_digit(@ch: int) -> int
    if @ch >= 48
        if @ch <= 57
            return @ch - 48
    if @ch >= 65
        if @ch <= 70
            return @ch - 55
    if @ch >= 97
        if @ch <= 102
            return @ch - 87
    return 0

fn url_decode(@input: *u8, @in_len: int, @output: *u8, @max_out: int) -> int
    @out_pos = 0
    @i = 0
    orbit @iter in 0..@in_len
        if @i >= @in_len
            nova
        if @out_pos >= @max_out
            nova
        @ch = types::ptr_read_byte(@input, @i)
        if @ch == 37  # '%'
            if @i + 2 < @in_len
                @h1 = hex_digit(types::ptr_read_byte(@input, @i + 1))
                @h2 = hex_digit(types::ptr_read_byte(@input, @i + 2))
                types::ptr_write_byte(@output, @out_pos, @h1 * 16 + @h2)
                @out_pos = @out_pos + 1
                @i = @i + 3
            eclipse
                types::ptr_write_byte(@output, @out_pos, @ch)
                @out_pos = @out_pos + 1
                @i = @i + 1
        eclipse
            if @ch == 43  # '+' -> space
                types::ptr_write_byte(@output, @out_pos, 32)
            eclipse
                types::ptr_write_byte(@output, @out_pos, @ch)
            @out_pos = @out_pos + 1
            @i = @i + 1
    return @out_pos

fn url_encode(@input: *u8, @in_len: int, @output: *u8, @max_out: int) -> int
    meow @hex_chars: [int; 16] = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70]
    @out_pos = 0
    orbit @i in 0..@in_len
        if @out_pos + 3 >= @max_out
            nova
        @ch = types::ptr_read_byte(@input, @i)
        @safe = 0
        if @ch >= 65
            if @ch <= 90
                @safe = 1
        if @ch >= 97
            if @ch <= 122
                @safe = 1
        if @ch >= 48
            if @ch <= 57
                @safe = 1
        if @ch == 45
            @safe = 1
        if @ch == 95
            @safe = 1
        if @ch == 46
            @safe = 1
        if @ch == 126
            @safe = 1

        if @safe == 1
            types::ptr_write_byte(@output, @out_pos, @ch)
            @out_pos = @out_pos + 1
        eclipse
            types::ptr_write_byte(@output, @out_pos, 37)  # '%'
            types::ptr_write_byte(@output, @out_pos + 1, @hex_chars[@ch / 16])
            types::ptr_write_byte(@output, @out_pos + 2, @hex_chars[@ch % 16])
            @out_pos = @out_pos + 3
    return @out_pos

# =============================================================================
# SECTION 7: RESPONSE BUILDER
# =============================================================================

fn http_response_new(@status: int)
    http_reset_response()
    @resp_status = @status

fn http_response_header(@name: *u8, @name_len: int, @val: *u8, @val_len: int)
    if @resp_hdr_count >= MAX_HEADERS
        return
    @idx = @resp_hdr_count
    @n_off = @idx * MAX_HEADER_NAME_LEN
    orbit @i in 0..@name_len
        @resp_hdr_names[@n_off + @i] = types::ptr_read_byte(@name, @i)
    @resp_hdr_name_lens[@idx] = @name_len

    @v_off = @idx * MAX_HEADER_VAL_LEN
    orbit @i in 0..@val_len
        @resp_hdr_values[@v_off + @i] = types::ptr_read_byte(@val, @i)
    @resp_hdr_val_lens[@idx] = @val_len
    @resp_hdr_count = @resp_hdr_count + 1

fn http_response_body(@body: *u8, @body_len: int)
    @copy_len = @body_len
    if @copy_len > MAX_BODY_LEN
        @copy_len = MAX_BODY_LEN
    orbit @i in 0..@copy_len
        @resp_body[@i] = types::ptr_read_byte(@body, @i)
    @resp_body_len = @copy_len

fn resp_write_byte(@ch: int)
    if @resp_buf_len < 131072
        @resp_buf[@resp_buf_len] = @ch
        @resp_buf_len = @resp_buf_len + 1

fn resp_write_str(@s: *u8, @len: int)
    orbit @i in 0..@len
        resp_write_byte(types::ptr_read_byte(@s, @i))

fn resp_write_int(@val: int)
    if @val < 0
        resp_write_byte(45)
        @val = 0 - @val
    if @val == 0
        resp_write_byte(48)
        return
    meow @digits: [int; 16] = [0; 16]
    @d_count = 0
    orbit @iter in 0..16
        if @val <= 0
            nova
        @digits[@d_count] = 48 + (@val % 10)
        @val = @val / 10
        @d_count = @d_count + 1
    orbit @i in 0..@d_count
        resp_write_byte(@digits[@d_count - 1 - @i])

fn resp_write_arr(@arr: [int; 65536], @len: int)
    orbit @i in 0..@len
        resp_write_byte(@arr[@i])

fn http_response_serialize() -> int
    # Serialize response to buffer
    @resp_buf_len = 0

    # Status line
    resp_write_str("HTTP/1.1 ", 9)
    resp_write_int(@resp_status)
    resp_write_byte(32)
    status_text(@resp_status)
    resp_write_str("\r\n", 2)

    # Content-Length header
    resp_write_str("Content-Length: ", 16)
    resp_write_int(@resp_body_len)
    resp_write_str("\r\n", 2)

    # Custom headers
    orbit @i in 0..@resp_hdr_count
        @n_off = @i * MAX_HEADER_NAME_LEN
        orbit @j in 0..@resp_hdr_name_lens[@i]
            resp_write_byte(@resp_hdr_names[@n_off + @j])
        resp_write_str(": ", 2)
        @v_off = @i * MAX_HEADER_VAL_LEN
        orbit @j in 0..@resp_hdr_val_lens[@i]
            resp_write_byte(@resp_hdr_values[@v_off + @j])
        resp_write_str("\r\n", 2)

    # End of headers
    resp_write_str("\r\n", 2)

    # Body
    resp_write_arr(@resp_body, @resp_body_len)

    return @resp_buf_len

fn http_response_text(@status: int, @text: *u8, @text_len: int) -> int
    http_response_new(@status)
    http_response_header("Content-Type", 12, "text/plain; charset=utf-8", 25)
    http_response_body(@text, @text_len)
    return http_response_serialize()

fn http_response_html(@status: int, @html: *u8, @html_len: int) -> int
    http_response_new(@status)
    http_response_header("Content-Type", 12, "text/html; charset=utf-8", 24)
    http_response_body(@html, @html_len)
    return http_response_serialize()

fn http_response_json(@status: int, @json: *u8, @json_len: int) -> int
    http_response_new(@status)
    http_response_header("Content-Type", 12, "application/json", 16)
    http_response_body(@json, @json_len)
    return http_response_serialize()

# =============================================================================
# SECTION 8: STATUS CODE TABLE
# =============================================================================

fn status_text(@code: int)
    phase @code
        200 =>
            resp_write_str("OK", 2)
        201 =>
            resp_write_str("Created", 7)
        204 =>
            resp_write_str("No Content", 10)
        301 =>
            resp_write_str("Moved Permanently", 17)
        302 =>
            resp_write_str("Found", 5)
        304 =>
            resp_write_str("Not Modified", 12)
        400 =>
            resp_write_str("Bad Request", 11)
        401 =>
            resp_write_str("Unauthorized", 12)
        403 =>
            resp_write_str("Forbidden", 9)
        404 =>
            resp_write_str("Not Found", 9)
        405 =>
            resp_write_str("Method Not Allowed", 18)
        409 =>
            resp_write_str("Conflict", 8)
        500 =>
            resp_write_str("Internal Server Error", 21)
        501 =>
            resp_write_str("Not Implemented", 15)
        502 =>
            resp_write_str("Bad Gateway", 11)
        503 =>
            resp_write_str("Service Unavailable", 19)

# =============================================================================
# SECTION 9: ROUTE MATCHING
# =============================================================================

fn route_add(@method: int, @pattern: *u8, @pat_len: int, @handler_id: int) -> int
    if @route_count >= MAX_ROUTES
        return HTTP_ERROR
    @idx = @route_count
    @route_methods[@idx] = @method
    @p_off = @idx * MAX_PATH_LEN
    orbit @i in 0..@pat_len
        @route_patterns[@p_off + @i] = types::ptr_read_byte(@pattern, @i)
    @route_pat_lens[@idx] = @pat_len
    @route_handler_ids[@idx] = @handler_id
    @route_count = @route_count + 1
    return @idx

fn route_match() -> int
    # Match current request against registered routes
    # Returns handler_id or -1
    @path_param_count = 0

    orbit @r in 0..@route_count
        if @route_methods[@r] != @req_method
            orbit @skip in 0..0
                pass
        eclipse
            @p_off = @r * MAX_PATH_LEN
            @p_len = @route_pat_lens[@r]

            # Try to match pattern against request path
            @matched = route_match_pattern(@p_off, @p_len, 0, 0)
            if @matched == 1
                return @route_handler_ids[@r]

    return -1

fn route_match_pattern(@pat_off: int, @pat_len: int, @pi: int, @ri: int) -> int
    # Match route pattern against request path
    # Supports :param path parameters
    orbit @iter in 0..MAX_PATH_LEN
        if @pi >= @pat_len
            if @ri >= @req_path_len
                return 1
            return 0

        @pch = @route_patterns[@pat_off + @pi]

        if @pch == 58  # ':' - path parameter
            # Read param name
            @pi = @pi + 1
            @pname_start = @pi
            orbit @j in 0..128
                if @pi >= @pat_len
                    nova
                if @route_patterns[@pat_off + @pi] == 47  # '/'
                    nova
                @pi = @pi + 1
            @pname_len = @pi - @pname_start

            # Read param value from request path
            @val_start = @ri
            orbit @j in 0..MAX_PATH_LEN
                if @ri >= @req_path_len
                    nova
                if @req_path[@ri] == 47
                    nova
                @ri = @ri + 1
            @val_len = @ri - @val_start

            # Store param
            if @path_param_count < MAX_PATH_PARAMS
                @pp_idx = @path_param_count
                @pn_off = @pp_idx * MAX_HEADER_NAME_LEN
                orbit @b in 0..@pname_len
                    @path_param_names[@pn_off + @b] = @route_patterns[@pat_off + @pname_start + @b]
                @path_param_name_lens[@pp_idx] = @pname_len
                @pv_off = @pp_idx * MAX_HEADER_NAME_LEN
                orbit @b in 0..@val_len
                    @path_param_vals[@pv_off + @b] = @req_path[@val_start + @b]
                @path_param_val_lens[@pp_idx] = @val_len
                @path_param_count = @path_param_count + 1

        eclipse
            # Literal character match
            if @ri >= @req_path_len
                return 0
            if @pch != @req_path[@ri]
                return 0
            @pi = @pi + 1
            @ri = @ri + 1

    return 0

# =============================================================================
# SECTION 10: CONTENT TYPE DETECTION
# =============================================================================

fn content_type_for_ext(@ext: *u8, @ext_len: int) -> int
    # Detect content type from file extension
    if @ext_len == 4
        @e0 = types::ptr_read_byte(@ext, 0)
        @e1 = types::ptr_read_byte(@ext, 1)
        @e2 = types::ptr_read_byte(@ext, 2)
        @e3 = types::ptr_read_byte(@ext, 3)
        if @e0 == 104  # h
            if @e1 == 116  # t
                if @e2 == 109  # m
                    if @e3 == 108  # l
                        return CT_HTML
        if @e0 == 106  # j
            if @e1 == 115  # s
                if @e2 == 111  # o
                    if @e3 == 110  # n
                        return CT_JSON
        if @e0 == 106  # j
            if @e1 == 112  # p
                if @e2 == 101  # e
                    if @e3 == 103  # g
                        return CT_JPEG
    if @ext_len == 3
        @e0 = types::ptr_read_byte(@ext, 0)
        @e1 = types::ptr_read_byte(@ext, 1)
        @e2 = types::ptr_read_byte(@ext, 2)
        if @e0 == 99   # c
            if @e1 == 115  # s
                if @e2 == 115  # s
                    return CT_CSS
        if @e0 == 112  # p
            if @e1 == 110  # n
                if @e2 == 103  # g
                    return CT_PNG
        if @e0 == 116  # t
            if @e1 == 120  # x
                if @e2 == 116  # t
                    return CT_TEXT
        if @e0 == 104  # h
            if @e1 == 116  # t
                if @e2 == 109  # m
                    return CT_HTML
        if @e0 == 106  # j
            if @e1 == 112  # p
                if @e2 == 103  # g
                    return CT_JPEG
    if @ext_len == 2
        @e0 = types::ptr_read_byte(@ext, 0)
        @e1 = types::ptr_read_byte(@ext, 1)
        if @e0 == 106  # j
            if @e1 == 115  # s
                return CT_JS
    return CT_OCTET

fn content_type_str(@ct: int, @out: *u8) -> int
    phase @ct
        0 =>
            orbit @i in 0..9
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("text/html", @i))
            return 9
        1 =>
            orbit @i in 0..16
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("application/json", @i))
            return 16
        2 =>
            orbit @i in 0..10
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("text/plain", @i))
            return 10
        3 =>
            orbit @i in 0..8
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("text/css", @i))
            return 8
        4 =>
            orbit @i in 0..24
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("application/javascript", @i))
            return 22
        5 =>
            orbit @i in 0..9
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("image/png", @i))
            return 9
        6 =>
            orbit @i in 0..10
                types::ptr_write_byte(@out, @i, types::ptr_read_byte("image/jpeg", @i))
            return 10
    orbit @i in 0..24
        types::ptr_write_byte(@out, @i, types::ptr_read_byte("application/octet-stream", @i))
    return 24

# =============================================================================
# SECTION 11: REQUEST ACCESSORS
# =============================================================================

fn http_get_method() -> int
    return @req_method

fn http_get_path(@out: *u8, @max: int) -> int
    @copy = @req_path_len
    if @copy > @max
        @copy = @max
    orbit @i in 0..@copy
        types::ptr_write_byte(@out, @i, @req_path[@i])
    return @copy

fn http_get_header(@name: *u8, @name_len: int, @out: *u8, @max: int) -> int
    orbit @i in 0..@req_hdr_count
        @n_off = @i * MAX_HEADER_NAME_LEN
        @n_len = @req_hdr_name_lens[@i]
        if @n_len == @name_len
            @match = 1
            orbit @j in 0..@name_len
                @ch1 = @req_hdr_names[@n_off + @j]
                @ch2 = types::ptr_read_byte(@name, @j)
                # Case insensitive
                if @ch2 >= 65
                    if @ch2 <= 90
                        @ch2 = @ch2 + 32
                if @ch1 != @ch2
                    @match = 0
                    nova
            if @match == 1
                @v_off = @i * MAX_HEADER_VAL_LEN
                @v_len = @req_hdr_val_lens[@i]
                @copy = @v_len
                if @copy > @max
                    @copy = @max
                orbit @j in 0..@copy
                    types::ptr_write_byte(@out, @j, @req_hdr_values[@v_off + @j])
                return @v_len
    return -1

fn http_get_query_param(@key: *u8, @key_len: int, @out: *u8, @max: int) -> int
    orbit @i in 0..@req_qp_count
        @k_off = @i * MAX_HEADER_NAME_LEN
        @k_len = @req_qp_key_lens[@i]
        if @k_len == @key_len
            @match = 1
            orbit @j in 0..@key_len
                if @req_qp_keys[@k_off + @j] != types::ptr_read_byte(@key, @j)
                    @match = 0
                    nova
            if @match == 1
                @v_off = @i * MAX_HEADER_NAME_LEN
                @v_len = @req_qp_val_lens[@i]
                @copy = @v_len
                if @copy > @max
                    @copy = @max
                orbit @j in 0..@copy
                    types::ptr_write_byte(@out, @j, @req_qp_vals[@v_off + @j])
                return @v_len
    return -1

fn http_get_cookie(@name: *u8, @name_len: int, @out: *u8, @max: int) -> int
    orbit @i in 0..@req_cookie_count
        @n_off = @i * MAX_HEADER_NAME_LEN
        @n_len = @req_cookie_name_lens[@i]
        if @n_len == @name_len
            @match = 1
            orbit @j in 0..@name_len
                if @req_cookie_names[@n_off + @j] != types::ptr_read_byte(@name, @j)
                    @match = 0
                    nova
            if @match == 1
                @v_off = @i * MAX_HEADER_NAME_LEN
                @v_len = @req_cookie_val_lens[@i]
                @copy = @v_len
                if @copy > @max
                    @copy = @max
                orbit @j in 0..@copy
                    types::ptr_write_byte(@out, @j, @req_cookie_vals[@v_off + @j])
                return @v_len
    return -1

fn http_get_body(@out: *u8, @max: int) -> int
    @copy = @req_body_len
    if @copy > @max
        @copy = @max
    orbit @i in 0..@copy
        types::ptr_write_byte(@out, @i, @req_body[@i])
    return @copy

fn http_get_header_count() -> int
    return @req_hdr_count

fn http_get_query_count() -> int
    return @req_qp_count

fn http_get_cookie_count() -> int
    return @req_cookie_count

fn http_get_path_param(@name: *u8, @name_len: int, @out: *u8, @max: int) -> int
    orbit @i in 0..@path_param_count
        @n_off = @i * MAX_HEADER_NAME_LEN
        @n_len = @path_param_name_lens[@i]
        if @n_len == @name_len
            @match = 1
            orbit @j in 0..@name_len
                if @path_param_names[@n_off + @j] != types::ptr_read_byte(@name, @j)
                    @match = 0
                    nova
            if @match == 1
                @v_off = @i * MAX_HEADER_NAME_LEN
                @v_len = @path_param_val_lens[@i]
                @copy = @v_len
                if @copy > @max
                    @copy = @max
                orbit @j in 0..@copy
                    types::ptr_write_byte(@out, @j, @path_param_vals[@v_off + @j])
                return @v_len
    return -1

# =============================================================================
# SECTION 12: EXTERN C API
# =============================================================================

extern "C" fn luna_http_parse(@raw: *u8, @len: int) -> int
    return http_parse_request(@raw, @len)

extern "C" fn luna_http_method() -> int
    return http_get_method()

extern "C" fn luna_http_path(@out: *u8, @max: int) -> int
    return http_get_path(@out, @max)

extern "C" fn luna_http_header(@name: *u8, @nlen: int, @out: *u8, @max: int) -> int
    return http_get_header(@name, @nlen, @out, @max)

extern "C" fn luna_http_response_text(@status: int, @text: *u8, @len: int) -> int
    return http_response_text(@status, @text, @len)

extern "C" fn luna_http_response_json(@status: int, @json: *u8, @len: int) -> int
    return http_response_json(@status, @json, @len)

extern "C" fn luna_http_route_add(@method: int, @pat: *u8, @plen: int, @hid: int) -> int
    return route_add(@method, @pat, @plen, @hid)

extern "C" fn luna_http_route_match() -> int
    return route_match()

# =============================================================================
# SECTION 13: SELF-TESTS
# =============================================================================

fn test_http_parse_get() -> int
    @raw = "GET /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n"
    @r = http_parse_request(@raw, 45)
    guard @r == HTTP_OK, "http: parse GET failed"
    guard @req_method == METHOD_GET, "http: method should be GET"
    guard @req_path_len > 0, "http: path should not be empty"
    shine("  [PASS] http parse GET")
    return 1

fn test_http_parse_post() -> int
    @raw = "POST /api/data HTTP/1.1\r\nContent-Type: application/json\r\nContent-Length: 13\r\n\r\n{\"key\":\"val\"}"
    @r = http_parse_request(@raw, 91)
    guard @r == HTTP_OK, "http: parse POST failed"
    guard @req_method == METHOD_POST, "http: method should be POST"
    guard @req_body_len > 0, "http: body should not be empty"
    shine("  [PASS] http parse POST")
    return 1

fn test_http_headers() -> int
    @raw = "GET / HTTP/1.1\r\nHost: example.com\r\nAccept: text/html\r\n\r\n"
    http_parse_request(@raw, 56)
    @hc = http_get_header_count()
    guard @hc >= 2, "http: should have at least 2 headers"
    shine("  [PASS] http headers")
    return 1

fn test_http_query_params() -> int
    @raw = "GET /search?q=hello&page=1 HTTP/1.1\r\nHost: x\r\n\r\n"
    http_parse_request(@raw, 49)
    @qc = http_get_query_count()
    guard @qc >= 2, "http: should have 2 query params"
    shine("  [PASS] http query params")
    return 1

fn test_http_response_build() -> int
    @len = http_response_text(200, "Hello", 5)
    guard @len > 0, "http: response should have content"
    shine("  [PASS] http response build")
    return 1

fn test_http_response_json_build() -> int
    @len = http_response_json(200, "{\"ok\":true}", 11)
    guard @len > 0, "http: json response should have content"
    shine("  [PASS] http response JSON")
    return 1

fn test_http_url_decode() -> int
    meow @out: [int; 256] = [0; 256]
    @len = url_decode("hello%20world", 13, @out, 256)
    guard @len == 11, "http: url decode length should be 11"
    shine("  [PASS] http url decode")
    return 1

fn test_http_url_encode() -> int
    meow @out: [int; 256] = [0; 256]
    @len = url_encode("hello world", 11, @out, 256)
    guard @len > 11, "http: url encode should expand spaces"
    shine("  [PASS] http url encode")
    return 1

fn test_http_routing() -> int
    @route_count = 0
    route_add(METHOD_GET, "/users/:id", 10, 42)
    route_add(METHOD_GET, "/index", 6, 1)

    # Simulate request to /index
    @raw = "GET /index HTTP/1.1\r\nHost: x\r\n\r\n"
    http_parse_request(@raw, 32)
    @handler = route_match()
    guard @handler == 1, "http: should match /index route"

    shine("  [PASS] http routing")
    return 1

fn test_http_content_type() -> int
    @ct = content_type_for_ext("html", 4)
    guard @ct == CT_HTML, "http: .html should be CT_HTML"
    @ct = content_type_for_ext("json", 4)
    guard @ct == CT_JSON, "http: .json should be CT_JSON"
    @ct = content_type_for_ext("css", 3)
    guard @ct == CT_CSS, "http: .css should be CT_CSS"
    shine("  [PASS] http content type")
    return 1

fn run_http_tests() -> int
    shine("--- http.luna self-tests ---")
    @pass_count = 0
    @pass_count = @pass_count + test_http_parse_get()
    @pass_count = @pass_count + test_http_parse_post()
    @pass_count = @pass_count + test_http_headers()
    @pass_count = @pass_count + test_http_query_params()
    @pass_count = @pass_count + test_http_response_build()
    @pass_count = @pass_count + test_http_response_json_build()
    @pass_count = @pass_count + test_http_url_decode()
    @pass_count = @pass_count + test_http_url_encode()
    @pass_count = @pass_count + test_http_routing()
    @pass_count = @pass_count + test_http_content_type()
    shine("--- http.luna: " + @pass_count + "/10 tests passed ---")
    return @pass_count
