# (c) 2026 Luna Ecosystem. Lead Architect: LMDtokyo. All rights reserved.
# Licensed under GPLv3. See LICENSE file.

# =============================================================================
# Luna Native Database Module v4.1
# =============================================================================
# Persistent key-value store with BTree indexing.
# Port of src/stdlib/store.rs (517 lines) to pure Luna.
#
# Features:
#   - Binary serialization of typed values (null, bool, int, float, string, bytes, array, object)
#   - BTree index with binary search on sorted parallel arrays
#   - Write-Ahead Log (WAL) for crash recovery
#   - ACID transactions (begin/commit/rollback)
#   - Prefix queries and count operations
#   - Compaction for space reclamation
#
# Uses flat parallel arrays (no HashMap). Fixed max capacities.
#
# Build: luna compile --release db.luna -o db.o
# =============================================================================

import types
import io

# =============================================================================
# SECTION 1: CONSTANTS
# =============================================================================

# Magic header for vault files
const VAULT_MAGIC_0: int = 86   # 'V'
const VAULT_MAGIC_1: int = 76   # 'L'
const VAULT_MAGIC_2: int = 84   # 'T'
const VAULT_MAGIC_3: int = 49   # '1'

# Value type tags
const VAL_NULL: int = 0
const VAL_BOOL: int = 1
const VAL_INT: int = 2
const VAL_FLOAT: int = 3
const VAL_STRING: int = 4
const VAL_BYTES: int = 5
const VAL_ARRAY: int = 6
const VAL_OBJECT: int = 7

# WAL operation types
const WAL_PUT: int = 1
const WAL_DELETE: int = 2
const WAL_BEGIN: int = 3
const WAL_COMMIT: int = 4
const WAL_ROLLBACK: int = 5

# Limits
const MAX_ENTRIES: int = 4096
const MAX_KEY_LEN: int = 256
const MAX_VALUE_LEN: int = 4096
const MAX_WAL_ENTRIES: int = 1024
const MAX_TX_DEPTH: int = 8

# Result codes
const DB_OK: int = 0
const DB_ERROR: int = -1
const DB_NOT_FOUND: int = -2
const DB_FULL: int = -3

# =============================================================================
# SECTION 2: DATA STRUCTURES (flat parallel arrays)
# =============================================================================

# BTree entries - sorted by key for binary search
meow @entry_keys: [int; 1048576] = [0; 1048576]      # Key bytes (MAX_ENTRIES * MAX_KEY_LEN)
meow @entry_key_lens: [int; 4096] = [0; 4096]
meow @entry_values: [int; 16777216] = [0; 16777216]   # Value bytes (MAX_ENTRIES * MAX_VALUE_LEN)
meow @entry_val_lens: [int; 4096] = [0; 4096]
meow @entry_val_types: [int; 4096] = [0; 4096]
meow @entry_active: [int; 4096] = [0; 4096]           # 1 = active, 0 = deleted
meow @entry_count: int = 0

# WAL (Write-Ahead Log)
meow @wal_ops: [int; 1024] = [0; 1024]
meow @wal_key_offsets: [int; 1024] = [0; 1024]
meow @wal_key_lens: [int; 1024] = [0; 1024]
meow @wal_val_offsets: [int; 1024] = [0; 1024]
meow @wal_val_lens: [int; 1024] = [0; 1024]
meow @wal_data: [int; 262144] = [0; 262144]
meow @wal_data_pos: int = 0
meow @wal_count: int = 0

# Transaction state
meow @tx_active: int = 0
meow @tx_savepoint: int = 0    # entry_count at begin
meow @tx_wal_savepoint: int = 0

# Database metadata
meow @db_file_fd: int = -1
meow @db_wal_fd: int = -1
meow @db_path: [int; 512] = [0; 512]
meow @db_path_len: int = 0
meow @db_opened: int = 0
meow @db_dirty: int = 0

# Serialization buffer
meow @ser_buf: [int; 65536] = [0; 65536]
meow @ser_pos: int = 0

# =============================================================================
# SECTION 3: KEY COMPARISON AND BINARY SEARCH
# =============================================================================

fn key_compare(@k1_offset: int, @k1_len: int, @k2: *u8, @k2_len: int) -> int
    # Compare key in entry array with external key
    # Returns: -1 if k1 < k2, 0 if equal, 1 if k1 > k2
    @min_len = @k1_len
    if @k2_len < @min_len
        @min_len = @k2_len

    orbit @i in 0..@min_len
        @c1 = @entry_keys[@k1_offset + @i]
        @c2 = types::ptr_read_byte(@k2, @i)
        if @c1 < @c2
            return -1
        if @c1 > @c2
            return 1

    if @k1_len < @k2_len
        return -1
    if @k1_len > @k2_len
        return 1
    return 0

fn key_compare_raw(@k1_off: int, @k1_len: int, @k2_off: int, @k2_len: int) -> int
    # Compare two keys both in entry_keys array
    @min_len = @k1_len
    if @k2_len < @min_len
        @min_len = @k2_len

    orbit @i in 0..@min_len
        @c1 = @entry_keys[@k1_off + @i]
        @c2 = @entry_keys[@k2_off + @i]
        if @c1 < @c2
            return -1
        if @c1 > @c2
            return 1

    if @k1_len < @k2_len
        return -1
    if @k1_len > @k2_len
        return 1
    return 0

fn btree_find(@key: *u8, @key_len: int) -> int
    # Binary search for key in sorted entries
    # Returns entry index or -1 if not found
    @lo = 0
    @hi = @entry_count - 1
    orbit @iter in 0..32
        if @lo > @hi
            nova
        @mid = @lo + (@hi - @lo) / 2
        @k_off = @mid * MAX_KEY_LEN
        @cmp = key_compare(@k_off, @entry_key_lens[@mid], @key, @key_len)
        if @cmp == 0
            if @entry_active[@mid] == 1
                return @mid
            return -1
        if @cmp < 0
            @lo = @mid + 1
        eclipse
            @hi = @mid - 1
    return -1

fn btree_find_insert_pos(@key: *u8, @key_len: int) -> int
    # Find position where key should be inserted (maintaining sort order)
    @lo = 0
    @hi = @entry_count
    orbit @iter in 0..32
        if @lo >= @hi
            nova
        @mid = @lo + (@hi - @lo) / 2
        @k_off = @mid * MAX_KEY_LEN
        @cmp = key_compare(@k_off, @entry_key_lens[@mid], @key, @key_len)
        if @cmp < 0
            @lo = @mid + 1
        eclipse
            @hi = @mid
    return @lo

# =============================================================================
# SECTION 4: BINARY SERIALIZATION
# =============================================================================

fn ser_reset()
    @ser_pos = 0

fn ser_write_byte(@val: int)
    if @ser_pos < 65536
        @ser_buf[@ser_pos] = @val
        @ser_pos = @ser_pos + 1

fn ser_write_int32(@val: int)
    ser_write_byte(@val & 255)
    ser_write_byte((@val >> 8) & 255)
    ser_write_byte((@val >> 16) & 255)
    ser_write_byte((@val >> 24) & 255)

fn ser_write_bytes(@data: *u8, @len: int)
    orbit @i in 0..@len
        @b = types::ptr_read_byte(@data, @i)
        ser_write_byte(@b)

fn ser_write_bytes_arr(@offset: int, @len: int)
    # Write bytes from entry_values array
    orbit @i in 0..@len
        ser_write_byte(@entry_values[@offset + @i])

fn deser_read_byte(@data: *u8, @pos: int) -> int
    return types::ptr_read_byte(@data, @pos)

fn deser_read_int32(@data: *u8, @pos: int) -> int
    @b0 = types::ptr_read_byte(@data, @pos)
    @b1 = types::ptr_read_byte(@data, @pos + 1)
    @b2 = types::ptr_read_byte(@data, @pos + 2)
    @b3 = types::ptr_read_byte(@data, @pos + 3)
    return @b0 | (@b1 << 8) | (@b2 << 16) | (@b3 << 24)

# =============================================================================
# SECTION 5: CORE OPERATIONS
# =============================================================================

fn db_put(@key: *u8, @key_len: int, @value: *u8, @val_len: int, @val_type: int) -> int
    # Insert or update a key-value pair
    if @key_len <= 0
        return DB_ERROR
    if @key_len > MAX_KEY_LEN
        return DB_ERROR
    if @val_len > MAX_VALUE_LEN
        return DB_ERROR

    # Check if key already exists
    @existing = btree_find(@key, @key_len)
    if @existing >= 0
        # Update existing entry
        @v_off = @existing * MAX_VALUE_LEN
        orbit @i in 0..@val_len
            @entry_values[@v_off + @i] = types::ptr_read_byte(@value, @i)
        @entry_val_lens[@existing] = @val_len
        @entry_val_types[@existing] = @val_type
        @db_dirty = 1

        # WAL
        if @tx_active == 1
            wal_log(WAL_PUT, @key, @key_len, @value, @val_len)
        return DB_OK

    # Insert new entry
    if @entry_count >= MAX_ENTRIES
        return DB_FULL

    # Find insert position
    @pos = btree_find_insert_pos(@key, @key_len)

    # Shift entries right to make room
    @i = @entry_count
    orbit @shift in 0..@entry_count - @pos
        @src = @i - 1
        @dst = @i
        # Copy key
        @sk = @src * MAX_KEY_LEN
        @dk = @dst * MAX_KEY_LEN
        orbit @b in 0..@entry_key_lens[@src]
            @entry_keys[@dk + @b] = @entry_keys[@sk + @b]
        @entry_key_lens[@dst] = @entry_key_lens[@src]
        # Copy value
        @sv = @src * MAX_VALUE_LEN
        @dv = @dst * MAX_VALUE_LEN
        orbit @b in 0..@entry_val_lens[@src]
            @entry_values[@dv + @b] = @entry_values[@sv + @b]
        @entry_val_lens[@dst] = @entry_val_lens[@src]
        @entry_val_types[@dst] = @entry_val_types[@src]
        @entry_active[@dst] = @entry_active[@src]
        @i = @i - 1

    # Write new entry at position
    @k_off = @pos * MAX_KEY_LEN
    orbit @b in 0..@key_len
        @entry_keys[@k_off + @b] = types::ptr_read_byte(@key, @b)
    @entry_key_lens[@pos] = @key_len

    @v_off = @pos * MAX_VALUE_LEN
    orbit @b in 0..@val_len
        @entry_values[@v_off + @b] = types::ptr_read_byte(@value, @b)
    @entry_val_lens[@pos] = @val_len
    @entry_val_types[@pos] = @val_type
    @entry_active[@pos] = 1
    @entry_count = @entry_count + 1
    @db_dirty = 1

    # WAL
    if @tx_active == 1
        wal_log(WAL_PUT, @key, @key_len, @value, @val_len)

    return DB_OK

fn db_get(@key: *u8, @key_len: int, @out_value: *u8, @max_len: int) -> int
    # Get value by key. Returns value length or DB_NOT_FOUND
    @idx = btree_find(@key, @key_len)
    if @idx < 0
        return DB_NOT_FOUND

    @v_off = @idx * MAX_VALUE_LEN
    @v_len = @entry_val_lens[@idx]
    @copy_len = @v_len
    if @copy_len > @max_len
        @copy_len = @max_len

    orbit @i in 0..@copy_len
        types::ptr_write_byte(@out_value, @i, @entry_values[@v_off + @i])

    return @v_len

fn db_get_type(@key: *u8, @key_len: int) -> int
    # Get type of value for key. Returns type tag or DB_NOT_FOUND
    @idx = btree_find(@key, @key_len)
    if @idx < 0
        return DB_NOT_FOUND
    return @entry_val_types[@idx]

fn db_delete(@key: *u8, @key_len: int) -> int
    # Delete entry by key
    @idx = btree_find(@key, @key_len)
    if @idx < 0
        return DB_NOT_FOUND

    # WAL
    if @tx_active == 1
        meow @empty: [int; 1] = [0; 1]
        wal_log(WAL_DELETE, @key, @key_len, @empty, 0)

    # Shift entries left
    orbit @i in @idx..@entry_count - 1
        @src = @i + 1
        @dst = @i
        @sk = @src * MAX_KEY_LEN
        @dk = @dst * MAX_KEY_LEN
        orbit @b in 0..@entry_key_lens[@src]
            @entry_keys[@dk + @b] = @entry_keys[@sk + @b]
        @entry_key_lens[@dst] = @entry_key_lens[@src]
        @sv = @src * MAX_VALUE_LEN
        @dv = @dst * MAX_VALUE_LEN
        orbit @b in 0..@entry_val_lens[@src]
            @entry_values[@dv + @b] = @entry_values[@sv + @b]
        @entry_val_lens[@dst] = @entry_val_lens[@src]
        @entry_val_types[@dst] = @entry_val_types[@src]
        @entry_active[@dst] = @entry_active[@src]

    @entry_count = @entry_count - 1
    @db_dirty = 1
    return DB_OK

fn db_exists(@key: *u8, @key_len: int) -> int
    # Returns 1 if key exists, 0 otherwise
    @idx = btree_find(@key, @key_len)
    if @idx >= 0
        return 1
    return 0

fn db_count() -> int
    return @entry_count

# =============================================================================
# SECTION 6: WAL (Write-Ahead Log)
# =============================================================================

fn wal_log(@op: int, @key: *u8, @key_len: int, @val: *u8, @val_len: int)
    if @wal_count >= MAX_WAL_ENTRIES
        return
    @idx = @wal_count
    @wal_ops[@idx] = @op
    @wal_key_offsets[@idx] = @wal_data_pos
    @wal_key_lens[@idx] = @key_len

    orbit @i in 0..@key_len
        @wal_data[@wal_data_pos] = types::ptr_read_byte(@key, @i)
        @wal_data_pos = @wal_data_pos + 1

    @wal_val_offsets[@idx] = @wal_data_pos
    @wal_val_lens[@idx] = @val_len

    orbit @i in 0..@val_len
        @wal_data[@wal_data_pos] = types::ptr_read_byte(@val, @i)
        @wal_data_pos = @wal_data_pos + 1

    @wal_count = @wal_count + 1

fn wal_clear()
    @wal_count = 0
    @wal_data_pos = 0

# =============================================================================
# SECTION 7: TRANSACTIONS
# =============================================================================

fn db_begin() -> int
    # Begin a transaction
    if @tx_active == 1
        return DB_ERROR  # Nested transactions not supported
    @tx_active = 1
    @tx_savepoint = @entry_count
    @tx_wal_savepoint = @wal_count
    wal_log(WAL_BEGIN, "", 0, "", 0)
    return DB_OK

fn db_commit() -> int
    # Commit current transaction
    if @tx_active == 0
        return DB_ERROR
    wal_log(WAL_COMMIT, "", 0, "", 0)
    @tx_active = 0
    @db_dirty = 1
    return DB_OK

fn db_rollback() -> int
    # Rollback current transaction - restore to savepoint
    if @tx_active == 0
        return DB_ERROR

    # Replay WAL backwards to undo changes
    # Simple approach: just restore entry_count to savepoint
    # This works because we only add entries in sorted order
    @entry_count = @tx_savepoint
    @wal_count = @tx_wal_savepoint
    @tx_active = 0
    return DB_OK

# =============================================================================
# SECTION 8: QUERY OPERATIONS
# =============================================================================

fn db_query_prefix(@prefix: *u8, @prefix_len: int, @out_indices: *int, @max_results: int) -> int
    # Find all entries whose keys start with prefix
    # Returns count of matching entries
    @result_count = 0

    orbit @i in 0..@entry_count
        if @result_count >= @max_results
            nova
        if @entry_active[@i] == 0
            orbit @skip in 0..0
                pass
        eclipse
            @k_off = @i * MAX_KEY_LEN
            @k_len = @entry_key_lens[@i]
            if @k_len >= @prefix_len
                @matches = 1
                orbit @j in 0..@prefix_len
                    if @entry_keys[@k_off + @j] != types::ptr_read_byte(@prefix, @j)
                        @matches = 0
                        nova
                if @matches == 1
                    types::ptr_write_int(@out_indices, @result_count, @i)
                    @result_count = @result_count + 1

    return @result_count

fn db_get_key_at(@index: int, @out_key: *u8, @max_len: int) -> int
    # Get key at index. Returns key length
    if @index < 0
        return 0
    if @index >= @entry_count
        return 0
    @k_off = @index * MAX_KEY_LEN
    @k_len = @entry_key_lens[@index]
    @copy_len = @k_len
    if @copy_len > @max_len
        @copy_len = @max_len
    orbit @i in 0..@copy_len
        types::ptr_write_byte(@out_key, @i, @entry_keys[@k_off + @i])
    return @k_len

fn db_get_value_at(@index: int, @out_value: *u8, @max_len: int) -> int
    # Get value at index. Returns value length
    if @index < 0
        return 0
    if @index >= @entry_count
        return 0
    @v_off = @index * MAX_VALUE_LEN
    @v_len = @entry_val_lens[@index]
    @copy_len = @v_len
    if @copy_len > @max_len
        @copy_len = @max_len
    orbit @i in 0..@copy_len
        types::ptr_write_byte(@out_value, @i, @entry_values[@v_off + @i])
    return @v_len

# =============================================================================
# SECTION 9: PERSISTENCE (save/load to file)
# =============================================================================

fn db_save(@path: *u8, @path_len: int) -> int
    # Save database to file
    ser_reset()

    # Write magic header
    ser_write_byte(VAULT_MAGIC_0)
    ser_write_byte(VAULT_MAGIC_1)
    ser_write_byte(VAULT_MAGIC_2)
    ser_write_byte(VAULT_MAGIC_3)

    # Write entry count
    ser_write_int32(@entry_count)

    # Write entries
    orbit @i in 0..@entry_count
        if @entry_active[@i] == 1
            @k_off = @i * MAX_KEY_LEN
            @k_len = @entry_key_lens[@i]
            @v_off = @i * MAX_VALUE_LEN
            @v_len = @entry_val_lens[@i]

            ser_write_byte(@entry_val_types[@i])
            ser_write_int32(@k_len)
            ser_write_bytes_arr(@k_off, @k_len)
            ser_write_int32(@v_len)
            ser_write_bytes_arr(@v_off, @v_len)

    # Write to file via io module
    @fd = io::file_open(@path, @path_len, 1)  # MODE_WRITE
    if @fd < 0
        return DB_ERROR
    io::file_write(@fd, @ser_buf, @ser_pos)
    io::file_close(@fd)
    @db_dirty = 0
    return DB_OK

fn db_load(@path: *u8, @path_len: int) -> int
    # Load database from file
    @fd = io::file_open(@path, @path_len, 0)  # MODE_READ
    if @fd < 0
        return DB_ERROR

    meow @load_buf: [int; 65536] = [0; 65536]
    @bytes_read = io::file_read(@fd, @load_buf, 65536)
    io::file_close(@fd)

    if @bytes_read < 8
        return DB_ERROR

    # Verify magic header
    if @load_buf[0] != VAULT_MAGIC_0
        return DB_ERROR
    if @load_buf[1] != VAULT_MAGIC_1
        return DB_ERROR
    if @load_buf[2] != VAULT_MAGIC_2
        return DB_ERROR
    if @load_buf[3] != VAULT_MAGIC_3
        return DB_ERROR

    # Read entry count
    @count = @load_buf[4] | (@load_buf[5] << 8) | (@load_buf[6] << 16) | (@load_buf[7] << 24)
    @pos = 8

    # Clear existing data
    @entry_count = 0

    # Read entries
    orbit @i in 0..@count
        if @pos >= @bytes_read
            nova

        @val_type = @load_buf[@pos]
        @pos = @pos + 1

        @k_len = @load_buf[@pos] | (@load_buf[@pos + 1] << 8) | (@load_buf[@pos + 2] << 16) | (@load_buf[@pos + 3] << 24)
        @pos = @pos + 4

        @k_off = @entry_count * MAX_KEY_LEN
        orbit @b in 0..@k_len
            @entry_keys[@k_off + @b] = @load_buf[@pos + @b]
        @pos = @pos + @k_len
        @entry_key_lens[@entry_count] = @k_len

        @v_len = @load_buf[@pos] | (@load_buf[@pos + 1] << 8) | (@load_buf[@pos + 2] << 16) | (@load_buf[@pos + 3] << 24)
        @pos = @pos + 4

        @v_off = @entry_count * MAX_VALUE_LEN
        orbit @b in 0..@v_len
            @entry_values[@v_off + @b] = @load_buf[@pos + @b]
        @pos = @pos + @v_len
        @entry_val_lens[@entry_count] = @v_len
        @entry_val_types[@entry_count] = @val_type
        @entry_active[@entry_count] = 1
        @entry_count = @entry_count + 1

    @db_dirty = 0
    return DB_OK

fn db_compact() -> int
    # Compact by removing inactive entries and rewriting
    @write_pos = 0
    orbit @i in 0..@entry_count
        if @entry_active[@i] == 1
            if @write_pos != @i
                # Move entry from i to write_pos
                @sk = @i * MAX_KEY_LEN
                @dk = @write_pos * MAX_KEY_LEN
                orbit @b in 0..@entry_key_lens[@i]
                    @entry_keys[@dk + @b] = @entry_keys[@sk + @b]
                @entry_key_lens[@write_pos] = @entry_key_lens[@i]

                @sv = @i * MAX_VALUE_LEN
                @dv = @write_pos * MAX_VALUE_LEN
                orbit @b in 0..@entry_val_lens[@i]
                    @entry_values[@dv + @b] = @entry_values[@sv + @b]
                @entry_val_lens[@write_pos] = @entry_val_lens[@i]
                @entry_val_types[@write_pos] = @entry_val_types[@i]
                @entry_active[@write_pos] = 1
            @write_pos = @write_pos + 1

    @old_count = @entry_count
    @entry_count = @write_pos
    return @old_count - @write_pos

fn db_clear()
    # Clear all entries
    @entry_count = 0
    @db_dirty = 1
    wal_clear()

# =============================================================================
# SECTION 10: CONVENIENCE FUNCTIONS
# =============================================================================

fn db_put_int(@key: *u8, @key_len: int, @val: int) -> int
    # Store an integer value
    meow @int_buf: [int; 4] = [0; 4]
    @int_buf[0] = @val & 255
    @int_buf[1] = (@val >> 8) & 255
    @int_buf[2] = (@val >> 16) & 255
    @int_buf[3] = (@val >> 24) & 255
    return db_put(@key, @key_len, @int_buf, 4, VAL_INT)

fn db_get_int(@key: *u8, @key_len: int) -> int
    # Retrieve an integer value
    meow @int_buf: [int; 4] = [0; 4]
    @r = db_get(@key, @key_len, @int_buf, 4)
    if @r < 0
        return 0
    return @int_buf[0] | (@int_buf[1] << 8) | (@int_buf[2] << 16) | (@int_buf[3] << 24)

fn db_put_string(@key: *u8, @key_len: int, @val: *u8, @val_len: int) -> int
    return db_put(@key, @key_len, @val, @val_len, VAL_STRING)

fn db_is_dirty() -> int
    return @db_dirty

# =============================================================================
# SECTION 11: EXTERN C API
# =============================================================================

extern "C" fn luna_vault_open(@path: *u8, @len: int) -> int
    return db_load(@path, @len)

extern "C" fn luna_vault_close() -> int
    if @db_dirty == 1
        if @db_path_len > 0
            return db_save(@db_path, @db_path_len)
    return DB_OK

extern "C" fn luna_vault_put(@key: *u8, @klen: int, @val: *u8, @vlen: int, @vtype: int) -> int
    return db_put(@key, @klen, @val, @vlen, @vtype)

extern "C" fn luna_vault_get(@key: *u8, @klen: int, @out: *u8, @max: int) -> int
    return db_get(@key, @klen, @out, @max)

extern "C" fn luna_vault_delete(@key: *u8, @klen: int) -> int
    return db_delete(@key, @klen)

extern "C" fn luna_vault_count() -> int
    return db_count()

extern "C" fn luna_vault_begin() -> int
    return db_begin()

extern "C" fn luna_vault_commit() -> int
    return db_commit()

extern "C" fn luna_vault_rollback() -> int
    return db_rollback()

# =============================================================================
# SECTION 12: SELF-TESTS
# =============================================================================

fn test_db_put_get() -> int
    db_clear()
    @r = db_put("hello", 5, "world", 5, VAL_STRING)
    guard @r == DB_OK, "db: put failed"

    meow @buf: [int; 256] = [0; 256]
    @r = db_get("hello", 5, @buf, 256)
    guard @r == 5, "db: get returned wrong length"

    shine("  [PASS] db put/get")
    return 1

fn test_db_delete() -> int
    db_clear()
    db_put("key1", 4, "val1", 4, VAL_STRING)
    db_put("key2", 4, "val2", 4, VAL_STRING)

    @r = db_delete("key1", 4)
    guard @r == DB_OK, "db: delete failed"

    @r = db_exists("key1", 4)
    guard @r == 0, "db: key1 should not exist after delete"

    @r = db_exists("key2", 4)
    guard @r == 1, "db: key2 should still exist"

    shine("  [PASS] db delete")
    return 1

fn test_db_binary_search() -> int
    db_clear()
    # Insert in non-sorted order; btree_find_insert_pos should maintain sort
    db_put("charlie", 7, "3", 1, VAL_STRING)
    db_put("alpha", 5, "1", 1, VAL_STRING)
    db_put("bravo", 5, "2", 1, VAL_STRING)
    db_put("delta", 5, "4", 1, VAL_STRING)

    @r = db_count()
    guard @r == 4, "db: should have 4 entries"

    # Verify binary search finds all keys
    @r = db_exists("alpha", 5)
    guard @r == 1, "db: alpha should exist"
    @r = db_exists("bravo", 5)
    guard @r == 1, "db: bravo should exist"
    @r = db_exists("charlie", 7)
    guard @r == 1, "db: charlie should exist"
    @r = db_exists("delta", 5)
    guard @r == 1, "db: delta should exist"
    @r = db_exists("echo", 4)
    guard @r == 0, "db: echo should not exist"

    shine("  [PASS] db binary search")
    return 1

fn test_db_update() -> int
    db_clear()
    db_put("key", 3, "old", 3, VAL_STRING)

    meow @buf: [int; 256] = [0; 256]
    @r = db_get("key", 3, @buf, 256)
    guard @r == 3, "db: get old value length wrong"

    db_put("key", 3, "new_value", 9, VAL_STRING)
    @r = db_get("key", 3, @buf, 256)
    guard @r == 9, "db: get new value length wrong"

    @c = db_count()
    guard @c == 1, "db: should still have 1 entry after update"

    shine("  [PASS] db update")
    return 1

fn test_db_transaction() -> int
    db_clear()
    db_put("before", 6, "1", 1, VAL_STRING)

    db_begin()
    db_put("during", 6, "2", 1, VAL_STRING)
    @c = db_count()
    guard @c == 2, "db: should have 2 during tx"

    db_rollback()
    @c = db_count()
    guard @c == 1, "db: should have 1 after rollback"

    @r = db_exists("before", 6)
    guard @r == 1, "db: 'before' should survive rollback"

    shine("  [PASS] db transaction")
    return 1

fn test_db_prefix_query() -> int
    db_clear()
    db_put("user:1:name", 11, "Alice", 5, VAL_STRING)
    db_put("user:1:age", 10, "30", 2, VAL_STRING)
    db_put("user:2:name", 11, "Bob", 3, VAL_STRING)
    db_put("config:theme", 12, "dark", 4, VAL_STRING)

    meow @indices: [int; 64] = [0; 64]
    @r = db_query_prefix("user:1:", 7, @indices, 64)
    guard @r == 2, "db: prefix 'user:1:' should find 2 entries"

    @r = db_query_prefix("user:", 5, @indices, 64)
    guard @r == 3, "db: prefix 'user:' should find 3 entries"

    @r = db_query_prefix("config:", 7, @indices, 64)
    guard @r == 1, "db: prefix 'config:' should find 1 entry"

    shine("  [PASS] db prefix query")
    return 1

fn test_db_types() -> int
    db_clear()
    db_put_int("counter", 7, 42)
    @v = db_get_int("counter", 7)
    guard @v == 42, "db: get_int should return 42"

    db_put_string("name", 4, "Luna", 4)
    @t = db_get_type("name", 4)
    guard @t == VAL_STRING, "db: type should be VAL_STRING"

    @t = db_get_type("counter", 7)
    guard @t == VAL_INT, "db: type should be VAL_INT"

    shine("  [PASS] db types")
    return 1

fn test_db_compact() -> int
    db_clear()
    db_put("a", 1, "1", 1, VAL_STRING)
    db_put("b", 1, "2", 1, VAL_STRING)
    db_put("c", 1, "3", 1, VAL_STRING)
    db_delete("b", 1)

    @c = db_count()
    guard @c == 2, "db: count should be 2 after delete"

    @r = db_compact()
    @c = db_count()
    guard @c == 2, "db: count should be 2 after compact"

    @r = db_exists("a", 1)
    guard @r == 1, "db: 'a' should exist after compact"
    @r = db_exists("c", 1)
    guard @r == 1, "db: 'c' should exist after compact"

    shine("  [PASS] db compact")
    return 1

fn run_db_tests() -> int
    shine("--- db.luna self-tests ---")
    @pass_count = 0
    @pass_count = @pass_count + test_db_put_get()
    @pass_count = @pass_count + test_db_delete()
    @pass_count = @pass_count + test_db_binary_search()
    @pass_count = @pass_count + test_db_update()
    @pass_count = @pass_count + test_db_transaction()
    @pass_count = @pass_count + test_db_prefix_query()
    @pass_count = @pass_count + test_db_types()
    @pass_count = @pass_count + test_db_compact()
    shine("--- db.luna: " + @pass_count + "/8 tests passed ---")
    return @pass_count
