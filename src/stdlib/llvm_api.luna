# (c) 2026 Luna Ecosystem. Lead Architect: LMDtokyo. All rights reserved.
# Licensed under GPLv3. See LICENSE file.

# =============================================================================
# Luna Self-Hosting LLVM 18 API Driver v1.0 "Pulsar"
# =============================================================================
# Pure Luna direct interface to the LLVM C API via FFI.
# No intermediate Rust functions — Luna calls LLVM-C directly.
#
# Architecture:
# ┌────────────────┐    ┌──────────────────┐    ┌─────────────────┐
# │  Luna Compiler  │───▶│  llvm_api.luna   │───▶│  libLLVM-18.so  │
# │  (bootstrap)    │    │  (this file)     │    │  (C API)        │
# └────────────────┘    └──────────────────┘    └─────────────────┘
#
# This module provides:
# 1. All LLVM C API opaque type definitions
# 2. Complete enum/constant mappings for LLVM 18
# 3. 100+ FFI function declarations for direct LLVM-C calls
# 4. High-level Luna wrapper structs (LlvmContext, LlvmModule, etc.)
# 5. Optimization pipeline (O0-Oz, LTO, PGO)
# 6. CPU feature detection and target triple management
# 7. IR generation types matching backend/llvm.rs
#
# Usage:
#   import llvm_api
#   @ctx = llvm_context_new("my_module")
#   @i32_ty = llvm_int32_type(@ctx.context)
#   ...
#   llvm_context_dispose(@ctx)
#
# Requires: LLVM 18 shared library on system PATH or LD_LIBRARY_PATH
# =============================================================================

import parser

# =============================================================================
# SECTION 1: LLVM OPAQUE POINTER TYPES
# =============================================================================
# All LLVM C API types are opaque pointers. Luna represents them as RawPtr.
# The type aliases improve readability and document intent.

const LLVMBool: type = i32                  # LLVM uses i32 for boolean returns

# --- Core IR Types ---
const LLVMContextRef: type = RawPtr         # Opaque LLVM context handle
const LLVMModuleRef: type = RawPtr          # Opaque LLVM module handle
const LLVMBuilderRef: type = RawPtr         # Opaque IR builder handle
const LLVMTypeRef: type = RawPtr            # Opaque LLVM type handle
const LLVMValueRef: type = RawPtr           # Opaque LLVM value handle
const LLVMBasicBlockRef: type = RawPtr      # Opaque basic block handle
const LLVMAttributeRef: type = RawPtr       # Opaque attribute handle
const LLVMDiagnosticInfoRef: type = RawPtr  # Opaque diagnostic info handle
const LLVMNamedMDNodeRef: type = RawPtr     # Opaque named metadata node
const LLVMMetadataRef: type = RawPtr        # Opaque metadata handle
const LLVMUseRef: type = RawPtr             # Opaque use handle

# --- Target Machine Types ---
const LLVMTargetRef: type = RawPtr          # Opaque target handle
const LLVMTargetMachineRef: type = RawPtr   # Opaque target machine handle
const LLVMTargetDataRef: type = RawPtr      # Opaque target data layout handle

# --- Pass Manager Types ---
const LLVMPassManagerRef: type = RawPtr     # Opaque pass manager handle
const LLVMPassBuilderOptionsRef: type = RawPtr  # LLVM 18 new pass manager options

# --- Memory and Execution Types ---
const LLVMMemoryBufferRef: type = RawPtr    # Opaque memory buffer handle
const LLVMExecutionEngineRef: type = RawPtr # Opaque MCJIT execution engine
const LLVMGenericValueRef: type = RawPtr    # Opaque generic value for JIT
const LLVMMCJITCompilerOptions: type = RawPtr  # MCJIT options struct pointer

# --- Object File Types ---
const LLVMObjectFileRef: type = RawPtr      # Opaque object file handle
const LLVMSectionIteratorRef: type = RawPtr # Section iterator
const LLVMSymbolIteratorRef: type = RawPtr  # Symbol iterator

# =============================================================================
# SECTION 2: LLVM ENUMERATIONS AND CONSTANTS
# =============================================================================

# -----------------------------------------------------------------------------
# 2.1 Integer Comparison Predicates (LLVMIntPredicate)
# -----------------------------------------------------------------------------
# Used with LLVMBuildICmp to compare integer values.
# Values match the LLVM C API enum LLVMIntPredicate.

const LLVMIntEQ: u32 = 32                  # Equal
const LLVMIntNE: u32 = 33                  # Not equal
const LLVMIntUGT: u32 = 34                 # Unsigned greater than
const LLVMIntUGE: u32 = 35                 # Unsigned greater or equal
const LLVMIntULT: u32 = 36                 # Unsigned less than
const LLVMIntULE: u32 = 37                 # Unsigned less or equal
const LLVMIntSGT: u32 = 38                 # Signed greater than
const LLVMIntSGE: u32 = 39                 # Signed greater or equal
const LLVMIntSLT: u32 = 40                 # Signed less than
const LLVMIntSLE: u32 = 41                 # Signed less or equal

# -----------------------------------------------------------------------------
# 2.2 Floating-Point Comparison Predicates (LLVMRealPredicate)
# -----------------------------------------------------------------------------
# Used with LLVMBuildFCmp. "O" = ordered (no NaN), "U" = unordered (NaN ok).

const LLVMRealPredicateFalse: u32 = 0      # Always false
const LLVMRealOEQ: u32 = 1                 # Ordered and equal
const LLVMRealOGT: u32 = 2                 # Ordered and greater than
const LLVMRealOGE: u32 = 3                 # Ordered and greater or equal
const LLVMRealOLT: u32 = 4                 # Ordered and less than
const LLVMRealOLE: u32 = 5                 # Ordered and less or equal
const LLVMRealONE: u32 = 6                 # Ordered and not equal
const LLVMRealORD: u32 = 7                 # Ordered (no NaN)
const LLVMRealUNO: u32 = 8                 # Unordered (either NaN)
const LLVMRealUEQ: u32 = 9                 # Unordered or equal
const LLVMRealUGT: u32 = 10                # Unordered or greater than
const LLVMRealUGE: u32 = 11                # Unordered or greater or equal
const LLVMRealULT: u32 = 12                # Unordered or less than
const LLVMRealULE: u32 = 13                # Unordered or less or equal
const LLVMRealUNE: u32 = 14                # Unordered or not equal
const LLVMRealPredicateTrue: u32 = 15      # Always true

# -----------------------------------------------------------------------------
# 2.3 LLVM Opcodes (LLVMOpcode)
# -----------------------------------------------------------------------------
# Instruction opcode values from LLVMOpcode enum.

# Terminator instructions
const LLVMRet: u32 = 1                     # Return from function
const LLVMBr: u32 = 2                      # Branch (conditional or unconditional)
const LLVMSwitch: u32 = 3                  # Switch statement
const LLVMIndirectBr: u32 = 4              # Indirect branch
const LLVMInvoke: u32 = 5                  # Invoke (call with exception handling)
const LLVMUnreachable: u32 = 7             # Unreachable instruction

# Binary operators
const LLVMAdd: u32 = 8                     # Integer addition
const LLVMFAdd: u32 = 9                    # Floating-point addition
const LLVMSub: u32 = 10                    # Integer subtraction
const LLVMFSub: u32 = 11                   # Floating-point subtraction
const LLVMMul: u32 = 12                    # Integer multiplication
const LLVMFMul: u32 = 13                   # Floating-point multiplication
const LLVMUDiv: u32 = 14                   # Unsigned integer division
const LLVMSDiv: u32 = 15                   # Signed integer division
const LLVMFDiv: u32 = 16                   # Floating-point division
const LLVMURem: u32 = 17                   # Unsigned integer remainder
const LLVMSRem: u32 = 18                   # Signed integer remainder
const LLVMFRem: u32 = 19                   # Floating-point remainder

# Bitwise binary operators
const LLVMShl: u32 = 20                    # Shift left
const LLVMLShr: u32 = 21                   # Logical shift right
const LLVMAShr: u32 = 22                   # Arithmetic shift right
const LLVMAnd: u32 = 23                    # Bitwise AND
const LLVMOr: u32 = 24                     # Bitwise OR
const LLVMXor: u32 = 25                    # Bitwise XOR

# Memory operators
const LLVMAlloca: u32 = 26                 # Stack allocation
const LLVMLoad: u32 = 27                   # Load from memory
const LLVMStore: u32 = 28                  # Store to memory
const LLVMGetElementPtr: u32 = 29          # Get element pointer (GEP)

# Cast operators
const LLVMTrunc: u32 = 30                  # Truncate integer
const LLVMZExt: u32 = 31                   # Zero extend integer
const LLVMSExt: u32 = 32                   # Sign extend integer
const LLVMFPToUI: u32 = 33                 # Float to unsigned int
const LLVMFPToSI: u32 = 34                 # Float to signed int
const LLVMUIToFP: u32 = 35                 # Unsigned int to float
const LLVMSIToFP: u32 = 36                 # Signed int to float
const LLVMFPTrunc: u32 = 37                # Truncate float
const LLVMFPExt: u32 = 38                  # Extend float
const LLVMPtrToInt: u32 = 39               # Pointer to integer
const LLVMIntToPtr: u32 = 40               # Integer to pointer
const LLVMBitCast: u32 = 41                # Bitwise cast
const LLVMAddrSpaceCast: u32 = 60          # Address space cast

# Other operators
const LLVMICmp: u32 = 42                   # Integer comparison
const LLVMFCmp: u32 = 43                   # Float comparison
const LLVMPHI: u32 = 44                    # PHI node
const LLVMCall: u32 = 45                   # Function call
const LLVMSelect: u32 = 46                 # Select (ternary)
const LLVMUserOp1: u32 = 47                # User-defined op 1
const LLVMUserOp2: u32 = 48                # User-defined op 2
const LLVMVAArg: u32 = 49                  # Variable argument access
const LLVMExtractElement: u32 = 50         # Extract from vector
const LLVMInsertElement: u32 = 51          # Insert into vector
const LLVMShuffleVector: u32 = 52          # Shuffle two vectors
const LLVMExtractValue: u32 = 53           # Extract from aggregate
const LLVMInsertValue: u32 = 54            # Insert into aggregate
const LLVMFreeze: u32 = 68                 # Freeze poison/undef value

# Atomic operations
const LLVMFence: u32 = 55                  # Memory fence
const LLVMAtomicCmpXchg: u32 = 56          # Atomic compare-exchange
const LLVMAtomicRMW: u32 = 57              # Atomic read-modify-write

# Exception handling
const LLVMResume: u32 = 58                 # Resume exception propagation
const LLVMLandingPad: u32 = 59             # Landing pad for exceptions
const LLVMCleanupRet: u32 = 61             # Cleanup return
const LLVMCatchRet: u32 = 62               # Catch return
const LLVMCatchPad: u32 = 63               # Catch pad
const LLVMCleanupPad: u32 = 64             # Cleanup pad
const LLVMCatchSwitch: u32 = 65            # Catch switch

# Call-related
const LLVMCallBr: u32 = 66                 # Call with branch targets
const LLVMFNeg: u32 = 67                   # Floating-point negation

# -----------------------------------------------------------------------------
# 2.4 Code Generation Optimization Levels
# -----------------------------------------------------------------------------

const LLVMCodeGenLevelNone: u32 = 0        # No optimization (-O0)
const LLVMCodeGenLevelLess: u32 = 1        # Light optimization (-O1)
const LLVMCodeGenLevelDefault: u32 = 2     # Standard optimization (-O2)
const LLVMCodeGenLevelAggressive: u32 = 3  # Aggressive optimization (-O3)

# -----------------------------------------------------------------------------
# 2.5 Relocation Model
# -----------------------------------------------------------------------------

const LLVMRelocDefault: u32 = 0            # Target default relocation
const LLVMRelocStatic: u32 = 1             # Non-relocatable code
const LLVMRelocPIC: u32 = 2                # Position-independent code
const LLVMRelocDynamicNoPic: u32 = 3       # Dynamic, not PIC (macOS)
const LLVMRelocROPI: u32 = 4               # Read-only position independent
const LLVMRelocRWPI: u32 = 5               # Read-write position independent
const LLVMRelocROPI_RWPI: u32 = 6          # Both ROPI and RWPI

# -----------------------------------------------------------------------------
# 2.6 Code Model
# -----------------------------------------------------------------------------

const LLVMCodeModelDefault: u32 = 0        # Target default code model
const LLVMCodeModelJITDefault: u32 = 1     # JIT default
const LLVMCodeModelTiny: u32 = 2           # Tiny (AArch64)
const LLVMCodeModelSmall: u32 = 3          # Small (most common)
const LLVMCodeModelKernel: u32 = 4         # Kernel code model
const LLVMCodeModelMedium: u32 = 5         # Medium
const LLVMCodeModelLarge: u32 = 6          # Large (no assumptions on addresses)

# -----------------------------------------------------------------------------
# 2.7 Code Generation File Type
# -----------------------------------------------------------------------------

const LLVMAssemblyFile: u32 = 0            # Emit assembly (.s)
const LLVMObjectFile: u32 = 1              # Emit object file (.o / .obj)

# -----------------------------------------------------------------------------
# 2.8 Linkage Types
# -----------------------------------------------------------------------------

const LLVMExternalLinkage: u32 = 0         # Externally visible function
const LLVMAvailableExternallyLinkage: u32 = 1  # Available for inspection, not emission
const LLVMLinkOnceAnyLinkage: u32 = 2      # Keep one copy when linking (any)
const LLVMLinkOnceODRLinkage: u32 = 3      # Keep one copy (one definition rule)
const LLVMLinkOnceODRAutoHideLinkage: u32 = 4  # ODR + auto hide
const LLVMWeakAnyLinkage: u32 = 5          # Weak linkage (any)
const LLVMWeakODRLinkage: u32 = 6          # Weak ODR linkage
const LLVMAppendingLinkage: u32 = 7        # Special: append to array
const LLVMInternalLinkage: u32 = 8         # Module-internal (static)
const LLVMPrivateLinkage: u32 = 9          # Private to module
const LLVMDLLImportLinkage: u32 = 10       # DLL import (Windows)
const LLVMDLLExportLinkage: u32 = 11       # DLL export (Windows)
const LLVMExternalWeakLinkage: u32 = 12    # External weak
const LLVMGhostLinkage: u32 = 13           # Ghost (obsolete)
const LLVMCommonLinkage: u32 = 14          # Tentative definition
const LLVMLinkerPrivateLinkage: u32 = 15   # Linker private
const LLVMLinkerPrivateWeakLinkage: u32 = 16  # Linker private weak

# -----------------------------------------------------------------------------
# 2.9 Visibility
# -----------------------------------------------------------------------------

const LLVMDefaultVisibility: u32 = 0       # Default visibility
const LLVMHiddenVisibility: u32 = 1        # Hidden symbol
const LLVMProtectedVisibility: u32 = 2     # Protected symbol

# -----------------------------------------------------------------------------
# 2.10 Calling Conventions
# -----------------------------------------------------------------------------

const LLVMCCallConv: u32 = 0               # Standard C calling convention
const LLVMFastCallConv: u32 = 8            # Fast call convention
const LLVMColdCallConv: u32 = 9            # Cold call (rarely invoked)
const LLVMWebKitJSCallConv: u32 = 12       # WebKit JavaScript
const LLVMAnyRegCallConv: u32 = 13         # Any register
const LLVMX86StdcallCallConv: u32 = 64     # x86 stdcall
const LLVMX86FastcallCallConv: u32 = 65    # x86 fastcall
const LLVMWin64CallConv: u32 = 79          # Windows x64
const LLVMX86VectorCallConv: u32 = 80      # x86 vectorcall
const LLVMSwiftCallConv: u32 = 16          # Swift calling convention
const LLVMTailCallConv: u32 = 18           # Guaranteed tail call

# -----------------------------------------------------------------------------
# 2.11 Module Verification Actions
# -----------------------------------------------------------------------------

const LLVMAbortProcessAction: u32 = 0      # Abort on verification failure
const LLVMPrintMessageAction: u32 = 1      # Print error message
const LLVMReturnStatusAction: u32 = 2      # Return status code

# -----------------------------------------------------------------------------
# 2.12 Thread-Local Storage Modes
# -----------------------------------------------------------------------------

const LLVMNotThreadLocal: u32 = 0          # Not thread-local
const LLVMGeneralDynamicTLSModel: u32 = 1  # General dynamic TLS
const LLVMLocalDynamicTLSModel: u32 = 2    # Local dynamic TLS
const LLVMInitialExecTLSModel: u32 = 3     # Initial exec TLS
const LLVMLocalExecTLSModel: u32 = 4       # Local exec TLS

# -----------------------------------------------------------------------------
# 2.13 Atomic Ordering
# -----------------------------------------------------------------------------

const LLVMAtomicOrderingNotAtomic: u32 = 0              # Not atomic
const LLVMAtomicOrderingUnordered: u32 = 1               # Unordered
const LLVMAtomicOrderingMonotonic: u32 = 2               # Monotonic
const LLVMAtomicOrderingAcquire: u32 = 4                 # Acquire
const LLVMAtomicOrderingRelease: u32 = 5                 # Release
const LLVMAtomicOrderingAcquireRelease: u32 = 6          # Acquire-Release
const LLVMAtomicOrderingSequentiallyConsistent: u32 = 7  # Sequentially consistent

# -----------------------------------------------------------------------------
# 2.14 Atomic RMW Binary Operations
# -----------------------------------------------------------------------------

const LLVMAtomicRMWBinOpXchg: u32 = 0     # Exchange
const LLVMAtomicRMWBinOpAdd: u32 = 1      # Add
const LLVMAtomicRMWBinOpSub: u32 = 2      # Subtract
const LLVMAtomicRMWBinOpAnd: u32 = 3      # AND
const LLVMAtomicRMWBinOpNand: u32 = 4     # NAND
const LLVMAtomicRMWBinOpOr: u32 = 5       # OR
const LLVMAtomicRMWBinOpXor: u32 = 6      # XOR
const LLVMAtomicRMWBinOpMax: u32 = 7      # Signed max
const LLVMAtomicRMWBinOpMin: u32 = 8      # Signed min
const LLVMAtomicRMWBinOpUMax: u32 = 9     # Unsigned max
const LLVMAtomicRMWBinOpUMin: u32 = 10    # Unsigned min
const LLVMAtomicRMWBinOpFAdd: u32 = 11    # Float add
const LLVMAtomicRMWBinOpFSub: u32 = 12    # Float sub
const LLVMAtomicRMWBinOpFMax: u32 = 13    # Float max
const LLVMAtomicRMWBinOpFMin: u32 = 14    # Float min

# -----------------------------------------------------------------------------
# 2.15 Inline Assembly Dialect
# -----------------------------------------------------------------------------

const LLVMInlineAsmDialectATT: u32 = 0    # AT&T syntax
const LLVMInlineAsmDialectIntel: u32 = 1   # Intel syntax

# -----------------------------------------------------------------------------
# 2.16 Luna Optimization Level Constants
# -----------------------------------------------------------------------------
# These map to our pipeline levels, not raw LLVM code gen levels.

const OPT_O0: u32 = 0                      # No optimization
const OPT_O1: u32 = 1                      # Basic optimizations
const OPT_O2: u32 = 2                      # Standard optimizations
const OPT_O3: u32 = 3                      # Aggressive optimizations
const OPT_Os: u32 = 4                      # Optimize for size
const OPT_Oz: u32 = 5                      # Aggressive size optimization

# =============================================================================
# SECTION 3: LLVM C API FFI DECLARATIONS
# =============================================================================
# Direct bindings to libLLVM-18 C API functions.
# All calls require `unsafe` blocks in Luna code.
# Library: "LLVM-18" (Linux/macOS) or "LLVM-C" (Windows)

# -----------------------------------------------------------------------------
# 3.1 Context Management
# -----------------------------------------------------------------------------
# The LLVM context owns all IR objects. Thread-safe when using separate contexts.

# Create a new LLVM context. Each context is independent and thread-safe.
# Returns: a new context handle, must be disposed with LLVMContextDispose
extern "C" fn LLVMContextCreate() -> LLVMContextRef

# Dispose of a context and all IR objects it owns.
# After this call, all modules/types/values from this context are invalid.
extern "C" fn LLVMContextDispose(@C: LLVMContextRef)

# Get the global (non-thread-safe) LLVM context.
# WARNING: Not safe for concurrent compilation. Prefer LLVMContextCreate.
extern "C" fn LLVMGetGlobalContext() -> LLVMContextRef

# Set a diagnostic handler callback on the context.
extern "C" fn LLVMContextSetDiagnosticHandler(@C: LLVMContextRef, @Handler: RawPtr, @DiagnosticContext: RawPtr)

# Get whether the context discards all value names (for memory savings).
extern "C" fn LLVMContextShouldDiscardValueNames(@C: LLVMContextRef) -> LLVMBool

# Set whether the context discards value names.
extern "C" fn LLVMContextSetDiscardValueNames(@C: LLVMContextRef, @Discard: LLVMBool)

# -----------------------------------------------------------------------------
# 3.2 Module Management
# -----------------------------------------------------------------------------
# Modules are the top-level LLVM IR container. Each module holds functions,
# globals, and metadata. Modules belong to exactly one context.

# Create a new module with a name within a context.
# @ModuleID: human-readable name for the module
# @C: the owning context
extern "C" fn LLVMModuleCreateWithNameInContext(@ModuleID: *u8, @C: LLVMContextRef) -> LLVMModuleRef

# Dispose of a module and free its memory.
extern "C" fn LLVMDisposeModule(@M: LLVMModuleRef)

# Get the module identifier (name).
extern "C" fn LLVMGetModuleIdentifier(@M: LLVMModuleRef, @Len: *u64) -> *u8

# Set the module identifier.
extern "C" fn LLVMSetModuleIdentifier(@M: LLVMModuleRef, @Ident: *u8, @Len: u64)

# Get the source file name associated with the module.
extern "C" fn LLVMGetSourceFileName(@M: LLVMModuleRef, @Len: *u64) -> *u8

# Set the source file name.
extern "C" fn LLVMSetSourceFileName(@M: LLVMModuleRef, @Name: *u8, @Len: u64)

# Set the target triple for this module (e.g., "x86_64-pc-linux-gnu").
extern "C" fn LLVMSetTarget(@M: LLVMModuleRef, @Triple: *u8)

# Get the target triple string.
extern "C" fn LLVMGetTarget(@M: LLVMModuleRef) -> *u8

# Set the data layout string (e.g., "e-m:e-p270:32:32-p271:32:32-...").
extern "C" fn LLVMSetDataLayout(@M: LLVMModuleRef, @DataLayoutStr: *u8)

# Get the data layout string.
extern "C" fn LLVMGetDataLayout(@M: LLVMModuleRef) -> *u8

# Print the full LLVM IR of the module to a string.
# Caller must free the returned string with LLVMDisposeMessage.
extern "C" fn LLVMPrintModuleToString(@M: LLVMModuleRef) -> *u8

# Print the module IR to a file.
extern "C" fn LLVMPrintModuleToFile(@M: LLVMModuleRef, @Filename: *u8, @ErrorMessage: **u8) -> LLVMBool

# Verify the module IR for correctness.
# @Action: LLVMAbortProcessAction, LLVMPrintMessageAction, or LLVMReturnStatusAction
# Returns: 0 on success, non-zero on failure
extern "C" fn LLVMVerifyModule(@M: LLVMModuleRef, @Action: u32, @OutMessage: **u8) -> LLVMBool

# Clone an entire module (deep copy).
extern "C" fn LLVMCloneModule(@M: LLVMModuleRef) -> LLVMModuleRef

# Link a source module into a destination module (destructive to Src).
# Returns: 0 on success
extern "C" fn LLVMLinkModules2(@Dest: LLVMModuleRef, @Src: LLVMModuleRef) -> LLVMBool

# Get the context that owns this module.
extern "C" fn LLVMGetModuleContext(@M: LLVMModuleRef) -> LLVMContextRef

# Add a module-level flag (metadata).
extern "C" fn LLVMAddModuleFlag(@M: LLVMModuleRef, @Behavior: u32, @Key: *u8, @KeyLen: u64, @Val: LLVMMetadataRef)

# Write LLVM bitcode to a file.
extern "C" fn LLVMWriteBitcodeToFile(@M: LLVMModuleRef, @Path: *u8) -> i32

# Write LLVM bitcode to a memory buffer.
extern "C" fn LLVMWriteBitcodeToMemoryBuffer(@M: LLVMModuleRef) -> LLVMMemoryBufferRef

# -----------------------------------------------------------------------------
# 3.3 IR Builder - Creation and Positioning
# -----------------------------------------------------------------------------
# The IR builder is the primary interface for generating LLVM IR instructions.
# Position the builder at a basic block, then call Build* methods.

# Create a new IR builder within a context.
extern "C" fn LLVMCreateBuilderInContext(@C: LLVMContextRef) -> LLVMBuilderRef

# Dispose of a builder.
extern "C" fn LLVMDisposeBuilder(@Builder: LLVMBuilderRef)

# Position the builder at the end of a basic block.
extern "C" fn LLVMPositionBuilderAtEnd(@Builder: LLVMBuilderRef, @Block: LLVMBasicBlockRef)

# Position the builder before a specific instruction.
extern "C" fn LLVMPositionBuilderBefore(@Builder: LLVMBuilderRef, @Instr: LLVMValueRef)

# Get the basic block the builder is currently positioned in.
extern "C" fn LLVMGetInsertBlock(@Builder: LLVMBuilderRef) -> LLVMBasicBlockRef

# Clear the builder's current insertion point.
extern "C" fn LLVMClearInsertionPosition(@Builder: LLVMBuilderRef)

# Set current debug location for the builder.
extern "C" fn LLVMSetCurrentDebugLocation2(@Builder: LLVMBuilderRef, @Loc: LLVMMetadataRef)

# -----------------------------------------------------------------------------
# 3.4 IR Builder - Terminator Instructions
# -----------------------------------------------------------------------------

# Build a return instruction with a value.
extern "C" fn LLVMBuildRet(@Builder: LLVMBuilderRef, @V: LLVMValueRef) -> LLVMValueRef

# Build a void return instruction.
extern "C" fn LLVMBuildRetVoid(@Builder: LLVMBuilderRef) -> LLVMValueRef

# Build a return with multiple aggregate values.
extern "C" fn LLVMBuildAggregateRet(@Builder: LLVMBuilderRef, @RetVals: *LLVMValueRef, @N: u32) -> LLVMValueRef

# Build an unconditional branch to a target block.
extern "C" fn LLVMBuildBr(@Builder: LLVMBuilderRef, @Dest: LLVMBasicBlockRef) -> LLVMValueRef

# Build a conditional branch.
# If @If is true, branch to @Then; otherwise branch to @Else.
extern "C" fn LLVMBuildCondBr(@Builder: LLVMBuilderRef, @If: LLVMValueRef, @Then: LLVMBasicBlockRef, @Else: LLVMBasicBlockRef) -> LLVMValueRef

# Build a switch instruction.
# @V: value to switch on
# @Else: default target block
# @NumCases: expected number of cases (hint for allocation)
extern "C" fn LLVMBuildSwitch(@Builder: LLVMBuilderRef, @V: LLVMValueRef, @Else: LLVMBasicBlockRef, @NumCases: u32) -> LLVMValueRef

# Add a case to a switch instruction.
extern "C" fn LLVMAddCase(@Switch: LLVMValueRef, @OnVal: LLVMValueRef, @Dest: LLVMBasicBlockRef)

# Build an indirect branch.
extern "C" fn LLVMBuildIndirectBr(@Builder: LLVMBuilderRef, @Addr: LLVMValueRef, @NumDests: u32) -> LLVMValueRef

# Build an invoke instruction (call with exception handling).
extern "C" fn LLVMBuildInvoke2(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Fn: LLVMValueRef, @Args: *LLVMValueRef, @NumArgs: u32, @Then: LLVMBasicBlockRef, @Catch: LLVMBasicBlockRef, @Name: *u8) -> LLVMValueRef

# Build an unreachable instruction.
extern "C" fn LLVMBuildUnreachable(@Builder: LLVMBuilderRef) -> LLVMValueRef

# Build a resume instruction (resume exception propagation).
extern "C" fn LLVMBuildResume(@Builder: LLVMBuilderRef, @Exn: LLVMValueRef) -> LLVMValueRef

# Build a landing pad instruction for exception handling.
extern "C" fn LLVMBuildLandingPad(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @PersFn: LLVMValueRef, @NumClauses: u32, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.5 IR Builder - Integer Arithmetic
# -----------------------------------------------------------------------------

# Integer addition: LHS + RHS
extern "C" fn LLVMBuildAdd(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer addition with no-signed-wrap flag.
extern "C" fn LLVMBuildNSWAdd(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer addition with no-unsigned-wrap flag.
extern "C" fn LLVMBuildNUWAdd(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer subtraction: LHS - RHS
extern "C" fn LLVMBuildSub(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer subtraction with NSW.
extern "C" fn LLVMBuildNSWSub(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer subtraction with NUW.
extern "C" fn LLVMBuildNUWSub(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer multiplication: LHS * RHS
extern "C" fn LLVMBuildMul(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer multiplication with NSW.
extern "C" fn LLVMBuildNSWMul(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer multiplication with NUW.
extern "C" fn LLVMBuildNUWMul(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Signed integer division: LHS / RHS
extern "C" fn LLVMBuildSDiv(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Exact signed division (undefined if not exact).
extern "C" fn LLVMBuildExactSDiv(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Unsigned integer division: LHS / RHS
extern "C" fn LLVMBuildUDiv(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Exact unsigned division.
extern "C" fn LLVMBuildExactUDiv(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Signed integer remainder: LHS % RHS
extern "C" fn LLVMBuildSRem(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Unsigned integer remainder: LHS % RHS
extern "C" fn LLVMBuildURem(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer negation: -V
extern "C" fn LLVMBuildNeg(@Builder: LLVMBuilderRef, @V: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer negation with NSW.
extern "C" fn LLVMBuildNSWNeg(@Builder: LLVMBuilderRef, @V: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Integer negation with NUW.
extern "C" fn LLVMBuildNUWNeg(@Builder: LLVMBuilderRef, @V: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.6 IR Builder - Floating-Point Arithmetic
# -----------------------------------------------------------------------------

# Float addition: LHS + RHS
extern "C" fn LLVMBuildFAdd(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Float subtraction: LHS - RHS
extern "C" fn LLVMBuildFSub(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Float multiplication: LHS * RHS
extern "C" fn LLVMBuildFMul(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Float division: LHS / RHS
extern "C" fn LLVMBuildFDiv(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Float remainder: LHS % RHS
extern "C" fn LLVMBuildFRem(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Float negation: -V
extern "C" fn LLVMBuildFNeg(@Builder: LLVMBuilderRef, @V: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.7 IR Builder - Bitwise Operations
# -----------------------------------------------------------------------------

# Bitwise AND: LHS & RHS
extern "C" fn LLVMBuildAnd(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Bitwise OR: LHS | RHS
extern "C" fn LLVMBuildOr(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Bitwise XOR: LHS ^ RHS
extern "C" fn LLVMBuildXor(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Shift left: LHS << RHS
extern "C" fn LLVMBuildShl(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Logical shift right: LHS >> RHS (zero fill)
extern "C" fn LLVMBuildLShr(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Arithmetic shift right: LHS >> RHS (sign extend)
extern "C" fn LLVMBuildAShr(@Builder: LLVMBuilderRef, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Bitwise NOT: ~V
extern "C" fn LLVMBuildNot(@Builder: LLVMBuilderRef, @V: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.8 IR Builder - Memory Operations
# -----------------------------------------------------------------------------

# Allocate space on the stack for a value of the given type.
extern "C" fn LLVMBuildAlloca(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Allocate an array on the stack.
extern "C" fn LLVMBuildArrayAlloca(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Val: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Load a value from a pointer (typed, LLVM 18 opaque pointer compatible).
# @Ty: the type of the value being loaded
# @PointerVal: the pointer to load from
extern "C" fn LLVMBuildLoad2(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @PointerVal: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Store a value to a pointer.
extern "C" fn LLVMBuildStore(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @Ptr: LLVMValueRef) -> LLVMValueRef

# Build a GEP (Get Element Pointer) instruction with explicit type.
# This is the LLVM 18 opaque-pointer-compatible version.
extern "C" fn LLVMBuildGEP2(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Pointer: LLVMValueRef, @Indices: *LLVMValueRef, @NumIndices: u32, @Name: *u8) -> LLVMValueRef

# Build an inbounds GEP (undefined behavior if out of bounds).
extern "C" fn LLVMBuildInBoundsGEP2(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Pointer: LLVMValueRef, @Indices: *LLVMValueRef, @NumIndices: u32, @Name: *u8) -> LLVMValueRef

# Build a struct GEP with explicit type (accessing a struct field).
extern "C" fn LLVMBuildStructGEP2(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Pointer: LLVMValueRef, @Idx: u32, @Name: *u8) -> LLVMValueRef

# Build a global string pointer (creates a global constant string).
extern "C" fn LLVMBuildGlobalStringPtr(@Builder: LLVMBuilderRef, @Str: *u8, @Name: *u8) -> LLVMValueRef

# Build a memset intrinsic call.
extern "C" fn LLVMBuildMemSet(@Builder: LLVMBuilderRef, @Ptr: LLVMValueRef, @Val: LLVMValueRef, @Len: LLVMValueRef, @Align: u32) -> LLVMValueRef

# Build a memcpy intrinsic call.
extern "C" fn LLVMBuildMemCpy(@Builder: LLVMBuilderRef, @Dst: LLVMValueRef, @DstAlign: u32, @Src: LLVMValueRef, @SrcAlign: u32, @Size: LLVMValueRef) -> LLVMValueRef

# Build a memmove intrinsic call.
extern "C" fn LLVMBuildMemMove(@Builder: LLVMBuilderRef, @Dst: LLVMValueRef, @DstAlign: u32, @Src: LLVMValueRef, @SrcAlign: u32, @Size: LLVMValueRef) -> LLVMValueRef

# Build an atomic fence instruction.
extern "C" fn LLVMBuildFence(@Builder: LLVMBuilderRef, @Ordering: u32, @SingleThread: LLVMBool, @Name: *u8) -> LLVMValueRef

# Build an atomic compare-and-exchange instruction.
extern "C" fn LLVMBuildAtomicCmpXchg(@Builder: LLVMBuilderRef, @Ptr: LLVMValueRef, @Cmp: LLVMValueRef, @New: LLVMValueRef, @SuccessOrdering: u32, @FailureOrdering: u32, @SingleThread: LLVMBool) -> LLVMValueRef

# Build an atomic read-modify-write instruction.
extern "C" fn LLVMBuildAtomicRMW(@Builder: LLVMBuilderRef, @Op: u32, @Ptr: LLVMValueRef, @Val: LLVMValueRef, @Ordering: u32, @SingleThread: LLVMBool) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.9 IR Builder - Comparison Operations
# -----------------------------------------------------------------------------

# Build an integer comparison.
# @Op: LLVMIntEQ, LLVMIntNE, LLVMIntSLT, etc.
extern "C" fn LLVMBuildICmp(@Builder: LLVMBuilderRef, @Op: u32, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Build a floating-point comparison.
# @Op: LLVMRealOEQ, LLVMRealOLT, etc.
extern "C" fn LLVMBuildFCmp(@Builder: LLVMBuilderRef, @Op: u32, @LHS: LLVMValueRef, @RHS: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.10 IR Builder - Conversion / Cast Operations
# -----------------------------------------------------------------------------

# Truncate an integer to a smaller type.
extern "C" fn LLVMBuildTrunc(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Zero-extend an integer to a larger type.
extern "C" fn LLVMBuildZExt(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Sign-extend an integer to a larger type.
extern "C" fn LLVMBuildSExt(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Truncate a float to a smaller float type (e.g., double -> float).
extern "C" fn LLVMBuildFPTrunc(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Extend a float to a larger float type (e.g., float -> double).
extern "C" fn LLVMBuildFPExt(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Convert float to unsigned integer.
extern "C" fn LLVMBuildFPToUI(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Convert float to signed integer.
extern "C" fn LLVMBuildFPToSI(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Convert unsigned integer to float.
extern "C" fn LLVMBuildUIToFP(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Convert signed integer to float.
extern "C" fn LLVMBuildSIToFP(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Convert a pointer to an integer.
extern "C" fn LLVMBuildPtrToInt(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Convert an integer to a pointer.
extern "C" fn LLVMBuildIntToPtr(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Bitwise cast (reinterpret bits, same size required).
extern "C" fn LLVMBuildBitCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Address space cast (pointer between address spaces).
extern "C" fn LLVMBuildAddrSpaceCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Automatic cast that picks the right conversion.
extern "C" fn LLVMBuildZExtOrBitCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

extern "C" fn LLVMBuildSExtOrBitCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

extern "C" fn LLVMBuildTruncOrBitCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

extern "C" fn LLVMBuildPointerCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

extern "C" fn LLVMBuildIntCast2(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @IsSigned: LLVMBool, @Name: *u8) -> LLVMValueRef

extern "C" fn LLVMBuildFPCast(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @DestTy: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.11 IR Builder - Miscellaneous Instructions
# -----------------------------------------------------------------------------

# Build a function call (typed, LLVM 18 opaque pointer compatible).
# @Ty: the function type being called
# @Fn: the function value (or function pointer)
# @Args: pointer to array of argument values
# @NumArgs: number of arguments
extern "C" fn LLVMBuildCall2(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Fn: LLVMValueRef, @Args: *LLVMValueRef, @NumArgs: u32, @Name: *u8) -> LLVMValueRef

# Build a select instruction (ternary: if cond then T else F).
extern "C" fn LLVMBuildSelect(@Builder: LLVMBuilderRef, @If: LLVMValueRef, @Then: LLVMValueRef, @Else: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Build a PHI node. Incoming values are added later with LLVMAddIncoming.
extern "C" fn LLVMBuildPhi(@Builder: LLVMBuilderRef, @Ty: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Build a VA_ARG instruction (access variable arguments).
extern "C" fn LLVMBuildVAArg(@Builder: LLVMBuilderRef, @List: LLVMValueRef, @Ty: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Build an extract-element from a vector.
extern "C" fn LLVMBuildExtractElement(@Builder: LLVMBuilderRef, @VecVal: LLVMValueRef, @Index: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Build an insert-element into a vector.
extern "C" fn LLVMBuildInsertElement(@Builder: LLVMBuilderRef, @VecVal: LLVMValueRef, @EltVal: LLVMValueRef, @Index: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Build a shuffle-vector instruction (combine/reorder two vectors).
extern "C" fn LLVMBuildShuffleVector(@Builder: LLVMBuilderRef, @V1: LLVMValueRef, @V2: LLVMValueRef, @Mask: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Build an extract-value from an aggregate (struct or array).
extern "C" fn LLVMBuildExtractValue(@Builder: LLVMBuilderRef, @AggVal: LLVMValueRef, @Index: u32, @Name: *u8) -> LLVMValueRef

# Build an insert-value into an aggregate.
extern "C" fn LLVMBuildInsertValue(@Builder: LLVMBuilderRef, @AggVal: LLVMValueRef, @EltVal: LLVMValueRef, @Index: u32, @Name: *u8) -> LLVMValueRef

# Build a freeze instruction (convert undef/poison to a fixed value).
extern "C" fn LLVMBuildFreeze(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Check if a value is null.
extern "C" fn LLVMBuildIsNull(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# Check if a value is not null.
extern "C" fn LLVMBuildIsNotNull(@Builder: LLVMBuilderRef, @Val: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.12 Type Constructors
# -----------------------------------------------------------------------------
# LLVM types are uniqued per context. Calling these multiple times with the
# same parameters returns the same type reference.

# Void type (for functions that return nothing).
extern "C" fn LLVMVoidTypeInContext(@C: LLVMContextRef) -> LLVMTypeRef

# Integer types of various bit widths.
extern "C" fn LLVMInt1TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMInt8TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMInt16TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMInt32TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMInt64TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMInt128TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef

# Arbitrary-width integer type.
extern "C" fn LLVMIntTypeInContext(@C: LLVMContextRef, @NumBits: u32) -> LLVMTypeRef

# Get the bit width of an integer type.
extern "C" fn LLVMGetIntTypeWidth(@IntegerTy: LLVMTypeRef) -> u32

# Floating-point types.
extern "C" fn LLVMHalfTypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMBFloatTypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMFloatTypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMDoubleTypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMX86FP80TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef
extern "C" fn LLVMFP128TypeInContext(@C: LLVMContextRef) -> LLVMTypeRef

# Opaque pointer type (LLVM 18: all pointers are opaque by default).
# @AddressSpace: 0 for default, non-zero for GPU/special memory
extern "C" fn LLVMPointerTypeInContext(@C: LLVMContextRef, @AddressSpace: u32) -> LLVMTypeRef

# Legacy pointer type (still available for backwards compatibility).
extern "C" fn LLVMPointerType(@ElementType: LLVMTypeRef, @AddressSpace: u32) -> LLVMTypeRef

# Array type with 64-bit element count (LLVM 18).
extern "C" fn LLVMArrayType2(@ElementType: LLVMTypeRef, @ElementCount: u64) -> LLVMTypeRef

# Fixed-width vector type (for SIMD).
extern "C" fn LLVMVectorType(@ElementType: LLVMTypeRef, @ElementCount: u32) -> LLVMTypeRef

# Scalable vector type (for ARM SVE).
extern "C" fn LLVMScalableVectorType(@ElementType: LLVMTypeRef, @ElementCount: u32) -> LLVMTypeRef

# Struct type from an array of field types.
# @Packed: if true, no padding between fields
extern "C" fn LLVMStructTypeInContext(@C: LLVMContextRef, @ElementTypes: *LLVMTypeRef, @ElementCount: u32, @Packed: LLVMBool) -> LLVMTypeRef

# Create a named (identified) struct type.
extern "C" fn LLVMStructCreateNamed(@C: LLVMContextRef, @Name: *u8) -> LLVMTypeRef

# Set the body of a named struct type.
extern "C" fn LLVMStructSetBody(@StructTy: LLVMTypeRef, @ElementTypes: *LLVMTypeRef, @ElementCount: u32, @Packed: LLVMBool)

# Get the number of elements in a struct type.
extern "C" fn LLVMCountStructElementTypes(@StructTy: LLVMTypeRef) -> u32

# Get a struct element type by index.
extern "C" fn LLVMStructGetTypeAtIndex(@StructTy: LLVMTypeRef, @I: u32) -> LLVMTypeRef

# Check if a struct is packed.
extern "C" fn LLVMIsPackedStruct(@StructTy: LLVMTypeRef) -> LLVMBool

# Check if a struct is opaque (body not set).
extern "C" fn LLVMIsOpaqueStruct(@StructTy: LLVMTypeRef) -> LLVMBool

# Function type constructor.
# @ReturnType: the return type
# @ParamTypes: array of parameter types
# @ParamCount: number of parameters
# @IsVarArg: whether this function accepts variable arguments
extern "C" fn LLVMFunctionType(@ReturnType: LLVMTypeRef, @ParamTypes: *LLVMTypeRef, @ParamCount: u32, @IsVarArg: LLVMBool) -> LLVMTypeRef

# Check if a function type is variadic.
extern "C" fn LLVMIsFunctionVarArg(@FunctionTy: LLVMTypeRef) -> LLVMBool

# Get the return type of a function type.
extern "C" fn LLVMGetReturnType(@FunctionTy: LLVMTypeRef) -> LLVMTypeRef

# Get the number of parameters of a function type.
extern "C" fn LLVMCountParamTypes(@FunctionTy: LLVMTypeRef) -> u32

# Get parameter types into an array.
extern "C" fn LLVMGetParamTypes(@FunctionTy: LLVMTypeRef, @Dest: *LLVMTypeRef)

# Get the kind of a type (integer, float, pointer, etc.).
extern "C" fn LLVMGetTypeKind(@Ty: LLVMTypeRef) -> u32

# Get the context a type belongs to.
extern "C" fn LLVMGetTypeContext(@Ty: LLVMTypeRef) -> LLVMContextRef

# Print a type to string (caller must free with LLVMDisposeMessage).
extern "C" fn LLVMPrintTypeToString(@Val: LLVMTypeRef) -> *u8

# -----------------------------------------------------------------------------
# 3.13 Value Constructors - Constants
# -----------------------------------------------------------------------------

# Create a constant integer value.
# @IntTy: the integer type (e.g., i32, i64)
# @N: the integer value
# @SignExtend: whether to sign-extend if N has fewer bits
extern "C" fn LLVMConstInt(@IntTy: LLVMTypeRef, @N: u64, @SignExtend: LLVMBool) -> LLVMValueRef

# Create a constant integer from a string.
extern "C" fn LLVMConstIntOfString(@IntTy: LLVMTypeRef, @Text: *u8, @Radix: u8) -> LLVMValueRef

# Create a constant integer from an arbitrary-precision value.
extern "C" fn LLVMConstIntOfArbitraryPrecision(@IntTy: LLVMTypeRef, @NumWords: u32, @Words: *u64) -> LLVMValueRef

# Create a constant floating-point value.
extern "C" fn LLVMConstReal(@RealTy: LLVMTypeRef, @N: f64) -> LLVMValueRef

# Create a constant float from a string.
extern "C" fn LLVMConstRealOfString(@RealTy: LLVMTypeRef, @Text: *u8) -> LLVMValueRef

# Create a null (zero-initialized) constant of any type.
extern "C" fn LLVMConstNull(@Ty: LLVMTypeRef) -> LLVMValueRef

# Create a constant with all bits set to 1.
extern "C" fn LLVMConstAllOnes(@Ty: LLVMTypeRef) -> LLVMValueRef

# Get an undefined value of a type (use with caution).
extern "C" fn LLVMGetUndef(@Ty: LLVMTypeRef) -> LLVMValueRef

# Get a poison value of a type (LLVM 18: stronger than undef).
extern "C" fn LLVMGetPoison(@Ty: LLVMTypeRef) -> LLVMValueRef

# Check if a value is null.
extern "C" fn LLVMIsNull(@Val: LLVMValueRef) -> LLVMBool

# Check if a value is undef.
extern "C" fn LLVMIsUndef(@Val: LLVMValueRef) -> LLVMBool

# Check if a value is poison.
extern "C" fn LLVMIsPoison(@Val: LLVMValueRef) -> LLVMBool

# Create a constant null pointer.
extern "C" fn LLVMConstPointerNull(@Ty: LLVMTypeRef) -> LLVMValueRef

# Create a constant string value.
# @Str: the string data
# @Length: length of the string
# @DontNullTerminate: if non-zero, do not append a null byte
extern "C" fn LLVMConstStringInContext(@C: LLVMContextRef, @Str: *u8, @Length: u32, @DontNullTerminate: LLVMBool) -> LLVMValueRef

# Create a constant string (shorthand using global context).
extern "C" fn LLVMConstString(@Str: *u8, @Length: u32, @DontNullTerminate: LLVMBool) -> LLVMValueRef

# Create a constant array of values.
extern "C" fn LLVMConstArray2(@ElementTy: LLVMTypeRef, @ConstantVals: *LLVMValueRef, @Length: u64) -> LLVMValueRef

# Create a constant struct from values.
# @Packed: if true, no padding between fields
extern "C" fn LLVMConstStructInContext(@C: LLVMContextRef, @ConstantVals: *LLVMValueRef, @Count: u32, @Packed: LLVMBool) -> LLVMValueRef

# Create a constant named struct from values.
extern "C" fn LLVMConstNamedStruct(@StructTy: LLVMTypeRef, @ConstantVals: *LLVMValueRef, @Count: u32) -> LLVMValueRef

# Create a constant vector from scalar values.
extern "C" fn LLVMConstVector(@ScalarConstantVals: *LLVMValueRef, @Size: u32) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.14 Value Inspection
# -----------------------------------------------------------------------------

# Get the type of a value.
extern "C" fn LLVMTypeOf(@Val: LLVMValueRef) -> LLVMTypeRef

# Get the name of a value.
extern "C" fn LLVMGetValueName2(@Val: LLVMValueRef, @Length: *u64) -> *u8

# Set the name of a value.
extern "C" fn LLVMSetValueName2(@Val: LLVMValueRef, @Name: *u8, @NameLen: u64)

# Print a value to string (caller must free with LLVMDisposeMessage).
extern "C" fn LLVMPrintValueToString(@Val: LLVMValueRef) -> *u8

# Get the opcode of an instruction value.
extern "C" fn LLVMGetInstructionOpcode(@Inst: LLVMValueRef) -> u32

# Get a constant int's zero-extended value.
extern "C" fn LLVMConstIntGetZExtValue(@ConstantVal: LLVMValueRef) -> u64

# Get a constant int's sign-extended value.
extern "C" fn LLVMConstIntGetSExtValue(@ConstantVal: LLVMValueRef) -> i64

# Get a constant float's value as a double.
extern "C" fn LLVMConstRealGetDouble(@ConstantVal: LLVMValueRef, @LosesInfo: *LLVMBool) -> f64

# Check if a value is a constant.
extern "C" fn LLVMIsConstant(@Val: LLVMValueRef) -> LLVMBool

# Replace all uses of a value with another value.
extern "C" fn LLVMReplaceAllUsesWith(@OldVal: LLVMValueRef, @NewVal: LLVMValueRef)

# -----------------------------------------------------------------------------
# 3.15 Function Management
# -----------------------------------------------------------------------------

# Add a function to a module.
# @M: the module
# @Name: function name
# @FunctionTy: the function type (created with LLVMFunctionType)
extern "C" fn LLVMAddFunction(@M: LLVMModuleRef, @Name: *u8, @FunctionTy: LLVMTypeRef) -> LLVMValueRef

# Look up a function by name in a module.
extern "C" fn LLVMGetNamedFunction(@M: LLVMModuleRef, @Name: *u8) -> LLVMValueRef

# Get the first function in a module (for iteration).
extern "C" fn LLVMGetFirstFunction(@M: LLVMModuleRef) -> LLVMValueRef

# Get the last function in a module.
extern "C" fn LLVMGetLastFunction(@M: LLVMModuleRef) -> LLVMValueRef

# Get the next function (for iteration).
extern "C" fn LLVMGetNextFunction(@Fn: LLVMValueRef) -> LLVMValueRef

# Set the calling convention of a function.
extern "C" fn LLVMSetFunctionCallConv(@Fn: LLVMValueRef, @CC: u32)

# Get the calling convention of a function.
extern "C" fn LLVMGetFunctionCallConv(@Fn: LLVMValueRef) -> u32

# Set the linkage type of a global value (function or global variable).
extern "C" fn LLVMSetLinkage(@Global: LLVMValueRef, @Linkage: u32)

# Get the linkage type.
extern "C" fn LLVMGetLinkage(@Global: LLVMValueRef) -> u32

# Set the visibility of a global value.
extern "C" fn LLVMSetVisibility(@Global: LLVMValueRef, @Viz: u32)

# Get the visibility.
extern "C" fn LLVMGetVisibility(@Global: LLVMValueRef) -> u32

# Set the section for a global value.
extern "C" fn LLVMSetSection(@Global: LLVMValueRef, @Section: *u8)

# Get the section name.
extern "C" fn LLVMGetSection(@Global: LLVMValueRef) -> *u8

# Set the alignment of a global or alloca.
extern "C" fn LLVMSetAlignment(@V: LLVMValueRef, @Bytes: u32)

# Get a function parameter by index.
extern "C" fn LLVMGetParam(@Fn: LLVMValueRef, @Index: u32) -> LLVMValueRef

# Get the number of parameters of a function.
extern "C" fn LLVMCountParams(@Fn: LLVMValueRef) -> u32

# Get all parameters into an array.
extern "C" fn LLVMGetParams(@Fn: LLVMValueRef, @Params: *LLVMValueRef)

# Add an attribute to a function at a specific index.
# @Idx: 0 = return, 1+ = parameter index, -1 = function itself
extern "C" fn LLVMAddAttributeAtIndex(@F: LLVMValueRef, @Idx: u32, @A: LLVMAttributeRef)

# Get the number of attributes at an index.
extern "C" fn LLVMGetAttributeCountAtIndex(@F: LLVMValueRef, @Idx: u32) -> u32

# Create an enum attribute.
extern "C" fn LLVMCreateEnumAttribute(@C: LLVMContextRef, @KindID: u32, @Val: u64) -> LLVMAttributeRef

# Create a string attribute.
extern "C" fn LLVMCreateStringAttribute(@C: LLVMContextRef, @K: *u8, @KLength: u32, @V: *u8, @VLength: u32) -> LLVMAttributeRef

# Get the enum attribute kind ID by name.
extern "C" fn LLVMGetEnumAttributeKindForName(@Name: *u8, @SLen: u64) -> u32

# Delete a function from its module.
extern "C" fn LLVMDeleteFunction(@Fn: LLVMValueRef)

# Verify a single function.
extern "C" fn LLVMVerifyFunction(@Fn: LLVMValueRef, @Action: u32) -> LLVMBool

# Set the personality function for exception handling.
extern "C" fn LLVMSetPersonalityFn(@Fn: LLVMValueRef, @PersonalityFn: LLVMValueRef)

# Set the GC strategy name for a function.
extern "C" fn LLVMSetGC(@Fn: LLVMValueRef, @Name: *u8)

# -----------------------------------------------------------------------------
# 3.16 Basic Block Management
# -----------------------------------------------------------------------------

# Append a basic block to a function within a context.
extern "C" fn LLVMAppendBasicBlockInContext(@C: LLVMContextRef, @Fn: LLVMValueRef, @Name: *u8) -> LLVMBasicBlockRef

# Insert a basic block before another block.
extern "C" fn LLVMInsertBasicBlockInContext(@C: LLVMContextRef, @BB: LLVMBasicBlockRef, @Name: *u8) -> LLVMBasicBlockRef

# Get the terminator instruction of a basic block (or null).
extern "C" fn LLVMGetBasicBlockTerminator(@BB: LLVMBasicBlockRef) -> LLVMValueRef

# Get the parent function of a basic block.
extern "C" fn LLVMGetBasicBlockParent(@BB: LLVMBasicBlockRef) -> LLVMValueRef

# Get the first basic block in a function.
extern "C" fn LLVMGetFirstBasicBlock(@Fn: LLVMValueRef) -> LLVMBasicBlockRef

# Get the last basic block in a function.
extern "C" fn LLVMGetLastBasicBlock(@Fn: LLVMValueRef) -> LLVMBasicBlockRef

# Get the next basic block (for iteration).
extern "C" fn LLVMGetNextBasicBlock(@BB: LLVMBasicBlockRef) -> LLVMBasicBlockRef

# Get the previous basic block (for reverse iteration).
extern "C" fn LLVMGetPreviousBasicBlock(@BB: LLVMBasicBlockRef) -> LLVMBasicBlockRef

# Get the entry basic block of a function.
extern "C" fn LLVMGetEntryBasicBlock(@Fn: LLVMValueRef) -> LLVMBasicBlockRef

# Count the number of basic blocks in a function.
extern "C" fn LLVMCountBasicBlocks(@Fn: LLVMValueRef) -> u32

# Delete a basic block (must have no predecessors).
extern "C" fn LLVMDeleteBasicBlock(@BB: LLVMBasicBlockRef)

# Remove a basic block from its function without deleting it.
extern "C" fn LLVMRemoveBasicBlockFromParent(@BB: LLVMBasicBlockRef)

# Move a basic block before another.
extern "C" fn LLVMMoveBasicBlockBefore(@BB: LLVMBasicBlockRef, @MovePos: LLVMBasicBlockRef)

# Move a basic block after another.
extern "C" fn LLVMMoveBasicBlockAfter(@BB: LLVMBasicBlockRef, @MovePos: LLVMBasicBlockRef)

# Get the first instruction in a basic block.
extern "C" fn LLVMGetFirstInstruction(@BB: LLVMBasicBlockRef) -> LLVMValueRef

# Get the last instruction in a basic block.
extern "C" fn LLVMGetLastInstruction(@BB: LLVMBasicBlockRef) -> LLVMValueRef

# Convert a basic block to a value (for use as a branch target).
extern "C" fn LLVMBasicBlockAsValue(@BB: LLVMBasicBlockRef) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.17 PHI Node Management
# -----------------------------------------------------------------------------

# Add incoming (value, block) pairs to a PHI node.
# @PhiNode: the PHI instruction
# @IncomingValues: array of values
# @IncomingBlocks: array of corresponding basic blocks
# @Count: number of pairs
extern "C" fn LLVMAddIncoming(@PhiNode: LLVMValueRef, @IncomingValues: *LLVMValueRef, @IncomingBlocks: *LLVMBasicBlockRef, @Count: u32)

# Get the number of incoming values.
extern "C" fn LLVMCountIncoming(@PhiNode: LLVMValueRef) -> u32

# Get an incoming value by index.
extern "C" fn LLVMGetIncomingValue(@PhiNode: LLVMValueRef, @Index: u32) -> LLVMValueRef

# Get an incoming block by index.
extern "C" fn LLVMGetIncomingBlock(@PhiNode: LLVMValueRef, @Index: u32) -> LLVMBasicBlockRef

# -----------------------------------------------------------------------------
# 3.18 Global Variable Management
# -----------------------------------------------------------------------------

# Add a global variable to a module.
extern "C" fn LLVMAddGlobal(@M: LLVMModuleRef, @Ty: LLVMTypeRef, @Name: *u8) -> LLVMValueRef

# Add a global variable in a specific address space.
extern "C" fn LLVMAddGlobalInAddressSpace(@M: LLVMModuleRef, @Ty: LLVMTypeRef, @Name: *u8, @AddressSpace: u32) -> LLVMValueRef

# Look up a global variable by name.
extern "C" fn LLVMGetNamedGlobal(@M: LLVMModuleRef, @Name: *u8) -> LLVMValueRef

# Get the first global variable in a module.
extern "C" fn LLVMGetFirstGlobal(@M: LLVMModuleRef) -> LLVMValueRef

# Get the next global variable (for iteration).
extern "C" fn LLVMGetNextGlobal(@GlobalVar: LLVMValueRef) -> LLVMValueRef

# Set the initializer of a global variable.
extern "C" fn LLVMSetInitializer(@GlobalVar: LLVMValueRef, @ConstantVal: LLVMValueRef)

# Get the initializer of a global variable.
extern "C" fn LLVMGetInitializer(@GlobalVar: LLVMValueRef) -> LLVMValueRef

# Set whether a global is constant (read-only).
extern "C" fn LLVMSetGlobalConstant(@GlobalVar: LLVMValueRef, @IsConstant: LLVMBool)

# Check if a global is constant.
extern "C" fn LLVMIsGlobalConstant(@GlobalVar: LLVMValueRef) -> LLVMBool

# Set thread-local storage mode for a global.
extern "C" fn LLVMSetThreadLocalMode(@GlobalVar: LLVMValueRef, @Mode: u32)

# Get thread-local storage mode.
extern "C" fn LLVMGetThreadLocalMode(@GlobalVar: LLVMValueRef) -> u32

# Set whether a global is externally initialized.
extern "C" fn LLVMSetExternallyInitialized(@GlobalVar: LLVMValueRef, @IsExtInit: LLVMBool)

# Delete a global variable.
extern "C" fn LLVMDeleteGlobal(@GlobalVar: LLVMValueRef)

# Add an alias to a module.
extern "C" fn LLVMAddAlias2(@M: LLVMModuleRef, @Ty: LLVMTypeRef, @AddrSpace: u32, @Aliasee: LLVMValueRef, @Name: *u8) -> LLVMValueRef

# -----------------------------------------------------------------------------
# 3.19 Target Initialization
# -----------------------------------------------------------------------------
# These must be called before creating a target machine.
# Luna calls the specific architecture initializers for deterministic behavior.

# x86/x86_64 target initialization
extern "C" fn LLVMInitializeX86TargetInfo()
extern "C" fn LLVMInitializeX86Target()
extern "C" fn LLVMInitializeX86TargetMC()
extern "C" fn LLVMInitializeX86AsmPrinter()
extern "C" fn LLVMInitializeX86AsmParser()
extern "C" fn LLVMInitializeX86Disassembler()

# AArch64 (ARM64) target initialization
extern "C" fn LLVMInitializeAArch64TargetInfo()
extern "C" fn LLVMInitializeAArch64Target()
extern "C" fn LLVMInitializeAArch64TargetMC()
extern "C" fn LLVMInitializeAArch64AsmPrinter()
extern "C" fn LLVMInitializeAArch64AsmParser()
extern "C" fn LLVMInitializeAArch64Disassembler()

# RISC-V target initialization
extern "C" fn LLVMInitializeRISCVTargetInfo()
extern "C" fn LLVMInitializeRISCVTarget()
extern "C" fn LLVMInitializeRISCVTargetMC()
extern "C" fn LLVMInitializeRISCVAsmPrinter()
extern "C" fn LLVMInitializeRISCVAsmParser()

# WebAssembly target initialization
extern "C" fn LLVMInitializeWebAssemblyTargetInfo()
extern "C" fn LLVMInitializeWebAssemblyTarget()
extern "C" fn LLVMInitializeWebAssemblyTargetMC()
extern "C" fn LLVMInitializeWebAssemblyAsmPrinter()
extern "C" fn LLVMInitializeWebAssemblyAsmParser()

# Initialize all targets at once (convenience, but heavier).
extern "C" fn LLVMInitializeAllTargetInfos()
extern "C" fn LLVMInitializeAllTargets()
extern "C" fn LLVMInitializeAllTargetMCs()
extern "C" fn LLVMInitializeAllAsmPrinters()
extern "C" fn LLVMInitializeAllAsmParsers()

# Initialize the native (host) target.
# Returns: 0 on success
extern "C" fn LLVMInitializeNativeTarget() -> LLVMBool
extern "C" fn LLVMInitializeNativeAsmPrinter() -> LLVMBool
extern "C" fn LLVMInitializeNativeAsmParser() -> LLVMBool

# -----------------------------------------------------------------------------
# 3.20 Target Information
# -----------------------------------------------------------------------------

# Get the default target triple for the host machine.
# Caller must free the returned string with LLVMDisposeMessage.
extern "C" fn LLVMGetDefaultTargetTriple() -> *u8

# Normalize a target triple string.
extern "C" fn LLVMNormalizeTargetTriple(@Triple: *u8) -> *u8

# Get the host CPU name (e.g., "skylake", "apple-m1").
# Caller must free with LLVMDisposeMessage.
extern "C" fn LLVMGetHostCPUName() -> *u8

# Get the host CPU features as a comma-separated string.
# Caller must free with LLVMDisposeMessage.
extern "C" fn LLVMGetHostCPUFeatures() -> *u8

# Get a target by its triple.
# Returns: 0 on success, non-zero if target not found
extern "C" fn LLVMGetTargetFromTriple(@Triple: *u8, @T: *LLVMTargetRef, @ErrorMessage: **u8) -> LLVMBool

# Get the name of a target.
extern "C" fn LLVMGetTargetName(@T: LLVMTargetRef) -> *u8

# Get the description of a target.
extern "C" fn LLVMGetTargetDescription(@T: LLVMTargetRef) -> *u8

# Check if a target has a JIT compiler.
extern "C" fn LLVMTargetHasJIT(@T: LLVMTargetRef) -> LLVMBool

# Check if a target has a target machine (code generator).
extern "C" fn LLVMTargetHasTargetMachine(@T: LLVMTargetRef) -> LLVMBool

# Check if a target has an assembly backend.
extern "C" fn LLVMTargetHasAsmBackend(@T: LLVMTargetRef) -> LLVMBool

# Get the first target in the target registry (for iteration).
extern "C" fn LLVMGetFirstTarget() -> LLVMTargetRef

# Get the next target (for iteration).
extern "C" fn LLVMGetNextTarget(@T: LLVMTargetRef) -> LLVMTargetRef

# -----------------------------------------------------------------------------
# 3.21 Target Machine
# -----------------------------------------------------------------------------

# Create a target machine for code generation.
# @T: the target (from LLVMGetTargetFromTriple)
# @Triple: target triple string
# @CPU: CPU name (e.g., "generic", "skylake")
# @Features: CPU features string (e.g., "+avx2,+fma")
# @Level: optimization level (LLVMCodeGenLevel*)
# @Reloc: relocation model (LLVMReloc*)
# @CodeModel: code model (LLVMCodeModel*)
extern "C" fn LLVMCreateTargetMachine(@T: LLVMTargetRef, @Triple: *u8, @CPU: *u8, @Features: *u8, @Level: u32, @Reloc: u32, @CodeModel: u32) -> LLVMTargetMachineRef

# Dispose of a target machine.
extern "C" fn LLVMDisposeTargetMachine(@T: LLVMTargetMachineRef)

# Get the target of a target machine.
extern "C" fn LLVMGetTargetMachineTarget(@T: LLVMTargetMachineRef) -> LLVMTargetRef

# Get the target triple of a target machine.
extern "C" fn LLVMGetTargetMachineTriple(@T: LLVMTargetMachineRef) -> *u8

# Get the CPU name of a target machine.
extern "C" fn LLVMGetTargetMachineCPU(@T: LLVMTargetMachineRef) -> *u8

# Get the feature string of a target machine.
extern "C" fn LLVMGetTargetMachineFeatureString(@T: LLVMTargetMachineRef) -> *u8

# Create target data layout from a target machine.
extern "C" fn LLVMCreateTargetDataLayout(@T: LLVMTargetMachineRef) -> LLVMTargetDataRef

# Set assembly verbosity on a target machine.
extern "C" fn LLVMSetTargetMachineAsmVerbosity(@T: LLVMTargetMachineRef, @VerboseAsm: LLVMBool)

# Emit the module as assembly or object file to disk.
# @codegen: LLVMAssemblyFile or LLVMObjectFile
# Returns: 0 on success
extern "C" fn LLVMTargetMachineEmitToFile(@T: LLVMTargetMachineRef, @M: LLVMModuleRef, @Filename: *u8, @codegen: u32, @ErrorMessage: **u8) -> LLVMBool

# Emit the module as assembly or object file to a memory buffer.
extern "C" fn LLVMTargetMachineEmitToMemoryBuffer(@T: LLVMTargetMachineRef, @M: LLVMModuleRef, @codegen: u32, @ErrorMessage: **u8, @OutMemBuf: *LLVMMemoryBufferRef) -> LLVMBool

# -----------------------------------------------------------------------------
# 3.22 Target Data Layout
# -----------------------------------------------------------------------------

# Dispose of a target data layout.
extern "C" fn LLVMDisposeTargetData(@TD: LLVMTargetDataRef)

# Create a target data from a layout string.
extern "C" fn LLVMCreateTargetData(@StringRep: *u8) -> LLVMTargetDataRef

# Copy a target data layout to a string.
extern "C" fn LLVMCopyStringRepOfTargetData(@TD: LLVMTargetDataRef) -> *u8

# Get the pointer size in bytes for the target.
extern "C" fn LLVMPointerSize(@TD: LLVMTargetDataRef) -> u32

# Get the byte order of the target (0 = big endian, 1 = little endian).
extern "C" fn LLVMByteOrder(@TD: LLVMTargetDataRef) -> u32

# Get the size of a type in bits.
extern "C" fn LLVMSizeOfTypeInBits(@TD: LLVMTargetDataRef, @Ty: LLVMTypeRef) -> u64

# Get the ABI size of a type in bytes.
extern "C" fn LLVMABISizeOfType(@TD: LLVMTargetDataRef, @Ty: LLVMTypeRef) -> u64

# Get the ABI alignment of a type in bytes.
extern "C" fn LLVMABIAlignmentOfType(@TD: LLVMTargetDataRef, @Ty: LLVMTypeRef) -> u32

# Get the preferred alignment of a type in bytes.
extern "C" fn LLVMPreferredAlignmentOfType(@TD: LLVMTargetDataRef, @Ty: LLVMTypeRef) -> u32

# Get the offset of a struct element in bytes.
extern "C" fn LLVMOffsetOfElement(@TD: LLVMTargetDataRef, @StructTy: LLVMTypeRef, @Element: u32) -> u64

# -----------------------------------------------------------------------------
# 3.23 Pass Manager (Legacy + New PM via pass builder)
# -----------------------------------------------------------------------------

# Create a module-level pass manager.
extern "C" fn LLVMCreatePassManager() -> LLVMPassManagerRef

# Create a function-level pass manager.
extern "C" fn LLVMCreateFunctionPassManagerForModule(@M: LLVMModuleRef) -> LLVMPassManagerRef

# Run the module pass manager on a module.
# Returns: non-zero if module was modified
extern "C" fn LLVMRunPassManager(@PM: LLVMPassManagerRef, @M: LLVMModuleRef) -> LLVMBool

# Initialize the function pass manager before running on functions.
extern "C" fn LLVMInitializeFunctionPassManager(@FPM: LLVMPassManagerRef) -> LLVMBool

# Run the function pass manager on a single function.
extern "C" fn LLVMRunFunctionPassManager(@FPM: LLVMPassManagerRef, @F: LLVMValueRef) -> LLVMBool

# Finalize the function pass manager after running on all functions.
extern "C" fn LLVMFinalizeFunctionPassManager(@FPM: LLVMPassManagerRef) -> LLVMBool

# Dispose of a pass manager.
extern "C" fn LLVMDisposePassManager(@PM: LLVMPassManagerRef)

# --- LLVM 18 New Pass Manager (PassBuilder) ---
# The new pass manager in LLVM 18 uses LLVMRunPasses with a textual pipeline.

# Create pass builder options.
extern "C" fn LLVMCreatePassBuilderOptions() -> LLVMPassBuilderOptionsRef

# Dispose pass builder options.
extern "C" fn LLVMDisposePassBuilderOptions(@Options: LLVMPassBuilderOptionsRef)

# Set loop interleaving in pass builder options.
extern "C" fn LLVMPassBuilderOptionsSetLoopInterleaving(@Options: LLVMPassBuilderOptionsRef, @LoopInterleaving: LLVMBool)

# Set loop vectorization in pass builder options.
extern "C" fn LLVMPassBuilderOptionsSetLoopVectorization(@Options: LLVMPassBuilderOptionsRef, @LoopVectorization: LLVMBool)

# Set SLP vectorization in pass builder options.
extern "C" fn LLVMPassBuilderOptionsSetSLPVectorization(@Options: LLVMPassBuilderOptionsRef, @SLPVectorization: LLVMBool)

# Set loop unrolling in pass builder options.
extern "C" fn LLVMPassBuilderOptionsSetLoopUnrolling(@Options: LLVMPassBuilderOptionsRef, @LoopUnrolling: LLVMBool)

# Set merge functions in pass builder options.
extern "C" fn LLVMPassBuilderOptionsSetMergeFunctions(@Options: LLVMPassBuilderOptionsRef, @MergeFunctions: LLVMBool)

# Set call graph profile in pass builder options.
extern "C" fn LLVMPassBuilderOptionsSetCallGraphProfile(@Options: LLVMPassBuilderOptionsRef, @CallGraphProfile: LLVMBool)

# Set the verification option for the pass builder.
extern "C" fn LLVMPassBuilderOptionsSetVerifyEach(@Options: LLVMPassBuilderOptionsRef, @VerifyEach: LLVMBool)

# Set the debug logging option for the pass builder.
extern "C" fn LLVMPassBuilderOptionsSetDebugLogging(@Options: LLVMPassBuilderOptionsRef, @DebugLogging: LLVMBool)

# Run passes on a module using the new pass manager.
# @Passes: textual pipeline description (e.g., "default<O2>")
# @TM: target machine (or null for target-independent passes)
# @Options: pass builder options (or null for defaults)
# Returns: an error ref (null on success)
extern "C" fn LLVMRunPasses(@M: LLVMModuleRef, @Passes: *u8, @TM: LLVMTargetMachineRef, @Options: LLVMPassBuilderOptionsRef) -> RawPtr

# -----------------------------------------------------------------------------
# 3.24 Execution Engine (MCJIT)
# -----------------------------------------------------------------------------
# The MCJIT provides JIT compilation. Must link in MCJIT first.

# Link in the MCJIT implementation. Must be called before creating JIT.
extern "C" fn LLVMLinkInMCJIT()

# Link in the interpreter.
extern "C" fn LLVMLinkInInterpreter()

# Create an MCJIT compiler for a module.
# The module is consumed by the execution engine (do not dispose separately).
# @OutJIT: receives the execution engine handle
# @M: the module (ownership transferred)
# @Options: MCJIT options struct pointer
# @SizeOfOptions: size of the options struct
# @OutError: receives error message on failure
# Returns: 0 on success
extern "C" fn LLVMCreateMCJITCompilerForModule(@OutJIT: *LLVMExecutionEngineRef, @M: LLVMModuleRef, @Options: RawPtr, @SizeOfOptions: u64, @OutError: **u8) -> LLVMBool

# Create an execution engine for a module (auto-selects JIT or interpreter).
extern "C" fn LLVMCreateExecutionEngineForModule(@OutEE: *LLVMExecutionEngineRef, @M: LLVMModuleRef, @OutError: **u8) -> LLVMBool

# Dispose of an execution engine (also disposes the module it owns).
extern "C" fn LLVMDisposeExecutionEngine(@EE: LLVMExecutionEngineRef)

# Get the address of a compiled function by name.
# Returns: the function pointer as a u64 (0 if not found)
extern "C" fn LLVMGetFunctionAddress(@EE: LLVMExecutionEngineRef, @Name: *u8) -> u64

# Run a function with generic arguments through the execution engine.
extern "C" fn LLVMRunFunction(@EE: LLVMExecutionEngineRef, @F: LLVMValueRef, @NumArgs: u32, @Args: *LLVMGenericValueRef) -> LLVMGenericValueRef

# Run static constructors.
extern "C" fn LLVMRunStaticConstructors(@EE: LLVMExecutionEngineRef)

# Run static destructors.
extern "C" fn LLVMRunStaticDestructors(@EE: LLVMExecutionEngineRef)

# Add a module to an existing execution engine.
extern "C" fn LLVMAddModule(@EE: LLVMExecutionEngineRef, @M: LLVMModuleRef)

# Remove a module from the execution engine (returns ownership to caller).
extern "C" fn LLVMRemoveModule(@EE: LLVMExecutionEngineRef, @M: LLVMModuleRef, @OutMod: *LLVMModuleRef, @OutError: **u8) -> LLVMBool

# Find a function by name in the execution engine.
extern "C" fn LLVMFindFunction(@EE: LLVMExecutionEngineRef, @Name: *u8, @OutFn: *LLVMValueRef) -> LLVMBool

# Get the target data of the execution engine.
extern "C" fn LLVMGetExecutionEngineTargetData(@EE: LLVMExecutionEngineRef) -> LLVMTargetDataRef

# Add a global mapping (bind a name to a host address).
extern "C" fn LLVMAddGlobalMapping(@EE: LLVMExecutionEngineRef, @Global: LLVMValueRef, @Addr: RawPtr)

# Get a pointer to a global variable in the JIT.
extern "C" fn LLVMGetPointerToGlobal(@EE: LLVMExecutionEngineRef, @Global: LLVMValueRef) -> RawPtr

# --- Generic Value constructors for JIT ---

# Create a generic integer value.
extern "C" fn LLVMCreateGenericValueOfInt(@Ty: LLVMTypeRef, @N: u64, @IsSigned: LLVMBool) -> LLVMGenericValueRef

# Create a generic float value.
extern "C" fn LLVMCreateGenericValueOfFloat(@Ty: LLVMTypeRef, @N: f64) -> LLVMGenericValueRef

# Create a generic pointer value.
extern "C" fn LLVMCreateGenericValueOfPointer(@P: RawPtr) -> LLVMGenericValueRef

# Get the int value from a generic value.
extern "C" fn LLVMGenericValueToInt(@GenVal: LLVMGenericValueRef, @IsSigned: LLVMBool) -> u64

# Get the float value from a generic value.
extern "C" fn LLVMGenericValueToFloat(@TyRef: LLVMTypeRef, @GenVal: LLVMGenericValueRef) -> f64

# Get the pointer value from a generic value.
extern "C" fn LLVMGenericValueToPointer(@GenVal: LLVMGenericValueRef) -> RawPtr

# Get the int width of a generic value in bits.
extern "C" fn LLVMGenericValueIntWidth(@GenVal: LLVMGenericValueRef) -> u32

# Dispose a generic value.
extern "C" fn LLVMDisposeGenericValue(@GenVal: LLVMGenericValueRef)

# -----------------------------------------------------------------------------
# 3.25 Memory Buffer
# -----------------------------------------------------------------------------

# Create a memory buffer from a file.
extern "C" fn LLVMCreateMemoryBufferWithContentsOfFile(@Path: *u8, @OutMemBuf: *LLVMMemoryBufferRef, @OutMessage: **u8) -> LLVMBool

# Create a memory buffer from stdin.
extern "C" fn LLVMCreateMemoryBufferWithSTDIN(@OutMemBuf: *LLVMMemoryBufferRef, @OutMessage: **u8) -> LLVMBool

# Create a memory buffer from a memory range (copy).
extern "C" fn LLVMCreateMemoryBufferWithMemoryRange(@InputData: *u8, @InputDataLength: u64, @BufferName: *u8, @RequiresNullTerminator: LLVMBool) -> LLVMMemoryBufferRef

# Create a memory buffer from a memory range (no copy).
extern "C" fn LLVMCreateMemoryBufferWithMemoryRangeCopy(@InputData: *u8, @InputDataLength: u64, @BufferName: *u8) -> LLVMMemoryBufferRef

# Get the start of the memory buffer data.
extern "C" fn LLVMGetBufferStart(@MemBuf: LLVMMemoryBufferRef) -> *u8

# Get the size of the memory buffer.
extern "C" fn LLVMGetBufferSize(@MemBuf: LLVMMemoryBufferRef) -> u64

# Dispose of a memory buffer.
extern "C" fn LLVMDisposeMemoryBuffer(@MemBuf: LLVMMemoryBufferRef)

# Parse bitcode from a memory buffer into a module.
extern "C" fn LLVMParseBitcodeInContext2(@ContextRef: LLVMContextRef, @MemBuf: LLVMMemoryBufferRef, @OutModule: *LLVMModuleRef) -> LLVMBool

# -----------------------------------------------------------------------------
# 3.26 Error / Message Handling
# -----------------------------------------------------------------------------

# Dispose of an error message string returned by LLVM.
extern "C" fn LLVMDisposeMessage(@Message: *u8)

# Get the error message from an LLVMErrorRef.
extern "C" fn LLVMGetErrorMessage(@Err: RawPtr) -> *u8

# Dispose an error message from LLVMGetErrorMessage.
extern "C" fn LLVMDisposeErrorMessage(@ErrMsg: *u8)

# Consume and dispose an error (clears it).
extern "C" fn LLVMConsumeError(@Err: RawPtr)

# Get the error type ID string.
extern "C" fn LLVMGetErrorTypeId(@Err: RawPtr) -> RawPtr

# Create a string error.
extern "C" fn LLVMCreateStringError(@ErrMsg: *u8) -> RawPtr

# -----------------------------------------------------------------------------
# 3.27 Inline Assembly
# -----------------------------------------------------------------------------

# Create an inline assembly value.
extern "C" fn LLVMGetInlineAsm(@Ty: LLVMTypeRef, @AsmString: *u8, @AsmStringSize: u64, @Constraints: *u8, @ConstraintsSize: u64, @HasSideEffects: LLVMBool, @IsAlignStack: LLVMBool, @Dialect: u32, @CanThrow: LLVMBool) -> LLVMValueRef

# Set the module-level inline assembly.
extern "C" fn LLVMSetModuleInlineAsm2(@M: LLVMModuleRef, @Asm: *u8, @Len: u64)

# Append to the module-level inline assembly.
extern "C" fn LLVMAppendModuleInlineAsm(@M: LLVMModuleRef, @Asm: *u8, @Len: u64)

# -----------------------------------------------------------------------------
# 3.28 Debug Information (DWARF)
# -----------------------------------------------------------------------------

# Create a debug info builder attached to a module.
extern "C" fn LLVMCreateDIBuilder(@M: LLVMModuleRef) -> RawPtr

# Create a non-lazy debug info builder.
extern "C" fn LLVMCreateDIBuilderDisallowUnresolved(@M: LLVMModuleRef) -> RawPtr

# Dispose of a debug info builder.
extern "C" fn LLVMDisposeDIBuilder(@Builder: RawPtr)

# Finalize the debug info (must be called before module verification).
extern "C" fn LLVMDIBuilderFinalize(@Builder: RawPtr)

# Create a compile unit for debug info.
extern "C" fn LLVMDIBuilderCreateCompileUnit(@Builder: RawPtr, @Lang: u32, @FileRef: LLVMMetadataRef, @Producer: *u8, @ProducerLen: u64, @IsOptimized: LLVMBool, @Flags: *u8, @FlagsLen: u64, @RuntimeVer: u32, @SplitName: *u8, @SplitNameLen: u64, @Kind: u32, @DWOId: u32, @SplitDebugInlining: LLVMBool, @DebugInfoForProfiling: LLVMBool, @SysRoot: *u8, @SysRootLen: u64, @SDK: *u8, @SDKLen: u64) -> LLVMMetadataRef

# Create a file descriptor for debug info.
extern "C" fn LLVMDIBuilderCreateFile(@Builder: RawPtr, @Filename: *u8, @FilenameLen: u64, @Directory: *u8, @DirectoryLen: u64) -> LLVMMetadataRef

# Create a debug info location.
extern "C" fn LLVMDIBuilderCreateDebugLocation(@Ctx: LLVMContextRef, @Line: u32, @Column: u32, @Scope: LLVMMetadataRef, @InlinedAt: LLVMMetadataRef) -> LLVMMetadataRef

# =============================================================================
# SECTION 4: HIGH-LEVEL LUNA WRAPPER STRUCTS
# =============================================================================
# These structs provide ergonomic Luna interfaces around the raw LLVM C API.
# They manage lifetimes, group related handles, and add safety checks.

# -----------------------------------------------------------------------------
# 4.1 LlvmContext - Top-level compilation context
# -----------------------------------------------------------------------------
# Owns an LLVM context, a module, and a builder. This is the primary entry
# point for generating LLVM IR from Luna.

struct LlvmContext
    context: LLVMContextRef      # The LLVM context handle
    module: LLVMModuleRef        # The current module being built
    builder: LLVMBuilderRef      # The IR builder
    target_machine: LLVMTargetMachineRef  # Target machine (null until set)
    target_data: LLVMTargetDataRef        # Target data layout (null until set)
    module_name: str             # Human-readable module name
    is_disposed: int             # 1 if already disposed, 0 otherwise

# Create a new LlvmContext with a module of the given name.
# Initializes context, module, and builder. Target machine is null.
fn llvm_context_new(@name: str) -> LlvmContext
    @ctx = unsafe { LLVMContextCreate() }
    @mod = unsafe { LLVMModuleCreateWithNameInContext(@name, @ctx) }
    @builder = unsafe { LLVMCreateBuilderInContext(@ctx) }
    return LlvmContext {
        context: @ctx,
        module: @mod,
        builder: @builder,
        target_machine: null,
        target_data: null,
        module_name: @name,
        is_disposed: 0
    }

# Dispose of all LLVM resources owned by this context.
# Safe to call multiple times (idempotent).
fn llvm_context_dispose(@self: LlvmContext)
    if @self.is_disposed == 1
        return
    if @self.target_machine != null
        unsafe { LLVMDisposeTargetMachine(@self.target_machine) }
    if @self.target_data != null
        unsafe { LLVMDisposeTargetData(@self.target_data) }
    unsafe { LLVMDisposeBuilder(@self.builder) }
    unsafe { LLVMDisposeModule(@self.module) }
    unsafe { LLVMContextDispose(@self.context) }
    @self.is_disposed = 1

# Set the target triple and data layout for the module.
# Must be called before emitting code or creating a target machine.
fn llvm_context_set_target(@self: LlvmContext, @triple: str, @data_layout: str)
    unsafe { LLVMSetTarget(@self.module, @triple) }
    unsafe { LLVMSetDataLayout(@self.module, @data_layout) }

# Initialize the target machine for the module.
# @opt_level: LLVMCodeGenLevel* constant
# @reloc: LLVMReloc* constant
# @code_model: LLVMCodeModel* constant
# Returns: 1 on success, 0 on failure
fn llvm_context_init_target(@self: LlvmContext, @triple: str, @cpu: str, @features: str, @opt_level: u32, @reloc: u32, @code_model: u32) -> int
    @target: LLVMTargetRef = null
    @error: *u8 = null
    @result = unsafe { LLVMGetTargetFromTriple(@triple, &@target, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return 0
    @tm = unsafe { LLVMCreateTargetMachine(@target, @triple, @cpu, @features, @opt_level, @reloc, @code_model) }
    if @tm == null
        return 0
    @self.target_machine = @tm
    @self.target_data = unsafe { LLVMCreateTargetDataLayout(@tm) }
    # Set the module target triple and data layout from the target machine
    @tm_triple = unsafe { LLVMGetTargetMachineTriple(@tm) }
    unsafe { LLVMSetTarget(@self.module, @tm_triple) }
    @layout_str = unsafe { LLVMCopyStringRepOfTargetData(@self.target_data) }
    unsafe { LLVMSetDataLayout(@self.module, @layout_str) }
    unsafe { LLVMDisposeMessage(@tm_triple) }
    unsafe { LLVMDisposeMessage(@layout_str) }
    return 1

# Verify the module IR for correctness.
# Returns: 1 if valid, 0 if invalid (with error message printed)
fn llvm_context_verify(@self: LlvmContext) -> int
    @error: *u8 = null
    @result = unsafe { LLVMVerifyModule(@self.module, LLVMReturnStatusAction, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return 0
    if @error != null
        unsafe { LLVMDisposeMessage(@error) }
    return 1

# Print the module IR to a string.
# Caller is responsible for the returned string lifetime.
fn llvm_context_print_ir(@self: LlvmContext) -> str
    @ir_ptr = unsafe { LLVMPrintModuleToString(@self.module) }
    @ir_str = str_from_cstr(@ir_ptr)
    unsafe { LLVMDisposeMessage(@ir_ptr) }
    return @ir_str

# Print the module IR to a file.
# Returns: 1 on success, 0 on failure
fn llvm_context_print_ir_to_file(@self: LlvmContext, @filename: str) -> int
    @error: *u8 = null
    @result = unsafe { LLVMPrintModuleToFile(@self.module, @filename, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return 0
    return 1

# Write LLVM bitcode to a file.
# Returns: 0 on success
fn llvm_context_write_bitcode(@self: LlvmContext, @filename: str) -> int
    return unsafe { LLVMWriteBitcodeToFile(@self.module, @filename) }

# Clone the module (deep copy).
fn llvm_context_clone_module(@self: LlvmContext) -> LLVMModuleRef
    return unsafe { LLVMCloneModule(@self.module) }

# Link another module into this context's module.
# The source module is consumed (destroyed) by this operation.
# Returns: 0 on success
fn llvm_context_link_module(@self: LlvmContext, @src: LLVMModuleRef) -> int
    return unsafe { LLVMLinkModules2(@self.module, @src) }

# Get common type references for this context (convenience).
fn llvm_void_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMVoidTypeInContext(@ctx) }

fn llvm_i1_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMInt1TypeInContext(@ctx) }

fn llvm_i8_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMInt8TypeInContext(@ctx) }

fn llvm_i16_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMInt16TypeInContext(@ctx) }

fn llvm_i32_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMInt32TypeInContext(@ctx) }

fn llvm_i64_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMInt64TypeInContext(@ctx) }

fn llvm_i128_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMInt128TypeInContext(@ctx) }

fn llvm_f16_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMHalfTypeInContext(@ctx) }

fn llvm_f32_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMFloatTypeInContext(@ctx) }

fn llvm_f64_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMDoubleTypeInContext(@ctx) }

fn llvm_ptr_type(@ctx: LLVMContextRef) -> LLVMTypeRef
    return unsafe { LLVMPointerTypeInContext(@ctx, 0) }

fn llvm_int_type(@ctx: LLVMContextRef, @bits: u32) -> LLVMTypeRef
    return unsafe { LLVMIntTypeInContext(@ctx, @bits) }

# -----------------------------------------------------------------------------
# 4.2 LlvmModule - Module-level operations
# -----------------------------------------------------------------------------
# Provides a high-level interface for module operations: adding functions,
# globals, emitting code, etc.

struct LlvmModule
    module_ref: LLVMModuleRef    # The underlying LLVM module handle
    context_ref: LLVMContextRef  # The owning context
    function_count: int          # Number of functions added
    global_count: int            # Number of globals added

# Wrap an existing module reference into a high-level struct.
fn llvm_module_wrap(@module: LLVMModuleRef, @context: LLVMContextRef) -> LlvmModule
    return LlvmModule {
        module_ref: @module,
        context_ref: @context,
        function_count: 0,
        global_count: 0
    }

# Add a function to the module.
# @name: function name
# @ret_type: return type
# @param_types: array of parameter types
# @param_count: number of parameters
# @is_vararg: 1 if variadic, 0 otherwise
# Returns: the function value reference
fn llvm_module_add_function(@self: LlvmModule, @name: str, @ret_type: LLVMTypeRef, @param_types: *LLVMTypeRef, @param_count: u32, @is_vararg: int) -> LLVMValueRef
    @fn_type = unsafe { LLVMFunctionType(@ret_type, @param_types, @param_count, @is_vararg) }
    @fn_val = unsafe { LLVMAddFunction(@self.module_ref, @name, @fn_type) }
    @self.function_count = @self.function_count + 1
    return @fn_val

# Look up a function by name.
# Returns: function value or null if not found
fn llvm_module_get_function(@self: LlvmModule, @name: str) -> LLVMValueRef
    return unsafe { LLVMGetNamedFunction(@self.module_ref, @name) }

# Add a global variable to the module.
# @name: variable name
# @ty: the type of the global
# Returns: the global variable value reference
fn llvm_module_add_global(@self: LlvmModule, @name: str, @ty: LLVMTypeRef) -> LLVMValueRef
    @gv = unsafe { LLVMAddGlobal(@self.module_ref, @ty, @name) }
    @self.global_count = @self.global_count + 1
    return @gv

# Add a global constant string to the module.
fn llvm_module_add_global_string(@self: LlvmModule, @name: str, @value: str) -> LLVMValueRef
    @str_val = unsafe { LLVMConstStringInContext(@self.context_ref, @value, len(@value), 0) }
    @str_ty = unsafe { LLVMArrayType2(LLVMInt8TypeInContext(@self.context_ref), len(@value) + 1) }
    @gv = unsafe { LLVMAddGlobal(@self.module_ref, @str_ty, @name) }
    unsafe { LLVMSetInitializer(@gv, @str_val) }
    unsafe { LLVMSetGlobalConstant(@gv, 1) }
    unsafe { LLVMSetLinkage(@gv, LLVMPrivateLinkage) }
    @self.global_count = @self.global_count + 1
    return @gv

# Look up a global variable by name.
fn llvm_module_get_global(@self: LlvmModule, @name: str) -> LLVMValueRef
    return unsafe { LLVMGetNamedGlobal(@self.module_ref, @name) }

# Verify the module.
# Returns: 1 if valid, 0 if errors found
fn llvm_module_verify(@self: LlvmModule) -> int
    @error: *u8 = null
    @result = unsafe { LLVMVerifyModule(@self.module_ref, LLVMReturnStatusAction, &@error) }
    if @error != null
        unsafe { LLVMDisposeMessage(@error) }
    if @result != 0
        return 0
    return 1

# Print the module IR to a string.
fn llvm_module_print_ir(@self: LlvmModule) -> str
    @ptr = unsafe { LLVMPrintModuleToString(@self.module_ref) }
    @result = str_from_cstr(@ptr)
    unsafe { LLVMDisposeMessage(@ptr) }
    return @result

# Emit an object file (.o / .obj) using the target machine.
# @filename: output file path
# @tm: target machine handle
# Returns: 1 on success, 0 on failure
fn llvm_module_emit_object(@self: LlvmModule, @filename: str, @tm: LLVMTargetMachineRef) -> int
    @error: *u8 = null
    @result = unsafe { LLVMTargetMachineEmitToFile(@tm, @self.module_ref, @filename, LLVMObjectFile, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return 0
    return 1

# Emit assembly (.s) using the target machine.
# @filename: output file path
# @tm: target machine handle
# Returns: 1 on success, 0 on failure
fn llvm_module_emit_assembly(@self: LlvmModule, @filename: str, @tm: LLVMTargetMachineRef) -> int
    @error: *u8 = null
    @result = unsafe { LLVMTargetMachineEmitToFile(@tm, @self.module_ref, @filename, LLVMAssemblyFile, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return 0
    return 1

# Emit object code to a memory buffer.
# Returns: memory buffer handle, or null on failure
fn llvm_module_emit_object_to_memory(@self: LlvmModule, @tm: LLVMTargetMachineRef) -> LLVMMemoryBufferRef
    @error: *u8 = null
    @membuf: LLVMMemoryBufferRef = null
    @result = unsafe { LLVMTargetMachineEmitToMemoryBuffer(@tm, @self.module_ref, LLVMObjectFile, &@error, &@membuf) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return null
    return @membuf

# Iterate over all functions in the module.
# Returns: the first function, or null if module is empty.
# Use llvm_function_next() to iterate.
fn llvm_module_first_function(@self: LlvmModule) -> LLVMValueRef
    return unsafe { LLVMGetFirstFunction(@self.module_ref) }

# Iterate over all globals in the module.
fn llvm_module_first_global(@self: LlvmModule) -> LLVMValueRef
    return unsafe { LLVMGetFirstGlobal(@self.module_ref) }

# Get the next function after the given one (for iteration).
fn llvm_function_next(@fn_val: LLVMValueRef) -> LLVMValueRef
    return unsafe { LLVMGetNextFunction(@fn_val) }

# Get the next global after the given one (for iteration).
fn llvm_global_next(@gv: LLVMValueRef) -> LLVMValueRef
    return unsafe { LLVMGetNextGlobal(@gv) }

# -----------------------------------------------------------------------------
# 4.3 LlvmBuilder - IR Instruction Builder
# -----------------------------------------------------------------------------
# High-level wrapper around the LLVM IR builder. Provides typed, safe
# methods for generating LLVM IR instructions.

struct LlvmBuilder
    builder_ref: LLVMBuilderRef  # The underlying LLVM builder handle
    context_ref: LLVMContextRef  # The owning context
    current_fn: LLVMValueRef     # Current function being built (or null)
    instr_count: int             # Total instructions emitted

# Wrap an existing builder reference.
fn llvm_builder_wrap(@builder: LLVMBuilderRef, @context: LLVMContextRef) -> LlvmBuilder
    return LlvmBuilder {
        builder_ref: @builder,
        context_ref: @context,
        current_fn: null,
        instr_count: 0
    }

# Position the builder at the end of a basic block.
fn llvm_builder_position_at_end(@self: LlvmBuilder, @block: LLVMBasicBlockRef)
    unsafe { LLVMPositionBuilderAtEnd(@self.builder_ref, @block) }

# Position the builder before a specific instruction.
fn llvm_builder_position_before(@self: LlvmBuilder, @instr: LLVMValueRef)
    unsafe { LLVMPositionBuilderBefore(@self.builder_ref, @instr) }

# Get the current insertion block.
fn llvm_builder_get_insert_block(@self: LlvmBuilder) -> LLVMBasicBlockRef
    return unsafe { LLVMGetInsertBlock(@self.builder_ref) }

# --- Terminator Instructions ---

fn llvm_build_ret(@self: LlvmBuilder, @val: LLVMValueRef) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildRet(@self.builder_ref, @val) }

fn llvm_build_ret_void(@self: LlvmBuilder) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildRetVoid(@self.builder_ref) }

fn llvm_build_br(@self: LlvmBuilder, @dest: LLVMBasicBlockRef) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildBr(@self.builder_ref, @dest) }

fn llvm_build_cond_br(@self: LlvmBuilder, @cond: LLVMValueRef, @then_bb: LLVMBasicBlockRef, @else_bb: LLVMBasicBlockRef) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildCondBr(@self.builder_ref, @cond, @then_bb, @else_bb) }

fn llvm_build_switch(@self: LlvmBuilder, @val: LLVMValueRef, @else_bb: LLVMBasicBlockRef, @num_cases: u32) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSwitch(@self.builder_ref, @val, @else_bb, @num_cases) }

fn llvm_build_unreachable(@self: LlvmBuilder) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildUnreachable(@self.builder_ref) }

# --- Integer Arithmetic ---

fn llvm_build_add(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildAdd(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_nsw_add(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildNSWAdd(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_nuw_add(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildNUWAdd(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_sub(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSub(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_nsw_sub(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildNSWSub(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_mul(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildMul(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_nsw_mul(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildNSWMul(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_sdiv(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSDiv(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_udiv(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildUDiv(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_srem(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSRem(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_urem(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildURem(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_neg(@self: LlvmBuilder, @v: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildNeg(@self.builder_ref, @v, @name) }

# --- Floating-Point Arithmetic ---

fn llvm_build_fadd(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFAdd(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_fsub(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFSub(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_fmul(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFMul(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_fdiv(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFDiv(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_frem(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFRem(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_fneg(@self: LlvmBuilder, @v: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFNeg(@self.builder_ref, @v, @name) }

# --- Bitwise Operations ---

fn llvm_build_and(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildAnd(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_or(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildOr(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_xor(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildXor(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_shl(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildShl(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_lshr(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildLShr(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_ashr(@self: LlvmBuilder, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildAShr(@self.builder_ref, @lhs, @rhs, @name) }

fn llvm_build_not(@self: LlvmBuilder, @v: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildNot(@self.builder_ref, @v, @name) }

# --- Memory Operations ---

fn llvm_build_alloca(@self: LlvmBuilder, @ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildAlloca(@self.builder_ref, @ty, @name) }

fn llvm_build_load(@self: LlvmBuilder, @ty: LLVMTypeRef, @ptr: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildLoad2(@self.builder_ref, @ty, @ptr, @name) }

fn llvm_build_store(@self: LlvmBuilder, @val: LLVMValueRef, @ptr: LLVMValueRef) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildStore(@self.builder_ref, @val, @ptr) }

fn llvm_build_gep(@self: LlvmBuilder, @ty: LLVMTypeRef, @ptr: LLVMValueRef, @indices: *LLVMValueRef, @num_indices: u32, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildGEP2(@self.builder_ref, @ty, @ptr, @indices, @num_indices, @name) }

fn llvm_build_inbounds_gep(@self: LlvmBuilder, @ty: LLVMTypeRef, @ptr: LLVMValueRef, @indices: *LLVMValueRef, @num_indices: u32, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildInBoundsGEP2(@self.builder_ref, @ty, @ptr, @indices, @num_indices, @name) }

fn llvm_build_struct_gep(@self: LlvmBuilder, @ty: LLVMTypeRef, @ptr: LLVMValueRef, @idx: u32, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildStructGEP2(@self.builder_ref, @ty, @ptr, @idx, @name) }

fn llvm_build_global_string_ptr(@self: LlvmBuilder, @str_val: str, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildGlobalStringPtr(@self.builder_ref, @str_val, @name) }

# --- Comparison Operations ---

fn llvm_build_icmp(@self: LlvmBuilder, @pred: u32, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildICmp(@self.builder_ref, @pred, @lhs, @rhs, @name) }

fn llvm_build_fcmp(@self: LlvmBuilder, @pred: u32, @lhs: LLVMValueRef, @rhs: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFCmp(@self.builder_ref, @pred, @lhs, @rhs, @name) }

# --- Cast / Conversion Operations ---

fn llvm_build_trunc(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildTrunc(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_zext(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildZExt(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_sext(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSExt(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_fptrunc(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFPTrunc(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_fpext(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFPExt(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_fp_to_ui(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFPToUI(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_fp_to_si(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildFPToSI(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_ui_to_fp(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildUIToFP(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_si_to_fp(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSIToFP(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_ptr_to_int(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildPtrToInt(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_int_to_ptr(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildIntToPtr(@self.builder_ref, @val, @dest_ty, @name) }

fn llvm_build_bitcast(@self: LlvmBuilder, @val: LLVMValueRef, @dest_ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildBitCast(@self.builder_ref, @val, @dest_ty, @name) }

# --- Miscellaneous ---

fn llvm_build_call(@self: LlvmBuilder, @fn_ty: LLVMTypeRef, @fn_val: LLVMValueRef, @args: *LLVMValueRef, @num_args: u32, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildCall2(@self.builder_ref, @fn_ty, @fn_val, @args, @num_args, @name) }

fn llvm_build_select(@self: LlvmBuilder, @cond: LLVMValueRef, @then_val: LLVMValueRef, @else_val: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildSelect(@self.builder_ref, @cond, @then_val, @else_val, @name) }

fn llvm_build_phi(@self: LlvmBuilder, @ty: LLVMTypeRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildPhi(@self.builder_ref, @ty, @name) }

fn llvm_build_extract_element(@self: LlvmBuilder, @vec: LLVMValueRef, @idx: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildExtractElement(@self.builder_ref, @vec, @idx, @name) }

fn llvm_build_insert_element(@self: LlvmBuilder, @vec: LLVMValueRef, @val: LLVMValueRef, @idx: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildInsertElement(@self.builder_ref, @vec, @val, @idx, @name) }

fn llvm_build_shuffle_vector(@self: LlvmBuilder, @v1: LLVMValueRef, @v2: LLVMValueRef, @mask: LLVMValueRef, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildShuffleVector(@self.builder_ref, @v1, @v2, @mask, @name) }

fn llvm_build_extract_value(@self: LlvmBuilder, @agg: LLVMValueRef, @idx: u32, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildExtractValue(@self.builder_ref, @agg, @idx, @name) }

fn llvm_build_insert_value(@self: LlvmBuilder, @agg: LLVMValueRef, @val: LLVMValueRef, @idx: u32, @name: str) -> LLVMValueRef
    @self.instr_count = @self.instr_count + 1
    return unsafe { LLVMBuildInsertValue(@self.builder_ref, @agg, @val, @idx, @name) }

# -----------------------------------------------------------------------------
# 4.4 LlvmFunction - Function-level operations
# -----------------------------------------------------------------------------
# Wraps a function value with convenience methods for basic blocks,
# parameters, attributes, and linkage.

struct LlvmFunction
    fn_ref: LLVMValueRef         # The underlying LLVM function value
    context_ref: LLVMContextRef  # The owning context
    block_count: int             # Number of basic blocks created
    name: str                    # Function name (cached)

# Wrap an existing function value reference.
fn llvm_function_wrap(@fn_ref: LLVMValueRef, @ctx: LLVMContextRef, @name: str) -> LlvmFunction
    return LlvmFunction {
        fn_ref: @fn_ref,
        context_ref: @ctx,
        block_count: 0,
        name: @name
    }

# Append a new basic block to the function.
fn llvm_function_append_block(@self: LlvmFunction, @name: str) -> LLVMBasicBlockRef
    @self.block_count = @self.block_count + 1
    return unsafe { LLVMAppendBasicBlockInContext(@self.context_ref, @self.fn_ref, @name) }

# Get a function parameter by index (0-based).
fn llvm_function_get_param(@self: LlvmFunction, @index: u32) -> LLVMValueRef
    return unsafe { LLVMGetParam(@self.fn_ref, @index) }

# Get the number of parameters.
fn llvm_function_param_count(@self: LlvmFunction) -> u32
    return unsafe { LLVMCountParams(@self.fn_ref) }

# Set the linkage type for this function.
fn llvm_function_set_linkage(@self: LlvmFunction, @linkage: u32)
    unsafe { LLVMSetLinkage(@self.fn_ref, @linkage) }

# Set the calling convention for this function.
fn llvm_function_set_call_conv(@self: LlvmFunction, @cc: u32)
    unsafe { LLVMSetFunctionCallConv(@self.fn_ref, @cc) }

# Set the visibility for this function.
fn llvm_function_set_visibility(@self: LlvmFunction, @viz: u32)
    unsafe { LLVMSetVisibility(@self.fn_ref, @viz) }

# Set the section for this function.
fn llvm_function_set_section(@self: LlvmFunction, @section: str)
    unsafe { LLVMSetSection(@self.fn_ref, @section) }

# Set the alignment of this function.
fn llvm_function_set_alignment(@self: LlvmFunction, @align: u32)
    unsafe { LLVMSetAlignment(@self.fn_ref, @align) }

# Add an enum attribute to this function.
# @idx: LLVMAttributeFunctionIndex (-1), LLVMAttributeReturnIndex (0), or param index (1+)
fn llvm_function_add_attr(@self: LlvmFunction, @idx: u32, @kind_name: str, @val: u64)
    @kind_id = unsafe { LLVMGetEnumAttributeKindForName(@kind_name, len(@kind_name)) }
    @attr = unsafe { LLVMCreateEnumAttribute(@self.context_ref, @kind_id, @val) }
    unsafe { LLVMAddAttributeAtIndex(@self.fn_ref, @idx, @attr) }

# Add a string attribute to this function.
fn llvm_function_add_string_attr(@self: LlvmFunction, @idx: u32, @key: str, @val: str)
    @attr = unsafe { LLVMCreateStringAttribute(@self.context_ref, @key, len(@key), @val, len(@val)) }
    unsafe { LLVMAddAttributeAtIndex(@self.fn_ref, @idx, @attr) }

# Set the personality function (for exception handling).
fn llvm_function_set_personality(@self: LlvmFunction, @personality_fn: LLVMValueRef)
    unsafe { LLVMSetPersonalityFn(@self.fn_ref, @personality_fn) }

# Set the GC strategy for this function.
fn llvm_function_set_gc(@self: LlvmFunction, @gc_name: str)
    unsafe { LLVMSetGC(@self.fn_ref, @gc_name) }

# Verify this function for IR correctness.
# Returns: 1 if valid, 0 if invalid
fn llvm_function_verify(@self: LlvmFunction) -> int
    @result = unsafe { LLVMVerifyFunction(@self.fn_ref, LLVMReturnStatusAction) }
    if @result != 0
        return 0
    return 1

# Get the entry basic block of this function.
fn llvm_function_entry_block(@self: LlvmFunction) -> LLVMBasicBlockRef
    return unsafe { LLVMGetEntryBasicBlock(@self.fn_ref) }

# Get the number of basic blocks.
fn llvm_function_block_count(@self: LlvmFunction) -> u32
    return unsafe { LLVMCountBasicBlocks(@self.fn_ref) }

# Delete the function from its module.
fn llvm_function_delete(@self: LlvmFunction)
    unsafe { LLVMDeleteFunction(@self.fn_ref) }

# =============================================================================
# SECTION 5: CPU FEATURE DETECTION AND TARGET TRIPLE
# =============================================================================

# -----------------------------------------------------------------------------
# 5.1 CpuFeatures - Runtime CPU feature detection
# -----------------------------------------------------------------------------
# Detects available SIMD and CPU features by querying LLVM's host info.
# Used to configure the target machine with optimal feature flags.

struct CpuFeatures
    has_sse42: int               # SSE 4.2 support
    has_avx: int                 # AVX support
    has_avx2: int                # AVX2 support
    has_avx512f: int             # AVX-512 Foundation
    has_avx512vl: int            # AVX-512 Vector Length Extensions
    has_fma: int                 # Fused Multiply-Add
    has_bmi1: int                # Bit Manipulation Instructions 1
    has_bmi2: int                # Bit Manipulation Instructions 2
    has_popcnt: int              # Population Count
    has_lzcnt: int               # Leading Zero Count
    # ARM features
    has_neon: int                # ARM NEON SIMD
    has_sve: int                 # ARM SVE (Scalable Vector Extension)
    has_sve2: int                # ARM SVE2
    # Feature string (cached)
    feature_string: str          # Comma-separated LLVM feature string
    cpu_name: str                # Detected CPU name

# Detect CPU features from the host machine via LLVM.
# Queries LLVMGetHostCPUFeatures and parses the result.
fn cpu_features_detect() -> CpuFeatures
    @cpu_ptr = unsafe { LLVMGetHostCPUName() }
    @cpu_name = str_from_cstr(@cpu_ptr)
    unsafe { LLVMDisposeMessage(@cpu_ptr) }

    @feat_ptr = unsafe { LLVMGetHostCPUFeatures() }
    @feat_str = str_from_cstr(@feat_ptr)
    unsafe { LLVMDisposeMessage(@feat_ptr) }

    # Parse the feature string to set individual flags
    @features = CpuFeatures {
        has_sse42: 0,
        has_avx: 0,
        has_avx2: 0,
        has_avx512f: 0,
        has_avx512vl: 0,
        has_fma: 0,
        has_bmi1: 0,
        has_bmi2: 0,
        has_popcnt: 0,
        has_lzcnt: 0,
        has_neon: 0,
        has_sve: 0,
        has_sve2: 0,
        feature_string: @feat_str,
        cpu_name: @cpu_name
    }

    # Check for individual features in the feature string
    if str_contains(@feat_str, "+sse4.2")
        @features.has_sse42 = 1
    if str_contains(@feat_str, "+avx2")
        @features.has_avx2 = 1
        @features.has_avx = 1     # AVX2 implies AVX
    else
        if str_contains(@feat_str, "+avx")
            @features.has_avx = 1
    if str_contains(@feat_str, "+avx512f")
        @features.has_avx512f = 1
    if str_contains(@feat_str, "+avx512vl")
        @features.has_avx512vl = 1
    if str_contains(@feat_str, "+fma")
        @features.has_fma = 1
    if str_contains(@feat_str, "+bmi")
        @features.has_bmi1 = 1
    if str_contains(@feat_str, "+bmi2")
        @features.has_bmi2 = 1
    if str_contains(@feat_str, "+popcnt")
        @features.has_popcnt = 1
    if str_contains(@feat_str, "+lzcnt")
        @features.has_lzcnt = 1
    if str_contains(@feat_str, "+neon")
        @features.has_neon = 1
    if str_contains(@feat_str, "+sve2")
        @features.has_sve2 = 1
        @features.has_sve = 1     # SVE2 implies SVE
    else
        if str_contains(@feat_str, "+sve")
            @features.has_sve = 1

    return @features

# Get the best SIMD vector width in bits for the detected CPU.
# Returns: 512 (AVX-512), 256 (AVX/SVE), 128 (SSE/NEON), or 64 (scalar)
fn cpu_features_best_vector_width(@self: CpuFeatures) -> u32
    if @self.has_avx512f == 1
        return 512
    if @self.has_avx2 == 1 or @self.has_avx == 1
        return 256
    if @self.has_sse42 == 1
        return 128
    if @self.has_sve2 == 1 or @self.has_sve == 1
        return 256
    if @self.has_neon == 1
        return 128
    return 64

# Build an LLVM-compatible feature string from detected features.
# Returns: e.g., "+sse4.2,+avx2,+fma" or "+neon"
fn cpu_features_to_llvm_string(@self: CpuFeatures) -> str
    @parts: [str] = []
    if @self.has_sse42 == 1
        @parts = append(@parts, "+sse4.2")
    if @self.has_avx == 1
        @parts = append(@parts, "+avx")
    if @self.has_avx2 == 1
        @parts = append(@parts, "+avx2")
    if @self.has_avx512f == 1
        @parts = append(@parts, "+avx512f")
    if @self.has_avx512vl == 1
        @parts = append(@parts, "+avx512vl")
    if @self.has_fma == 1
        @parts = append(@parts, "+fma")
    if @self.has_bmi1 == 1
        @parts = append(@parts, "+bmi")
    if @self.has_bmi2 == 1
        @parts = append(@parts, "+bmi2")
    if @self.has_popcnt == 1
        @parts = append(@parts, "+popcnt")
    if @self.has_lzcnt == 1
        @parts = append(@parts, "+lzcnt")
    if @self.has_neon == 1
        @parts = append(@parts, "+neon")
    if @self.has_sve == 1
        @parts = append(@parts, "+sve")
    if @self.has_sve2 == 1
        @parts = append(@parts, "+sve2")
    return str_join(@parts, ",")

# Check if the CPU supports any form of SIMD.
fn cpu_features_has_simd(@self: CpuFeatures) -> int
    if @self.has_sse42 == 1 or @self.has_avx == 1 or @self.has_neon == 1 or @self.has_sve == 1
        return 1
    return 0

# -----------------------------------------------------------------------------
# 5.2 TargetTriple - Target triple management
# -----------------------------------------------------------------------------
# Represents a parsed target triple (arch-vendor-os-env).
# Used to configure LLVM code generation for a specific platform.

struct TargetTriple
    arch: str                    # Architecture: x86_64, aarch64, riscv64, wasm32
    vendor: str                  # Vendor: pc, apple, unknown
    os: str                      # OS: windows, linux, darwin, freestanding
    env: str                     # Environment: msvc, gnu, musl, eabi
    raw: str                     # Original raw triple string

# Get the host machine's target triple.
fn target_triple_host() -> TargetTriple
    @triple_ptr = unsafe { LLVMGetDefaultTargetTriple() }
    @raw = str_from_cstr(@triple_ptr)
    unsafe { LLVMDisposeMessage(@triple_ptr) }
    return target_triple_parse(@raw)

# Parse a target triple string into its components.
fn target_triple_parse(@raw: str) -> TargetTriple
    @parts = str_split(@raw, "-")
    @arch = ""
    @vendor = ""
    @os = ""
    @env = ""
    if len(@parts) >= 1
        @arch = @parts[0]
    if len(@parts) >= 2
        @vendor = @parts[1]
    if len(@parts) >= 3
        @os = @parts[2]
    if len(@parts) >= 4
        @env = @parts[3]
    return TargetTriple {
        arch: @arch,
        vendor: @vendor,
        os: @os,
        env: @env,
        raw: @raw
    }

# Convert the target triple back to a string.
fn target_triple_to_string(@self: TargetTriple) -> str
    if @self.env == ""
        return @self.arch + "-" + @self.vendor + "-" + @self.os
    return @self.arch + "-" + @self.vendor + "-" + @self.os + "-" + @self.env

# Create a specific target triple.
fn target_triple_new(@arch: str, @vendor: str, @os: str, @env: str) -> TargetTriple
    @raw = @arch + "-" + @vendor + "-" + @os
    if @env != ""
        @raw = @raw + "-" + @env
    return TargetTriple {
        arch: @arch,
        vendor: @vendor,
        os: @os,
        env: @env,
        raw: @raw
    }

# Predefined target triples for common platforms.
fn target_triple_x86_64_linux() -> TargetTriple
    return target_triple_new("x86_64", "unknown", "linux", "gnu")

fn target_triple_x86_64_windows() -> TargetTriple
    return target_triple_new("x86_64", "pc", "windows", "msvc")

fn target_triple_aarch64_macos() -> TargetTriple
    return target_triple_new("aarch64", "apple", "darwin", "")

fn target_triple_aarch64_linux() -> TargetTriple
    return target_triple_new("aarch64", "unknown", "linux", "gnu")

fn target_triple_riscv64_linux() -> TargetTriple
    return target_triple_new("riscv64", "unknown", "linux", "gnu")

fn target_triple_wasm32() -> TargetTriple
    return target_triple_new("wasm32", "unknown", "unknown", "")

# Check if the target is a 64-bit architecture.
fn target_triple_is_64bit(@self: TargetTriple) -> int
    if @self.arch == "x86_64" or @self.arch == "aarch64" or @self.arch == "riscv64"
        return 1
    return 0

# Check if the target is Windows.
fn target_triple_is_windows(@self: TargetTriple) -> int
    if str_contains(@self.os, "windows") or str_contains(@self.os, "win32")
        return 1
    return 0

# Check if the target is macOS/Darwin.
fn target_triple_is_macos(@self: TargetTriple) -> int
    if str_contains(@self.os, "darwin") or str_contains(@self.os, "macos")
        return 1
    return 0

# Check if the target is Linux.
fn target_triple_is_linux(@self: TargetTriple) -> int
    if str_contains(@self.os, "linux")
        return 1
    return 0

# Get the appropriate default data layout for common targets.
fn target_triple_default_data_layout(@self: TargetTriple) -> str
    if @self.arch == "x86_64"
        if target_triple_is_windows(@self)
            return "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
        return "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
    if @self.arch == "aarch64"
        if target_triple_is_macos(@self)
            return "e-m:o-i64:64-i128:128-n32:64-S128-Fn32"
        return "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
    if @self.arch == "riscv64"
        return "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
    if @self.arch == "wasm32"
        return "e-m:e-p:32:32-p10:8:8-p20:8:8-i64:64-n32:64-S128-ni:1:10:20"
    # Fallback: generic x86_64 linux
    return "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"

# Initialize the appropriate LLVM target based on the triple.
# Returns: 1 on success, 0 on failure
fn target_triple_init_target(@self: TargetTriple) -> int
    match @self.arch
        phase "x86_64" =>
            unsafe { LLVMInitializeX86TargetInfo() }
            unsafe { LLVMInitializeX86Target() }
            unsafe { LLVMInitializeX86TargetMC() }
            unsafe { LLVMInitializeX86AsmPrinter() }
            unsafe { LLVMInitializeX86AsmParser() }
            return 1
        phase "aarch64" =>
            unsafe { LLVMInitializeAArch64TargetInfo() }
            unsafe { LLVMInitializeAArch64Target() }
            unsafe { LLVMInitializeAArch64TargetMC() }
            unsafe { LLVMInitializeAArch64AsmPrinter() }
            unsafe { LLVMInitializeAArch64AsmParser() }
            return 1
        phase "riscv64" =>
            unsafe { LLVMInitializeRISCVTargetInfo() }
            unsafe { LLVMInitializeRISCVTarget() }
            unsafe { LLVMInitializeRISCVTargetMC() }
            unsafe { LLVMInitializeRISCVAsmPrinter() }
            unsafe { LLVMInitializeRISCVAsmParser() }
            return 1
        phase "wasm32" =>
            unsafe { LLVMInitializeWebAssemblyTargetInfo() }
            unsafe { LLVMInitializeWebAssemblyTarget() }
            unsafe { LLVMInitializeWebAssemblyTargetMC() }
            unsafe { LLVMInitializeWebAssemblyAsmPrinter() }
            unsafe { LLVMInitializeWebAssemblyAsmParser() }
            return 1
        _ =>
            # Fallback: try to initialize all targets
            unsafe { LLVMInitializeAllTargetInfos() }
            unsafe { LLVMInitializeAllTargets() }
            unsafe { LLVMInitializeAllTargetMCs() }
            unsafe { LLVMInitializeAllAsmPrinters() }
            unsafe { LLVMInitializeAllAsmParsers() }
            return 1

# =============================================================================
# SECTION 6: IR GENERATION TYPES
# =============================================================================
# These types mirror the Rust backend/llvm.rs types for IR generation.
# Used by the Luna self-hosting compiler to represent LLVM IR.

# -----------------------------------------------------------------------------
# 6.1 LlvmType enum (integer-tagged)
# -----------------------------------------------------------------------------
# Represents LLVM IR types. Uses integer tags for fast pattern matching.

const LLVM_TYPE_VOID: int = 0
const LLVM_TYPE_I1: int = 1
const LLVM_TYPE_I8: int = 2
const LLVM_TYPE_I16: int = 3
const LLVM_TYPE_I32: int = 4
const LLVM_TYPE_I64: int = 5
const LLVM_TYPE_I128: int = 6
const LLVM_TYPE_F16: int = 7
const LLVM_TYPE_F32: int = 8
const LLVM_TYPE_F64: int = 9
const LLVM_TYPE_PTR: int = 10
const LLVM_TYPE_ARRAY: int = 11
const LLVM_TYPE_VECTOR: int = 12
const LLVM_TYPE_STRUCT: int = 13
const LLVM_TYPE_FUNCTION: int = 14

struct IrType
    kind: int                    # LLVM_TYPE_* constant
    # For Ptr: pointee type index (-1 for opaque)
    inner_type_idx: int
    # For Array: element count
    array_len: int
    # For Vector: element count
    vector_len: int
    # For Struct: field type indices (packed array)
    field_types: [int]
    field_count: int
    # For Function: return type index and param type indices
    ret_type_idx: int
    param_types: [int]
    param_count: int
    # For Struct: whether it is packed (no padding)
    is_packed: int

# Construct basic IR types.
fn ir_type_void() -> IrType
    return IrType { kind: LLVM_TYPE_VOID, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_i1() -> IrType
    return IrType { kind: LLVM_TYPE_I1, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_i8() -> IrType
    return IrType { kind: LLVM_TYPE_I8, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_i16() -> IrType
    return IrType { kind: LLVM_TYPE_I16, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_i32() -> IrType
    return IrType { kind: LLVM_TYPE_I32, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_i64() -> IrType
    return IrType { kind: LLVM_TYPE_I64, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_i128() -> IrType
    return IrType { kind: LLVM_TYPE_I128, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_f16() -> IrType
    return IrType { kind: LLVM_TYPE_F16, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_f32() -> IrType
    return IrType { kind: LLVM_TYPE_F32, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_f64() -> IrType
    return IrType { kind: LLVM_TYPE_F64, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_ptr(@inner: int) -> IrType
    return IrType { kind: LLVM_TYPE_PTR, inner_type_idx: @inner, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_array(@elem: int, @count: int) -> IrType
    return IrType { kind: LLVM_TYPE_ARRAY, inner_type_idx: @elem, array_len: @count, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_vector(@elem: int, @count: int) -> IrType
    return IrType { kind: LLVM_TYPE_VECTOR, inner_type_idx: @elem, array_len: 0, vector_len: @count, field_types: [], field_count: 0, ret_type_idx: -1, param_types: [], param_count: 0, is_packed: 0 }

fn ir_type_struct(@fields: [int], @packed: int) -> IrType
    return IrType { kind: LLVM_TYPE_STRUCT, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: @fields, field_count: len(@fields), ret_type_idx: -1, param_types: [], param_count: 0, is_packed: @packed }

fn ir_type_function(@ret: int, @params: [int]) -> IrType
    return IrType { kind: LLVM_TYPE_FUNCTION, inner_type_idx: -1, array_len: 0, vector_len: 0, field_types: [], field_count: 0, ret_type_idx: @ret, param_types: @params, param_count: len(@params), is_packed: 0 }

# Get the size in bits of a basic IR type.
fn ir_type_size_bits(@self: IrType) -> int
    match @self.kind
        phase LLVM_TYPE_VOID => return 0
        phase LLVM_TYPE_I1 => return 1
        phase LLVM_TYPE_I8 => return 8
        phase LLVM_TYPE_I16 => return 16
        phase LLVM_TYPE_I32 => return 32
        phase LLVM_TYPE_I64 => return 64
        phase LLVM_TYPE_I128 => return 128
        phase LLVM_TYPE_F16 => return 16
        phase LLVM_TYPE_F32 => return 32
        phase LLVM_TYPE_F64 => return 64
        phase LLVM_TYPE_PTR => return 64
        _ => return 0

# Convert an IrType to its LLVM IR text representation.
fn ir_type_to_ir(@self: IrType) -> str
    match @self.kind
        phase LLVM_TYPE_VOID => return "void"
        phase LLVM_TYPE_I1 => return "i1"
        phase LLVM_TYPE_I8 => return "i8"
        phase LLVM_TYPE_I16 => return "i16"
        phase LLVM_TYPE_I32 => return "i32"
        phase LLVM_TYPE_I64 => return "i64"
        phase LLVM_TYPE_I128 => return "i128"
        phase LLVM_TYPE_F16 => return "half"
        phase LLVM_TYPE_F32 => return "float"
        phase LLVM_TYPE_F64 => return "double"
        phase LLVM_TYPE_PTR => return "ptr"
        _ => return "unknown"

# Materialize an IrType into an actual LLVMTypeRef via the C API.
fn ir_type_materialize(@self: IrType, @ctx: LLVMContextRef) -> LLVMTypeRef
    match @self.kind
        phase LLVM_TYPE_VOID => return unsafe { LLVMVoidTypeInContext(@ctx) }
        phase LLVM_TYPE_I1 => return unsafe { LLVMInt1TypeInContext(@ctx) }
        phase LLVM_TYPE_I8 => return unsafe { LLVMInt8TypeInContext(@ctx) }
        phase LLVM_TYPE_I16 => return unsafe { LLVMInt16TypeInContext(@ctx) }
        phase LLVM_TYPE_I32 => return unsafe { LLVMInt32TypeInContext(@ctx) }
        phase LLVM_TYPE_I64 => return unsafe { LLVMInt64TypeInContext(@ctx) }
        phase LLVM_TYPE_I128 => return unsafe { LLVMInt128TypeInContext(@ctx) }
        phase LLVM_TYPE_F16 => return unsafe { LLVMHalfTypeInContext(@ctx) }
        phase LLVM_TYPE_F32 => return unsafe { LLVMFloatTypeInContext(@ctx) }
        phase LLVM_TYPE_F64 => return unsafe { LLVMDoubleTypeInContext(@ctx) }
        phase LLVM_TYPE_PTR => return unsafe { LLVMPointerTypeInContext(@ctx, 0) }
        _ => return unsafe { LLVMVoidTypeInContext(@ctx) }

# -----------------------------------------------------------------------------
# 6.2 IcmpPred and FcmpPred enums
# -----------------------------------------------------------------------------

const ICMP_EQ: int = 0
const ICMP_NE: int = 1
const ICMP_UGT: int = 2
const ICMP_UGE: int = 3
const ICMP_ULT: int = 4
const ICMP_ULE: int = 5
const ICMP_SGT: int = 6
const ICMP_SGE: int = 7
const ICMP_SLT: int = 8
const ICMP_SLE: int = 9

# Convert an IcmpPred to the LLVM C API integer predicate value.
fn icmp_pred_to_llvm(@pred: int) -> u32
    match @pred
        phase ICMP_EQ => return LLVMIntEQ
        phase ICMP_NE => return LLVMIntNE
        phase ICMP_UGT => return LLVMIntUGT
        phase ICMP_UGE => return LLVMIntUGE
        phase ICMP_ULT => return LLVMIntULT
        phase ICMP_ULE => return LLVMIntULE
        phase ICMP_SGT => return LLVMIntSGT
        phase ICMP_SGE => return LLVMIntSGE
        phase ICMP_SLT => return LLVMIntSLT
        phase ICMP_SLE => return LLVMIntSLE
        _ => return LLVMIntEQ

# Convert an IcmpPred to its LLVM IR text form.
fn icmp_pred_to_ir(@pred: int) -> str
    match @pred
        phase ICMP_EQ => return "eq"
        phase ICMP_NE => return "ne"
        phase ICMP_UGT => return "ugt"
        phase ICMP_UGE => return "uge"
        phase ICMP_ULT => return "ult"
        phase ICMP_ULE => return "ule"
        phase ICMP_SGT => return "sgt"
        phase ICMP_SGE => return "sge"
        phase ICMP_SLT => return "slt"
        phase ICMP_SLE => return "sle"
        _ => return "eq"

const FCMP_FALSE: int = 0
const FCMP_OEQ: int = 1
const FCMP_OGT: int = 2
const FCMP_OGE: int = 3
const FCMP_OLT: int = 4
const FCMP_OLE: int = 5
const FCMP_ONE: int = 6
const FCMP_ORD: int = 7
const FCMP_UEQ: int = 8
const FCMP_UGT: int = 9
const FCMP_UGE: int = 10
const FCMP_ULT: int = 11
const FCMP_ULE: int = 12
const FCMP_UNE: int = 13
const FCMP_UNO: int = 14
const FCMP_TRUE: int = 15

# Convert an FcmpPred to the LLVM C API real predicate value.
fn fcmp_pred_to_llvm(@pred: int) -> u32
    match @pred
        phase FCMP_FALSE => return LLVMRealPredicateFalse
        phase FCMP_OEQ => return LLVMRealOEQ
        phase FCMP_OGT => return LLVMRealOGT
        phase FCMP_OGE => return LLVMRealOGE
        phase FCMP_OLT => return LLVMRealOLT
        phase FCMP_OLE => return LLVMRealOLE
        phase FCMP_ONE => return LLVMRealONE
        phase FCMP_ORD => return LLVMRealORD
        phase FCMP_UEQ => return LLVMRealUEQ
        phase FCMP_UGT => return LLVMRealUGT
        phase FCMP_UGE => return LLVMRealUGE
        phase FCMP_ULT => return LLVMRealULT
        phase FCMP_ULE => return LLVMRealULE
        phase FCMP_UNE => return LLVMRealUNE
        phase FCMP_UNO => return LLVMRealUNO
        phase FCMP_TRUE => return LLVMRealPredicateTrue
        _ => return LLVMRealOEQ

# Convert an FcmpPred to its LLVM IR text form.
fn fcmp_pred_to_ir(@pred: int) -> str
    match @pred
        phase FCMP_FALSE => return "false"
        phase FCMP_OEQ => return "oeq"
        phase FCMP_OGT => return "ogt"
        phase FCMP_OGE => return "oge"
        phase FCMP_OLT => return "olt"
        phase FCMP_OLE => return "ole"
        phase FCMP_ONE => return "one"
        phase FCMP_ORD => return "ord"
        phase FCMP_UEQ => return "ueq"
        phase FCMP_UGT => return "ugt"
        phase FCMP_UGE => return "uge"
        phase FCMP_ULT => return "ult"
        phase FCMP_ULE => return "ule"
        phase FCMP_UNE => return "une"
        phase FCMP_UNO => return "uno"
        phase FCMP_TRUE => return "true"
        _ => return "oeq"

# -----------------------------------------------------------------------------
# 6.3 Linkage enum
# -----------------------------------------------------------------------------

const LINKAGE_EXTERNAL: int = 0
const LINKAGE_INTERNAL: int = 1
const LINKAGE_PRIVATE: int = 2
const LINKAGE_WEAK: int = 3
const LINKAGE_WEAK_ODR: int = 4
const LINKAGE_LINKONCE_ODR: int = 5
const LINKAGE_COMMON: int = 6
const LINKAGE_APPENDING: int = 7

# Convert a Luna linkage constant to the LLVM C API value.
fn linkage_to_llvm(@linkage: int) -> u32
    match @linkage
        phase LINKAGE_EXTERNAL => return LLVMExternalLinkage
        phase LINKAGE_INTERNAL => return LLVMInternalLinkage
        phase LINKAGE_PRIVATE => return LLVMPrivateLinkage
        phase LINKAGE_WEAK => return LLVMWeakAnyLinkage
        phase LINKAGE_WEAK_ODR => return LLVMWeakODRLinkage
        phase LINKAGE_LINKONCE_ODR => return LLVMLinkOnceODRLinkage
        phase LINKAGE_COMMON => return LLVMCommonLinkage
        phase LINKAGE_APPENDING => return LLVMAppendingLinkage
        _ => return LLVMExternalLinkage

# -----------------------------------------------------------------------------
# 6.4 FunctionAttrs struct
# -----------------------------------------------------------------------------
# Commonly-used function attributes for code generation.

struct FunctionAttrs
    is_noinline: int             # Prevent inlining
    is_alwaysinline: int         # Force inlining
    is_noreturn: int             # Function never returns
    is_nounwind: int             # Function does not throw
    is_readonly: int             # Function does not write memory
    is_writeonly: int            # Function only writes memory
    is_naked: int                # No prologue/epilogue
    is_cold: int                 # Rarely called (affects layout)
    is_hot: int                  # Frequently called (affects layout)
    is_norecurse: int            # Does not call itself recursively
    is_convergent: int           # Must not be made non-convergent
    stack_alignment: int         # Required stack alignment (0 = default)

# Create default function attributes (all disabled).
fn function_attrs_default() -> FunctionAttrs
    return FunctionAttrs {
        is_noinline: 0,
        is_alwaysinline: 0,
        is_noreturn: 0,
        is_nounwind: 0,
        is_readonly: 0,
        is_writeonly: 0,
        is_naked: 0,
        is_cold: 0,
        is_hot: 0,
        is_norecurse: 0,
        is_convergent: 0,
        stack_alignment: 0
    }

# Apply function attributes to an LLVM function value.
fn function_attrs_apply(@self: FunctionAttrs, @fn_ref: LLVMValueRef, @ctx: LLVMContextRef)
    # Function attribute index is -1 (max u32)
    @fn_idx: u32 = 4294967295
    if @self.is_noinline == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("noinline", 8) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_alwaysinline == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("alwaysinline", 12) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_noreturn == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("noreturn", 8) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_nounwind == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("nounwind", 8) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_readonly == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("readonly", 8) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_cold == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("cold", 4) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_hot == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("hot", 3) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }
    if @self.is_norecurse == 1
        @kind = unsafe { LLVMGetEnumAttributeKindForName("norecurse", 9) }
        @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
        unsafe { LLVMAddAttributeAtIndex(@fn_ref, @fn_idx, @attr) }

# =============================================================================
# SECTION 7: OPTIMIZATION PIPELINE
# =============================================================================
# Multi-level optimization using LLVM 18's new pass manager (LLVMRunPasses).
# Supports O0 through Oz, with per-pass control for advanced users.

# -----------------------------------------------------------------------------
# 7.1 Optimization Pass Definitions
# -----------------------------------------------------------------------------
# Pass names correspond to the LLVM 18 new pass manager textual pipeline syntax.

# Analysis passes
const PASS_INSTCOMBINE: str = "instcombine"
const PASS_REASSOCIATE: str = "reassociate"
const PASS_GVN: str = "gvn"
const PASS_SCCP: str = "sccp"
const PASS_BDCE: str = "bdce"
const PASS_ADCE: str = "adce"
const PASS_LICM: str = "licm"
const PASS_SIMPLIFYCFG: str = "simplifycfg"
const PASS_EARLY_CSE: str = "early-cse"
const PASS_MEMCPYOPT: str = "memcpyopt"
const PASS_DSE: str = "dse"

# Transform passes
const PASS_SROA: str = "sroa"
const PASS_MEM2REG: str = "mem2reg"
const PASS_INLINE: str = "inline"
const PASS_AGGRESSIVE_INSTCOMBINE: str = "aggressive-instcombine"
const PASS_CORRELATED_PROPAGATION: str = "correlated-propagation"
const PASS_JUMP_THREADING: str = "jump-threading"
const PASS_LOOP_ROTATE: str = "loop-rotate"
const PASS_LOOP_UNROLL: str = "loop-unroll"
const PASS_LOOP_VECTORIZE: str = "loop-vectorize"
const PASS_SLP_VECTORIZE: str = "slp-vectorizer"
const PASS_LOOP_UNSWITCH: str = "simple-loop-unswitch"
const PASS_LOOP_IDIOM: str = "loop-idiom"
const PASS_LOOP_DELETION: str = "loop-deletion"
const PASS_INDVARS: str = "indvars"
const PASS_TAILCALLELIM: str = "tailcallelim"
const PASS_GLOBALDCE: str = "globaldce"
const PASS_GLOBALOPT: str = "globalopt"
const PASS_CONSTMERGE: str = "constmerge"
const PASS_MERGEFUNC: str = "mergefunc"
const PASS_STRIP_DEAD_PROTOTYPES: str = "strip-dead-prototypes"
const PASS_FLOAT2INT: str = "float2int"
const PASS_LOWER_CONSTANT_INTRINSICS: str = "lower-constant-intrinsics"
const PASS_LOWER_EXPECT: str = "lower-expect"
const PASS_CALLSITE_SPLITTING: str = "callsite-splitting"
const PASS_IPSCCP: str = "ipsccp"
const PASS_CALLED_VALUE_PROPAGATION: str = "called-value-propagation"
const PASS_DEADARGELIM: str = "deadargelim"
const PASS_ARGPROMOTION: str = "argpromotion"

# Sanitizer passes
const PASS_ASAN: str = "asan"
const PASS_MSAN: str = "msan"
const PASS_TSAN: str = "tsan"

# -----------------------------------------------------------------------------
# 7.2 OptPipeline struct
# -----------------------------------------------------------------------------
# Collects a list of passes and runs them via the LLVM 18 new pass manager.

struct OptPipeline
    passes: [str]                # List of pass names
    pass_count: int              # Number of passes
    loop_vectorize: int          # Enable loop vectorization (1/0)
    slp_vectorize: int           # Enable SLP vectorization (1/0)
    loop_unroll: int             # Enable loop unrolling (1/0)
    loop_interleave: int         # Enable loop interleaving (1/0)
    merge_functions: int         # Enable function merging (1/0)
    verify_each: int             # Verify IR after each pass (1/0, debug)
    debug_logging: int           # Enable debug logging (1/0, debug)

# Create a default (empty) optimization pipeline.
fn opt_pipeline_new() -> OptPipeline
    return OptPipeline {
        passes: [],
        pass_count: 0,
        loop_vectorize: 1,
        slp_vectorize: 1,
        loop_unroll: 1,
        loop_interleave: 1,
        merge_functions: 0,
        verify_each: 0,
        debug_logging: 0
    }

# Add a pass to the pipeline.
fn opt_pipeline_add_pass(@self: OptPipeline, @pass: str)
    @self.passes = append(@self.passes, @pass)
    @self.pass_count = @self.pass_count + 1

# Build the textual pipeline string for LLVMRunPasses.
# For standard optimization levels, uses "default<OX>".
# For custom pipelines, joins individual passes with commas.
fn opt_pipeline_build_string(@self: OptPipeline, @level: u32) -> str
    # Use LLVM's built-in optimization presets for standard levels
    match @level
        phase OPT_O0 => return "default<O0>"
        phase OPT_O1 => return "default<O1>"
        phase OPT_O2 => return "default<O2>"
        phase OPT_O3 => return "default<O3>"
        phase OPT_Os => return "default<Os>"
        phase OPT_Oz => return "default<Oz>"
        _ =>
            # Custom pipeline: join all pass names
            if @self.pass_count == 0
                return "default<O2>"
            return str_join(@self.passes, ",")

# Run the optimization pipeline on a module.
# @module: the LLVM module to optimize
# @tm: target machine for target-specific passes
# @level: optimization level (OPT_O0 through OPT_Oz)
# Returns: 1 on success, 0 on failure
fn opt_pipeline_run(@self: OptPipeline, @module: LLVMModuleRef, @tm: LLVMTargetMachineRef, @level: u32) -> int
    @pipeline_str = opt_pipeline_build_string(@self, @level)

    # Create pass builder options
    @options = unsafe { LLVMCreatePassBuilderOptions() }
    unsafe { LLVMPassBuilderOptionsSetLoopVectorization(@options, @self.loop_vectorize) }
    unsafe { LLVMPassBuilderOptionsSetSLPVectorization(@options, @self.slp_vectorize) }
    unsafe { LLVMPassBuilderOptionsSetLoopUnrolling(@options, @self.loop_unroll) }
    unsafe { LLVMPassBuilderOptionsSetLoopInterleaving(@options, @self.loop_interleave) }
    unsafe { LLVMPassBuilderOptionsSetMergeFunctions(@options, @self.merge_functions) }
    unsafe { LLVMPassBuilderOptionsSetVerifyEach(@options, @self.verify_each) }
    unsafe { LLVMPassBuilderOptionsSetDebugLogging(@options, @self.debug_logging) }

    # Run the passes
    @err = unsafe { LLVMRunPasses(@module, @pipeline_str, @tm, @options) }
    unsafe { LLVMDisposePassBuilderOptions(@options) }

    # Check for errors (null = success)
    if @err != null
        @msg = unsafe { LLVMGetErrorMessage(@err) }
        unsafe { LLVMDisposeErrorMessage(@msg) }
        unsafe { LLVMConsumeError(@err) }
        return 0
    return 1

# Run a standard optimization level on a module (convenience function).
# Combines target initialization, pipeline creation, and execution.
fn opt_run_on_module(@module: LLVMModuleRef, @tm: LLVMTargetMachineRef, @level: u32) -> int
    @pipeline = opt_pipeline_new()
    return opt_pipeline_run(@pipeline, @module, @tm, @level)

# Create an O1 pipeline with specific Luna-tuned passes.
fn opt_pipeline_o1() -> OptPipeline
    @pipeline = opt_pipeline_new()
    @pipeline.loop_vectorize = 0
    @pipeline.slp_vectorize = 0
    @pipeline.merge_functions = 0
    return @pipeline

# Create an O2 pipeline (standard for release builds).
fn opt_pipeline_o2() -> OptPipeline
    @pipeline = opt_pipeline_new()
    @pipeline.loop_vectorize = 1
    @pipeline.slp_vectorize = 1
    @pipeline.loop_unroll = 1
    @pipeline.merge_functions = 0
    return @pipeline

# Create an O3 pipeline (aggressive, may increase code size).
fn opt_pipeline_o3() -> OptPipeline
    @pipeline = opt_pipeline_new()
    @pipeline.loop_vectorize = 1
    @pipeline.slp_vectorize = 1
    @pipeline.loop_unroll = 1
    @pipeline.loop_interleave = 1
    @pipeline.merge_functions = 1
    return @pipeline

# Create an Os pipeline (optimize for size).
fn opt_pipeline_os() -> OptPipeline
    @pipeline = opt_pipeline_new()
    @pipeline.loop_vectorize = 0
    @pipeline.slp_vectorize = 0
    @pipeline.loop_unroll = 0
    @pipeline.merge_functions = 1
    return @pipeline

# =============================================================================
# SECTION 8: LTO (LINK-TIME OPTIMIZATION) MANAGER
# =============================================================================
# Supports thin LTO and full LTO for cross-module optimization.

# LTO modes
const LTO_NONE: int = 0                    # No LTO
const LTO_THIN: int = 1                    # Thin LTO (parallel, fast)
const LTO_FULL: int = 2                    # Full LTO (maximum optimization)

struct LtoManager
    mode: int                    # LTO_NONE, LTO_THIN, or LTO_FULL
    modules: [LLVMModuleRef]     # Modules to link
    module_count: int            # Number of modules
    merged_module: LLVMModuleRef # Resulting merged module (null until merge)
    opt_level: u32               # Optimization level for LTO passes

# Create a new LTO manager.
fn lto_manager_new(@mode: int, @opt_level: u32) -> LtoManager
    return LtoManager {
        mode: @mode,
        modules: [],
        module_count: 0,
        merged_module: null,
        opt_level: @opt_level
    }

# Add a module to the LTO pipeline.
fn lto_manager_add_module(@self: LtoManager, @module: LLVMModuleRef)
    @self.modules = append(@self.modules, @module)
    @self.module_count = @self.module_count + 1

# Merge all modules into a single module for full LTO.
# The first module becomes the destination; all others are linked into it.
# Returns: 1 on success, 0 on failure
fn lto_manager_merge_modules(@self: LtoManager) -> int
    if @self.module_count == 0
        return 0
    if @self.module_count == 1
        @self.merged_module = @self.modules[0]
        return 1

    # Start with the first module as the destination
    @dest = @self.modules[0]
    @i = 1
    orbit @i in 1..@self.module_count
        @src = @self.modules[@i]
        # Clone the source so the original is not destroyed
        @src_clone = unsafe { LLVMCloneModule(@src) }
        @result = unsafe { LLVMLinkModules2(@dest, @src_clone) }
        if @result != 0
            return 0
    @self.merged_module = @dest
    return 1

# Run LTO optimization passes on the merged module.
# Must call lto_manager_merge_modules first.
# Returns: 1 on success, 0 on failure
fn lto_manager_optimize(@self: LtoManager, @tm: LLVMTargetMachineRef) -> int
    if @self.merged_module == null
        return 0

    @pipeline_str = ""
    match @self.mode
        phase LTO_THIN =>
            @pipeline_str = "thinlto-pre-link<O" + str(@self.opt_level) + ">"
        phase LTO_FULL =>
            @pipeline_str = "lto-pre-link<O" + str(@self.opt_level) + ">"
        _ =>
            # No LTO, just run default optimization
            @pipeline_str = "default<O" + str(@self.opt_level) + ">"

    @options = unsafe { LLVMCreatePassBuilderOptions() }
    unsafe { LLVMPassBuilderOptionsSetLoopVectorization(@options, 1) }
    unsafe { LLVMPassBuilderOptionsSetSLPVectorization(@options, 1) }
    unsafe { LLVMPassBuilderOptionsSetMergeFunctions(@options, 1) }

    @err = unsafe { LLVMRunPasses(@self.merged_module, @pipeline_str, @tm, @options) }
    unsafe { LLVMDisposePassBuilderOptions(@options) }

    if @err != null
        @msg = unsafe { LLVMGetErrorMessage(@err) }
        unsafe { LLVMDisposeErrorMessage(@msg) }
        unsafe { LLVMConsumeError(@err) }
        return 0
    return 1

# Run internalize + global DCE for full LTO (removes unused symbols).
fn lto_manager_internalize(@self: LtoManager, @tm: LLVMTargetMachineRef) -> int
    if @self.merged_module == null
        return 0
    @options = unsafe { LLVMCreatePassBuilderOptions() }
    @err = unsafe { LLVMRunPasses(@self.merged_module, "internalize,globaldce", @tm, @options) }
    unsafe { LLVMDisposePassBuilderOptions(@options) }
    if @err != null
        unsafe { LLVMConsumeError(@err) }
        return 0
    return 1

# Emit the final LTO-optimized object file.
# Returns: 1 on success, 0 on failure
fn lto_manager_emit_object(@self: LtoManager, @filename: str, @tm: LLVMTargetMachineRef) -> int
    if @self.merged_module == null
        return 0
    @error: *u8 = null
    @result = unsafe { LLVMTargetMachineEmitToFile(@tm, @self.merged_module, @filename, LLVMObjectFile, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return 0
    return 1

# =============================================================================
# SECTION 9: PGO (PROFILE-GUIDED OPTIMIZATION) SUPPORT
# =============================================================================
# Load and apply profiling data for PGO-optimized builds.
# PGO data includes function execution counts and branch probabilities.

# Maximum number of functions tracked in a PGO profile
const PGO_MAX_FUNCTIONS: int = 16384

# Maximum number of branch probability entries
const PGO_MAX_BRANCHES: int = 65536

struct PgoFunctionCount
    name: str                    # Function name
    count: int                   # Execution count from profiling

struct PgoBranchProb
    function_name: str           # Containing function
    block_id: int                # Basic block identifier
    true_count: int              # Times the true branch was taken
    false_count: int             # Times the false branch was taken

struct PgoProfile
    function_counts: [PgoFunctionCount]  # Per-function execution counts
    function_count: int                  # Number of function entries
    branch_probs: [PgoBranchProb]        # Branch probability data
    branch_count: int                    # Number of branch entries
    total_executions: int                # Sum of all function counts
    profile_version: int                 # Profile format version
    is_loaded: int                       # 1 if profile data is loaded

# Create an empty PGO profile.
fn pgo_profile_new() -> PgoProfile
    return PgoProfile {
        function_counts: [],
        function_count: 0,
        branch_probs: [],
        branch_count: 0,
        total_executions: 0,
        profile_version: 1,
        is_loaded: 0
    }

# Add a function count to the profile (during profile collection).
fn pgo_profile_add_function(@self: PgoProfile, @name: str, @count: int)
    if @self.function_count >= PGO_MAX_FUNCTIONS
        return
    @entry = PgoFunctionCount { name: @name, count: @count }
    @self.function_counts = append(@self.function_counts, @entry)
    @self.function_count = @self.function_count + 1
    @self.total_executions = @self.total_executions + @count

# Add a branch probability entry.
fn pgo_profile_add_branch(@self: PgoProfile, @fn_name: str, @block_id: int, @true_count: int, @false_count: int)
    if @self.branch_count >= PGO_MAX_BRANCHES
        return
    @entry = PgoBranchProb {
        function_name: @fn_name,
        block_id: @block_id,
        true_count: @true_count,
        false_count: @false_count
    }
    @self.branch_probs = append(@self.branch_probs, @entry)
    @self.branch_count = @self.branch_count + 1

# Get the list of hot functions (top 10% by execution count).
# Returns: list of function names sorted by hotness
fn pgo_profile_hot_functions(@self: PgoProfile) -> [str]
    @result: [str] = []
    if @self.function_count == 0
        return @result
    @threshold = @self.total_executions / 10
    if @threshold < 1
        @threshold = 1
    orbit @i in 0..@self.function_count
        @entry = @self.function_counts[@i]
        if @entry.count >= @threshold
            @result = append(@result, @entry.name)
    return @result

# Get the list of cold functions (bottom 10% by execution count).
fn pgo_profile_cold_functions(@self: PgoProfile) -> [str]
    @result: [str] = []
    if @self.function_count == 0
        return @result
    @threshold = @self.total_executions / 100
    orbit @i in 0..@self.function_count
        @entry = @self.function_counts[@i]
        if @entry.count <= @threshold
            @result = append(@result, @entry.name)
    return @result

# Apply PGO metadata to a module.
# Sets function attributes (hot/cold) based on profile data.
# @module: the module to annotate
# @ctx: the LLVM context
fn pgo_profile_apply_to_module(@self: PgoProfile, @module: LLVMModuleRef, @ctx: LLVMContextRef)
    if @self.is_loaded == 0
        return

    # Apply hot function attributes
    @hot_fns = pgo_profile_hot_functions(@self)
    orbit @i in 0..len(@hot_fns)
        @fn_ref = unsafe { LLVMGetNamedFunction(@module, @hot_fns[@i]) }
        if @fn_ref != null
            @kind = unsafe { LLVMGetEnumAttributeKindForName("hot", 3) }
            @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
            unsafe { LLVMAddAttributeAtIndex(@fn_ref, 4294967295, @attr) }

    # Apply cold function attributes
    @cold_fns = pgo_profile_cold_functions(@self)
    orbit @i in 0..len(@cold_fns)
        @fn_ref = unsafe { LLVMGetNamedFunction(@module, @cold_fns[@i]) }
        if @fn_ref != null
            @kind = unsafe { LLVMGetEnumAttributeKindForName("cold", 4) }
            @attr = unsafe { LLVMCreateEnumAttribute(@ctx, @kind, 0) }
            unsafe { LLVMAddAttributeAtIndex(@fn_ref, 4294967295, @attr) }

# Run PGO-optimized passes on a module.
# Uses the PGO instrumentation/use pipeline in LLVM 18.
# @phase: "instrument" for first pass, "use" for optimized build
# Returns: 1 on success, 0 on failure
fn pgo_run_passes(@module: LLVMModuleRef, @tm: LLVMTargetMachineRef, @phase: str, @profile_file: str) -> int
    @pipeline_str = ""
    if @phase == "instrument"
        # Instrumentation pass: inserts counters
        @pipeline_str = "pgo-instr-gen,default<O2>"
    else
        # Use pass: uses profile data for optimization
        @pipeline_str = "pgo-instr-use,default<O2>"

    @options = unsafe { LLVMCreatePassBuilderOptions() }
    unsafe { LLVMPassBuilderOptionsSetLoopVectorization(@options, 1) }
    unsafe { LLVMPassBuilderOptionsSetSLPVectorization(@options, 1) }

    @err = unsafe { LLVMRunPasses(@module, @pipeline_str, @tm, @options) }
    unsafe { LLVMDisposePassBuilderOptions(@options) }

    if @err != null
        @msg = unsafe { LLVMGetErrorMessage(@err) }
        unsafe { LLVMDisposeErrorMessage(@msg) }
        unsafe { LLVMConsumeError(@err) }
        return 0
    return 1

# =============================================================================
# SECTION 10: CONVENIENCE - FULL COMPILATION PIPELINE
# =============================================================================
# End-to-end compilation from module to native object file.

# Initialize LLVM for the host platform and compile a module to an object file.
# This is the simplest way to use this module for AOT compilation.
#
# @module_name: name for the LLVM module
# @output_file: path for the output .o / .obj file
# @opt_level: optimization level (OPT_O0 through OPT_Oz)
# @callback: function that takes an LlvmContext and populates it with IR
#
# Returns: 1 on success, 0 on failure
fn llvm_compile_to_object(@module_name: str, @output_file: str, @opt_level: u32) -> LlvmContext
    # Detect host platform
    @triple = target_triple_host()
    @success = target_triple_init_target(@triple)
    if @success == 0
        return LlvmContext { context: null, module: null, builder: null, target_machine: null, target_data: null, module_name: "", is_disposed: 1 }

    # Detect CPU features
    @cpu = cpu_features_detect()

    # Create context
    @ctx = llvm_context_new(@module_name)

    # Map optimization level to LLVM codegen level
    @codegen_level = LLVMCodeGenLevelDefault
    match @opt_level
        phase OPT_O0 => @codegen_level = LLVMCodeGenLevelNone
        phase OPT_O1 => @codegen_level = LLVMCodeGenLevelLess
        phase OPT_O2 => @codegen_level = LLVMCodeGenLevelDefault
        phase OPT_O3 => @codegen_level = LLVMCodeGenLevelAggressive
        phase OPT_Os => @codegen_level = LLVMCodeGenLevelDefault
        phase OPT_Oz => @codegen_level = LLVMCodeGenLevelDefault
        _ => @codegen_level = LLVMCodeGenLevelDefault

    # Initialize target machine
    @triple_str = target_triple_to_string(@triple)
    @feat_str = @cpu.feature_string
    @init_ok = llvm_context_init_target(@ctx, @triple_str, @cpu.cpu_name, @feat_str, @codegen_level, LLVMRelocPIC, LLVMCodeModelDefault)
    if @init_ok == 0
        llvm_context_dispose(@ctx)
        return LlvmContext { context: null, module: null, builder: null, target_machine: null, target_data: null, module_name: "", is_disposed: 1 }

    return @ctx

# Finalize compilation: optimize and emit object file.
# Call this after populating the context with IR.
# Returns: 1 on success, 0 on failure
fn llvm_finalize_compilation(@ctx: LlvmContext, @output_file: str, @opt_level: u32) -> int
    # Verify module
    @valid = llvm_context_verify(@ctx)
    if @valid == 0
        return 0

    # Run optimization passes
    @opt_ok = opt_run_on_module(@ctx.module, @ctx.target_machine, @opt_level)
    if @opt_ok == 0
        return 0

    # Emit object file
    @mod = llvm_module_wrap(@ctx.module, @ctx.context)
    @emit_ok = llvm_module_emit_object(@mod, @output_file, @ctx.target_machine)
    return @emit_ok

# Create an MCJIT execution engine for a module (for JIT compilation).
# The module ownership is transferred to the engine.
# Returns: execution engine handle, or null on failure
fn llvm_create_jit(@module: LLVMModuleRef) -> LLVMExecutionEngineRef
    unsafe { LLVMLinkInMCJIT() }
    @ee: LLVMExecutionEngineRef = null
    @error: *u8 = null
    @result = unsafe { LLVMCreateMCJITCompilerForModule(&@ee, @module, null, 0, &@error) }
    if @result != 0
        if @error != null
            unsafe { LLVMDisposeMessage(@error) }
        return null
    return @ee

# Get a JIT-compiled function address by name.
# Returns: function pointer as u64 (0 if not found)
fn llvm_jit_get_function_address(@ee: LLVMExecutionEngineRef, @name: str) -> u64
    return unsafe { LLVMGetFunctionAddress(@ee, @name) }

# Dispose of a JIT execution engine.
fn llvm_jit_dispose(@ee: LLVMExecutionEngineRef)
    unsafe { LLVMDisposeExecutionEngine(@ee) }

# =============================================================================
# SECTION 12: LINKER DRIVER — v4.0
# =============================================================================
# Multi-platform linker invocation ported from native_compiler.rs try_link().
# Luna can now produce executables entirely through its own LLVM pipeline:
#   IR generation → optimization → object file emission → linking
#
# Supports 13 linker strategies across Windows, Linux, and macOS:
#   Windows: lld-link, clang, link.exe (MSVC), gcc (MinGW)
#   Linux:   gcc, clang, ld.lld, ld (GNU)
#   macOS:   clang, ld (ld64)
# =============================================================================

# --- Platform detection ---
const PLATFORM_UNKNOWN: int = 0
const PLATFORM_WINDOWS: int = 1
const PLATFORM_LINUX: int = 2
const PLATFORM_MACOS: int = 3

# --- Linker strategy ---
const MAX_LINKER_STRATEGIES: int = 8
const MAX_LINKER_ARGS: int = 32

struct LinkerStrategy
    name: str                   # Human-readable name (e.g. "lld-link")
    command: str                # Executable path or name
    args: [str; 32]             # Pre-built argument list
    arg_count: int
    is_active: int              # 1 if configured

struct LinkerResult
    success: int                # 1 on success
    strategy_used: str          # Name of linker that succeeded
    error: str                  # Error message if failed

# --- FFI for process execution ---
# These FFI functions must be provided by the Luna runtime (interpreter or JIT).
# luna_get_platform(): returns PLATFORM_* constant
# luna_exec_process(): runs a command, returns exit code (0 = success)
extern "C" fn luna_get_platform() -> int
extern "C" fn luna_exec_process(@cmd: str, @args: [str; 32], @arg_count: int) -> int
extern "C" fn luna_file_exists(@path: str) -> int

# Detect current platform
fn linker_detect_platform() -> int
    # Try FFI first
    @p = unsafe { luna_get_platform() }
    if @p > 0
        return @p
    # Fallback: assume Windows on Luna (primary dev platform)
    return PLATFORM_WINDOWS

# --- Windows linker strategies ---
# Priority: lld-link → clang → link.exe (MSVC) → gcc (MinGW)
fn linker_build_windows(@strategies: [LinkerStrategy; 8], @output: str, @objects: [str; 8], @obj_count: int) -> int
    @count = 0

    # Strategy 1: lld-link (LLVM linker)
    @strategies[@count].name = "lld-link"
    @strategies[@count].command = "lld-link"
    @strategies[@count].args[0] = "/OUT:" + @output
    @strategies[@count].args[1] = "/SUBSYSTEM:CONSOLE"
    @strategies[@count].args[2] = "/ENTRY:mainCRTStartup"
    @strategies[@count].args[3] = "/DEFAULTLIB:libcmt"
    @strategies[@count].args[4] = "/DEFAULTLIB:ucrt"
    @strategies[@count].args[5] = "/DEFAULTLIB:vcruntime"
    @strategies[@count].args[6] = "/OPT:REF"
    @strategies[@count].args[7] = "/OPT:ICF"
    @ac = 8
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 2: clang (LLVM driver)
    @strategies[@count].name = "clang"
    @strategies[@count].command = "clang"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-fuse-ld=lld"
    @strategies[@count].args[3] = "-Wl,-subsystem:console"
    @ac = 4
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 3: link.exe (MSVC)
    @strategies[@count].name = "link.exe (MSVC)"
    @strategies[@count].command = "link.exe"
    @strategies[@count].args[0] = "/OUT:" + @output
    @strategies[@count].args[1] = "/ENTRY:mainCRTStartup"
    @strategies[@count].args[2] = "/SUBSYSTEM:CONSOLE"
    @strategies[@count].args[3] = "/DEFAULTLIB:libcmt"
    @strategies[@count].args[4] = "/DEFAULTLIB:ucrt"
    @ac = 5
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 4: gcc (MinGW)
    @strategies[@count].name = "gcc (MinGW)"
    @strategies[@count].command = "gcc"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-Wl,-e,mainCRTStartup"
    @strategies[@count].args[3] = "--gc-sections"
    @ac = 4
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    return @count

# --- Linux linker strategies ---
# Priority: gcc → clang → ld.lld → ld (GNU)
fn linker_build_linux(@strategies: [LinkerStrategy; 8], @output: str, @objects: [str; 8], @obj_count: int) -> int
    @count = 0

    # Strategy 1: gcc
    @strategies[@count].name = "gcc"
    @strategies[@count].command = "gcc"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-static"
    @strategies[@count].args[3] = "-Wl,-e,_start"
    @strategies[@count].args[4] = "-Wl,--gc-sections"
    @strategies[@count].args[5] = "-lc"
    @ac = 6
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 2: clang
    @strategies[@count].name = "clang"
    @strategies[@count].command = "clang"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-static"
    @strategies[@count].args[3] = "-Wl,--gc-sections"
    @strategies[@count].args[4] = "-lc"
    @ac = 5
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 3: ld.lld (LLVM linker)
    @strategies[@count].name = "ld.lld"
    @strategies[@count].command = "ld.lld"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-e"
    @strategies[@count].args[3] = "_start"
    @strategies[@count].args[4] = "-static"
    @strategies[@count].args[5] = "--gc-sections"
    @strategies[@count].args[6] = "-lc"
    @strategies[@count].args[7] = "-L/usr/lib"
    @ac = 8
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 4: ld (GNU)
    @strategies[@count].name = "ld"
    @strategies[@count].command = "ld"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-e"
    @strategies[@count].args[3] = "_start"
    @strategies[@count].args[4] = "-static"
    @strategies[@count].args[5] = "--gc-sections"
    @strategies[@count].args[6] = "-lc"
    @ac = 7
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    return @count

# --- macOS linker strategies ---
# Priority: clang → ld (ld64)
fn linker_build_macos(@strategies: [LinkerStrategy; 8], @output: str, @objects: [str; 8], @obj_count: int) -> int
    @count = 0

    # Strategy 1: clang
    @strategies[@count].name = "clang"
    @strategies[@count].command = "clang"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-Wl,-e,_start"
    @strategies[@count].args[3] = "-Wl,-dead_strip"
    @strategies[@count].args[4] = "-lSystem"
    @ac = 5
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    # Strategy 2: ld (ld64)
    @strategies[@count].name = "ld (ld64)"
    @strategies[@count].command = "ld"
    @strategies[@count].args[0] = "-o"
    @strategies[@count].args[1] = @output
    @strategies[@count].args[2] = "-e"
    @strategies[@count].args[3] = "_start"
    @strategies[@count].args[4] = "-dead_strip"
    @strategies[@count].args[5] = "-lSystem"
    @ac = 6
    orbit @i in 0..@obj_count
        @strategies[@count].args[@ac] = @objects[@i]
        @ac = @ac + 1
    @strategies[@count].arg_count = @ac
    @strategies[@count].is_active = 1
    @count = @count + 1

    return @count

# --- Main linker entry point ---
# Try linking object files into an executable using platform-appropriate strategies.
# Iterates through strategies until one succeeds.
# Returns: LinkerResult
fn llvm_try_link(@objects: [str; 8], @obj_count: int, @output: str) -> LinkerResult
    @result = LinkerResult { success: 0, strategy_used: "", error: "" }
    @platform = linker_detect_platform()
    @strategies: [LinkerStrategy; 8] = [LinkerStrategy {
        name: "", command: "", args: [""; 32], arg_count: 0, is_active: 0
    }; 8]
    @strategy_count = 0

    phase @platform
        PLATFORM_WINDOWS =>
            @strategy_count = linker_build_windows(@strategies, @output, @objects, @obj_count)
        PLATFORM_LINUX =>
            @strategy_count = linker_build_linux(@strategies, @output, @objects, @obj_count)
        PLATFORM_MACOS =>
            @strategy_count = linker_build_macos(@strategies, @output, @objects, @obj_count)
        _ =>
            @result.error = "Unknown platform"
            return @result

    # Try each strategy in order
    orbit @i in 0..@strategy_count
        if @strategies[@i].is_active == 0
            continue
        @exit_code = unsafe { luna_exec_process(@strategies[@i].command,
                                                @strategies[@i].args,
                                                @strategies[@i].arg_count) }
        if @exit_code == 0
            @result.success = 1
            @result.strategy_used = @strategies[@i].name
            return @result

    @result.error = "All " + str(@strategy_count) + " linker strategies failed"
    return @result

# =============================================================================
# SECTION 13: COMPILATION PIPELINE — v4.0
# =============================================================================
# High-level orchestrator for the full compile → link pipeline.
# This is the Luna-native equivalent of native_compiler.rs compile flow.
# =============================================================================

struct CompilePipeline
    source_file: str            # Input .luna file
    output_file: str            # Output executable path
    opt_level: int              # 0-3 (O0, O1, O2, O3)
    emit_object_only: int       # 1 = stop at .o, don't link
    emit_llvm_ir: int           # 1 = dump IR to .ll file
    verbose: int                # 1 = print progress
    object_file: str            # Intermediate .o path

struct CompileResult
    success: int
    object_bytes: int           # Size of emitted object file
    link_strategy: str          # Linker that was used
    ir_dumped: int              # 1 if IR was dumped
    error: str

# Build an executable from LLVM module.
# Assumes the caller has already built LLVM IR into a module.
# This function handles: verify → optimize → emit .o → link
fn llvm_compile_and_link(@pipeline: CompilePipeline,
                         @module: LLVMModuleRef,
                         @machine: LLVMTargetMachineRef) -> CompileResult
    @result = CompileResult {
        success: 0, object_bytes: 0, link_strategy: "",
        ir_dumped: 0, error: ""
    }

    # Step 1: Verify module
    if @pipeline.verbose == 1
        shine("[llvm] Verifying module...")
    @verify_err: ptr = null
    @verify_ok = unsafe { LLVMVerifyModule(@module, 2, &@verify_err) }
    if @verify_ok != 0
        @result.error = "Module verification failed"
        if @verify_err != null
            unsafe { LLVMDisposeMessage(@verify_err) }
        return @result

    # Step 2: Run optimization pipeline
    if @pipeline.verbose == 1
        shine("[llvm] Optimizing at O" + str(@pipeline.opt_level) + "...")
    @pass_opts = unsafe { LLVMCreatePassBuilderOptions() }
    @opt_str = "default<O" + str(@pipeline.opt_level) + ">"
    @pass_err = unsafe { LLVMRunPasses(@module, @opt_str, @machine, @pass_opts) }
    unsafe { LLVMDisposePassBuilderOptions(@pass_opts) }

    # Step 3: Emit IR if requested
    if @pipeline.emit_llvm_ir == 1
        @ir_path = @pipeline.source_file + ".ll"
        @ir_err: ptr = null
        @ir_ok = unsafe { LLVMPrintModuleToFile(@module, @ir_path, &@ir_err) }
        if @ir_ok == 0
            @result.ir_dumped = 1
            if @pipeline.verbose == 1
                shine("[llvm] IR dumped to " + @ir_path)
        if @ir_err != null
            unsafe { LLVMDisposeMessage(@ir_err) }

    # Step 4: Emit object file
    @obj_path = @pipeline.object_file
    if @obj_path == ""
        @obj_path = @pipeline.output_file + ".o"
    if @pipeline.verbose == 1
        shine("[llvm] Emitting object file: " + @obj_path)
    @emit_err: ptr = null
    @emit_ok = unsafe { LLVMTargetMachineEmitToFile(@machine, @module, @obj_path, 1, &@emit_err) }
    if @emit_ok != 0
        @result.error = "Object file emission failed"
        if @emit_err != null
            unsafe { LLVMDisposeMessage(@emit_err) }
        return @result

    # Step 5: Link (unless emit_object_only)
    if @pipeline.emit_object_only == 1
        @result.success = 1
        if @pipeline.verbose == 1
            shine("[llvm] Object file emitted (no linking)")
        return @result

    if @pipeline.verbose == 1
        shine("[llvm] Linking: " + @pipeline.output_file)
    @objects: [str; 8] = [""; 8]
    @objects[0] = @obj_path
    @link_result = llvm_try_link(@objects, 1, @pipeline.output_file)
    if @link_result.success == 1
        @result.success = 1
        @result.link_strategy = @link_result.strategy_used
        if @pipeline.verbose == 1
            shine("[llvm] Linked with " + @link_result.strategy_used)
    else
        @result.error = "Linking failed: " + @link_result.error

    return @result

# Convenience: build executable from LLVM context
fn llvm_build_executable(@source: str, @output: str, @opt_level: int) -> CompileResult
    @pipeline = CompilePipeline {
        source_file: @source,
        output_file: @output,
        opt_level: @opt_level,
        emit_object_only: 0,
        emit_llvm_ir: 0,
        verbose: 1,
        object_file: ""
    }
    # Caller must create module + machine and pass to llvm_compile_and_link
    @result = CompileResult {
        success: 0, object_bytes: 0, link_strategy: "",
        ir_dumped: 0, error: "Module not provided — use llvm_compile_and_link()"
    }
    return @result

# --- Linker self-tests ---

fn test_linker_strategy_count()
    shine("  [test] Linker strategy counts...")
    @strategies: [LinkerStrategy; 8] = [LinkerStrategy {
        name: "", command: "", args: [""; 32], arg_count: 0, is_active: 0
    }; 8]
    @objects: [str; 8] = ["test.o", "", "", "", "", "", "", ""]
    @win = linker_build_windows(@strategies, "test.exe", @objects, 1)
    guard @win == 4 else
        shine("    FAIL: expected 4 Windows strategies, got " + str(@win))
        return
    @lin = linker_build_linux(@strategies, "test", @objects, 1)
    guard @lin == 4 else
        shine("    FAIL: expected 4 Linux strategies, got " + str(@lin))
        return
    @mac = linker_build_macos(@strategies, "test", @objects, 1)
    guard @mac == 2 else
        shine("    FAIL: expected 2 macOS strategies, got " + str(@mac))
        return
    shine("    PASS")

fn test_linker_args()
    shine("  [test] Linker argument construction...")
    @strategies: [LinkerStrategy; 8] = [LinkerStrategy {
        name: "", command: "", args: [""; 32], arg_count: 0, is_active: 0
    }; 8]
    @objects: [str; 8] = ["main.o", "utils.o", "", "", "", "", "", ""]
    @count = linker_build_windows(@strategies, "app.exe", @objects, 2)
    # Check first strategy (lld-link)
    guard @strategies[0].name == "lld-link" else
        shine("    FAIL: first strategy should be lld-link")
        return
    guard @strategies[0].command == "lld-link" else
        shine("    FAIL: command should be lld-link")
        return
    guard @strategies[0].args[0] == "/OUT:app.exe" else
        shine("    FAIL: first arg should be /OUT:app.exe")
        return
    # Object files should be appended after flags
    @has_main = 0
    @has_utils = 0
    orbit @i in 0..@strategies[0].arg_count
        if @strategies[0].args[@i] == "main.o"
            @has_main = 1
        if @strategies[0].args[@i] == "utils.o"
            @has_utils = 1
    guard @has_main == 1 and @has_utils == 1 else
        shine("    FAIL: object files not found in args")
        return
    shine("    PASS")

fn test_pipeline_struct()
    shine("  [test] Pipeline struct creation...")
    @pipeline = CompilePipeline {
        source_file: "test.luna",
        output_file: "test.exe",
        opt_level: 2,
        emit_object_only: 0,
        emit_llvm_ir: 0,
        verbose: 0,
        object_file: ""
    }
    guard @pipeline.opt_level == 2 else
        shine("    FAIL: opt level")
        return
    guard @pipeline.source_file == "test.luna" else
        shine("    FAIL: source file")
        return
    shine("    PASS")

# =============================================================================
# END OF LLVM API DRIVER — v4.0
# =============================================================================
# Total: 374+ FFI declarations, 10+ wrapper structs, complete optimization
# pipeline, LTO support, PGO support, CPU feature detection, IR types,
# multi-platform linker driver (13 strategies), and compilation orchestrator.
#
# This module is the foundation for Luna's self-hosting LLVM backend,
# enabling direct native code generation without any Rust intermediary.
# Luna v4.0 can compile and link executables entirely through this driver.
# =============================================================================
