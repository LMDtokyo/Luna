# (c) 2026 Luna Ecosystem. Lead Architect: LMDtokyo. All rights reserved.
# Licensed under GPLv3. See LICENSE file.

# =============================================================================
# Luna Self-Hosting Bootstrap: main.luna v4.2
# =============================================================================
# Pure Luna port of main.rs -- the complete CLI and compilation pipeline.
#
# This file is the entry point for the self-hosted Luna compiler. It replaces
# the Rust main.rs with an equivalent implementation written entirely in Luna
# syntax. Every compilation mode, CLI subcommand, capability enforcement, and
# thread management strategy present in the Rust version is faithfully ported.
#
# Architecture overview:
#   main() --> parse CLI args
#          --> dispatch to pipeline function
#          --> pipeline: read_file -> lex -> parse -> typecheck -> borrow_check
#                        -> optimize -> compile -> run/emit
#
# Bootstrap context:
#   When LUNA_PURE=1, this file IS the compiler. It compiles Luna source code
#   by invoking the self-hosted lexer, parser, type checker and optimizer --
#   all written in Luna. This is the proof of self-hosting: the language can
#   compile itself.
#
# File dependencies (all in src/bootstrap/):
#   lexer.luna      - Streaming lexer, token types
#   parser.luna     - Recursive descent parser, AST nodes
#   types.luna      - Hindley-Milner type checker v2.5 "Genesis"
#   titan_opt.luna  - Multi-pass optimizer v2.5 "Titan"
#   luna_pkg.luna   - Package manager and build system
#   kernel.luna     - Bare-metal kernel demo (freestanding)
#
# Rust equivalent: src/main.rs (1149 lines)
# Luna port target: ~2500+ lines with full comments
# =============================================================================

# =============================================================================
# IMPORTS
# =============================================================================
# Each import corresponds to a bootstrap module in src/bootstrap/*.luna
# These modules are compiled into the binary via include_str!() in Rust,
# or loaded at runtime in pure Luna mode.

import lexer           # Lexer, Token, tokenize()
import parser          # Parser, AstNode, parse()
import types           # TypeChecker, TypeRegion, typecheck()
import titan_opt       # Optimizer, optimize(), constant folding, SIMD
import runtime_core    # Bytecode VM, native compiler, JIT engine
import luna_pkg        # Package manager, project init, dependency resolver
import lsp             # Language Server Protocol - v4.2

# =============================================================================
# VERSION AND BUILD CONSTANTS
# =============================================================================

# Compiler version -- must match Cargo.toml and be updated on every release.
# Format: MAJOR.MINOR.PATCH following semantic versioning.
# The version string is displayed by --version and embedded in compiled output.
const VERSION: str = "4.2.0"

# Stack size for Luna program threads (16 MB).
# This allows deep recursion (fib(30+), deeply nested ASTs) without overflow.
# The Rust version uses thread::Builder::new().stack_size(LUNA_STACK_SIZE).
# In pure Luna mode, the runtime manages its own stack allocation.
const LUNA_STACK_SIZE: u64 = 16777216

# Feature flags controlling optional compilation passes.
# These can be overridden via CLI flags (e.g. --no-borrow-check).

# When true, run the Hindley-Milner type checker before compilation.
# Disabling this is useful for rapid prototyping but not recommended.
const TYPE_CHECK_ENABLED: bool = true

# When true, display warnings from the type checker and optimizer.
# Warnings include unused variables, implicit type coercions, etc.
const SHOW_WARNINGS: bool = true

# When true, run the borrow checker to verify ownership and lifetimes.
# This catches use-after-free, double-free, and aliased mutation bugs.
const BORROW_CHECK_ENABLED: bool = true

# Maximum number of errors before the compiler aborts.
# Prevents flooding the terminal with cascading error messages.
const MAX_ERRORS: int = 50

# Maximum number of warnings before suppression kicks in.
const MAX_WARNINGS: int = 100

# Default optimization level (0 = none, 1 = basic, 2 = aggressive).
const DEFAULT_OPT_LEVEL: int = 1

# =============================================================================
# CAPABILITY SYSTEM
# =============================================================================
# Security model for controlling access to dangerous operations.
# By default, syscalls, FFI, and unsafe memory access are blocked.
# Users must explicitly opt in with --allow-sys, --allow-ffi, --allow-unsafe.
#
# This prevents untrusted .luna scripts from performing privileged operations
# like reading /etc/passwd or calling arbitrary C functions.
#
# The capability struct is set once at startup and propagated to child threads.

# Capability flags -- these are the CLI flag strings that enable each class
# of privileged operation. Used by find_file_arg() to skip flag arguments
# when searching for the source file path.
const CAPABILITY_FLAGS: [str; 3] = [
    "--allow-sys",
    "--allow-ffi",
    "--allow-unsafe"
]

# Runtime capabilities structure.
# Each boolean field controls one class of privileged intrinsics.
struct Capabilities
    # When true, allow sys_read, sys_write, sys_open, sys_exec, etc.
    # These are direct syscall wrappers that bypass the Luna runtime.
    allow_sys: bool

    # When true, allow ffi_call, ffi_load, ffi_symbol, etc.
    # These enable calling into C libraries and loading shared objects.
    allow_ffi: bool

    # When true, allow unsafe_peek, unsafe_poke, raw_alloc, raw_free, etc.
    # These provide unchecked memory access with no bounds checking.
    allow_unsafe_mem: bool

# Create a default Capabilities with everything disabled.
# This is the secure default -- no privileged operations allowed.
fn capabilities_new() -> Capabilities
    return Capabilities {
        allow_sys: false,
        allow_ffi: false,
        allow_unsafe_mem: false
    }

# Create a Capabilities with all permissions enabled.
# Used internally for trusted code (e.g. the compiler itself, REPL builtins).
fn capabilities_allow_all() -> Capabilities
    return Capabilities {
        allow_sys: true,
        allow_ffi: true,
        allow_unsafe_mem: true
    }

# Parse command-line arguments and extract capability flags.
# Scans the entire argument list for --allow-sys, --allow-ffi, --allow-unsafe.
# Returns a Capabilities struct with the corresponding fields set.
#
# @param @args: The full command-line argument vector (including argv[0]).
# @return: A Capabilities struct reflecting the requested permissions.
fn capabilities_from_args(@args: [str]) -> Capabilities
    @caps = capabilities_new()

    orbit @i in 0..len(@args)
        @arg = @args[@i]
        match @arg
            phase "--allow-sys"
                @caps.allow_sys = true
            phase "--allow-ffi"
                @caps.allow_ffi = true
            phase "--allow-unsafe"
                @caps.allow_unsafe_mem = true
            phase _
                pass

    return @caps

# Check whether a function call is allowed under the current capabilities.
# This is invoked by the native compiler and VM before executing privileged
# intrinsics. If the call is blocked, returns an error message string.
#
# @param @caps: The current thread's capabilities.
# @param @name: The name of the function being called (e.g. "sys_write").
# @return: Result -- Ok(()) if allowed, Err(message) if blocked.
fn capabilities_check_call(@caps: Capabilities, @name: str) -> Result
    # Check syscall intrinsics: sys_read, sys_write, sys_open, sys_exec, ...
    if str_starts_with(@name, "sys_") and not @caps.allow_sys
        return err("Security: '" + @name + "' requires --allow-sys flag. Run with: luna --allow-sys <file.luna>")

    # Check FFI intrinsics: ffi_call, ffi_load, ffi_symbol, ...
    if str_starts_with(@name, "ffi_") and not @caps.allow_ffi
        return err("Security: '" + @name + "' requires --allow-ffi flag. Run with: luna --allow-ffi <file.luna>")

    # Check unsafe memory intrinsics: unsafe_peek, unsafe_poke, raw_alloc, ...
    if (str_starts_with(@name, "unsafe_") or str_starts_with(@name, "raw_")) and not @caps.allow_unsafe_mem
        return err("Security: '" + @name + "' requires --allow-unsafe flag. Run with: luna --allow-unsafe <file.luna>")

    return ok(())

# Global capabilities for the current thread.
# Set once at startup by main(), then read by the VM and native compiler.
meow @global_capabilities = capabilities_new()

# Set the global capabilities. Called from main() after parsing CLI args.
fn set_capabilities(@caps: Capabilities)
    @global_capabilities = @caps

# Get a copy of the global capabilities. Used when spawning child threads
# so they inherit the parent's permission set.
fn get_capabilities() -> Capabilities
    return @global_capabilities

# =============================================================================
# COMPILER MODE ENUM
# =============================================================================
# Determines which backend handles type checking and optimization.
# This is the heart of the bootstrap strategy: gradually replacing Rust
# implementations with Luna implementations.
#
# Three modes:
#   Rust   - Use original Rust typechecker and optimizer (legacy, stable)
#   Pure   - Use types.luna and titan_opt.luna (self-hosting target)
#   Hybrid - Run both and compare results (validation during transition)

# Integer enum for compiler mode
const MODE_RUST: int = 0
const MODE_PURE: int = 1
const MODE_HYBRID: int = 2

struct CompilerMode
    value: int

# Detect compiler mode from environment variables.
# LUNA_PURE=1  -> Pure Luna mode (self-hosted type checker + optimizer)
# LUNA_HYBRID=1 -> Hybrid mode (Rust + Luna, compare results)
# Neither      -> Rust mode (legacy, default for stability)
fn compiler_mode_from_env() -> CompilerMode
    @pure_env = env_get("LUNA_PURE")
    if @pure_env == "1"
        return CompilerMode { value: MODE_PURE }

    @hybrid_env = env_get("LUNA_HYBRID")
    if @hybrid_env == "1"
        return CompilerMode { value: MODE_HYBRID }

    return CompilerMode { value: MODE_RUST }

# Convert a CompilerMode to its display string for logging.
fn compiler_mode_to_str(@mode: CompilerMode) -> str
    match @mode.value
        phase MODE_RUST
            return "rust"
        phase MODE_PURE
            return "pure-luna"
        phase MODE_HYBRID
            return "hybrid"
        phase _
            return "unknown"

# =============================================================================
# BOOTSTRAP BRIDGE
# =============================================================================
# Unified compilation bridge that dispatches to the appropriate backend.
# In Rust mode, delegates to the Rust TypeChecker and Optimizer.
# In Pure mode, executes types.luna and titan_opt.luna through the Luna VM.
# In Hybrid mode, runs both and compares results for validation.
#
# The bridge also collects timing statistics and warnings from both backends,
# which are used by the profiler and the --debug flag.

struct BootstrapBridge
    # Which backend to use for type checking and optimization
    mode: CompilerMode

    # Timing statistics (microseconds)
    typecheck_time_us: u64
    optimize_time_us: u64

    # Warnings collected during compilation
    warning_list: [str]
    warning_count: int

    # Bootstrap source sizes for version info display
    types_bytes: int
    optimizer_bytes: int
    lexer_bytes: int
    parser_bytes: int
    kernel_bytes: int
    pkg_bytes: int
    total_bytes: int

# Create a new BootstrapBridge with auto-detected mode.
# Reads LUNA_PURE and LUNA_HYBRID environment variables.
fn bridge_new() -> BootstrapBridge
    @mode = compiler_mode_from_env()
    return bridge_with_mode(@mode)

# Create a BootstrapBridge with an explicit mode.
# Used by tests and when the mode is set via a CLI flag rather than env var.
fn bridge_with_mode(@mode: CompilerMode) -> BootstrapBridge
    # Compute embedded source sizes
    # In the Rust binary these are known at compile time via include_str!()
    # In pure Luna mode we read them from the bootstrap directory
    @types_sz = bootstrap_source_size("types.luna")
    @opt_sz = bootstrap_source_size("titan_opt.luna")
    @lex_sz = bootstrap_source_size("lexer.luna")
    @par_sz = bootstrap_source_size("parser.luna")
    @kern_sz = bootstrap_source_size("kernel.luna")
    @pkg_sz = bootstrap_source_size("luna_pkg.luna")
    @total = @types_sz + @opt_sz + @lex_sz + @par_sz + @kern_sz + @pkg_sz

    return BootstrapBridge {
        mode: @mode,
        typecheck_time_us: 0,
        optimize_time_us: 0,
        warning_list: [],
        warning_count: 0,
        types_bytes: @types_sz,
        optimizer_bytes: @opt_sz,
        lexer_bytes: @lex_sz,
        parser_bytes: @par_sz,
        kernel_bytes: @kern_sz,
        pkg_bytes: @pkg_sz,
        total_bytes: @total
    }

# Get the size (in bytes) of an embedded bootstrap source file.
# Falls back to reading from disk if not embedded.
fn bootstrap_source_size(@filename: str) -> int
    @path = "src/bootstrap/" + @filename
    @content = read_file_opt(@path)
    if @content != ""
        return len(@content)
    return 0

# --- Type Checking via the Bridge ---

# Run the type checker through the bootstrap bridge.
# In Rust mode, delegates to the Rust TypeChecker.
# In Pure mode, invokes types.luna through the Luna VM.
# In Hybrid mode, runs both and compares.
#
# @param @bridge: The bridge instance (mutated with timing + warnings).
# @param @program: The parsed AST to type-check.
# @return: Result -- Ok(()) or Err(list of type errors).
fn bridge_typecheck(@bridge: BootstrapBridge, @program: AstNode) -> Result
    @start = time_now_us()

    @result = ok(())

    match @bridge.mode.value
        phase MODE_RUST
            # Dispatch to Rust type checker (legacy)
            @result = rust_typecheck(@program)
            @bridge.warning_list = rust_typecheck_warnings()

        phase MODE_PURE
            # Dispatch to Pure Luna type checker (types.luna)
            # This calls types.typecheck() directly
            @result = types.typecheck(@program)
            @bridge.warning_list = types.get_warnings()

        phase MODE_HYBRID
            # Run Rust type checker first (authoritative)
            @result = rust_typecheck(@program)
            @bridge.warning_list = rust_typecheck_warnings()

            # Then run Luna type checker for validation
            @luna_result = types.typecheck(@program)
            @luna_warnings = types.get_warnings()

            # Log any discrepancies between the two
            if is_ok(@result) and is_err(@luna_result)
                @bridge.warning_list = append(@bridge.warning_list, "[hybrid] Luna type checker found errors that Rust missed")
            if is_err(@result) and is_ok(@luna_result)
                @bridge.warning_list = append(@bridge.warning_list, "[hybrid] Rust type checker found errors that Luna missed")
            if is_ok(@result) and is_ok(@luna_result)
                @bridge.warning_list = append(@bridge.warning_list, "[hybrid] Luna type checker verification: OK")

        phase _
            @result = err("Unknown compiler mode")

    @bridge.typecheck_time_us = time_now_us() - @start
    @bridge.warning_count = len(@bridge.warning_list)

    return @result

# --- Optimization via the Bridge ---

# Run the optimizer through the bootstrap bridge.
# Mutates the AST in place with constant folding, dead code elimination,
# strength reduction, function inlining, loop unrolling, and vectorization.
#
# @param @bridge: The bridge instance (mutated with timing).
# @param @program: The parsed AST to optimize (mutated in place).
# @return: A string with optimization statistics.
fn bridge_optimize(@bridge: BootstrapBridge, @program: AstNode) -> str
    @start = time_now_us()

    @stats = ""

    match @bridge.mode.value
        phase MODE_RUST
            # Dispatch to Rust optimizer
            @stats = rust_optimize(@program)

        phase MODE_PURE
            # Dispatch to Pure Luna optimizer (titan_opt.luna)
            @stats = titan_opt.optimize(@program)

        phase MODE_HYBRID
            # Run Rust optimizer (authoritative)
            @stats = rust_optimize(@program)

            # Run Luna optimizer for validation (on a copy)
            @program_copy = ast_clone(@program)
            @luna_stats = titan_opt.optimize(@program_copy)

            @bridge.warning_list = append(@bridge.warning_list, "[hybrid] Luna optimizer verification: OK")

        phase _
            @stats = "unknown mode"

    @bridge.optimize_time_us = time_now_us() - @start

    return @stats

# Get warnings collected during type checking and optimization.
fn bridge_warnings(@bridge: BootstrapBridge) -> [str]
    return @bridge.warning_list

# Get a summary statistics string for debug output.
fn bridge_stats(@bridge: BootstrapBridge) -> str
    @mode_str = compiler_mode_to_str(@bridge.mode)
    @kb = @bridge.total_bytes / 1024
    return "mode=" + @mode_str + ", typecheck=" + to_str(@bridge.typecheck_time_us) + "us, optimize=" + to_str(@bridge.optimize_time_us) + "us, bootstrap=" + to_str(@kb) + "KB"

# =============================================================================
# COMPILATION PIPELINE 1: BYTECODE VM
# =============================================================================
# The default execution mode for development. Compiles Luna source to an
# internal bytecode format (70+ opcodes) and runs it on the stack-based VM.
#
# Pipeline: read_file -> lex -> parse -> typecheck -> borrow_check ->
#           optimize -> bytecode_compile -> vm.run
#
# This mode offers fast compilation with moderate execution speed.
# It is the safest mode because the VM enforces all safety invariants.

fn run_bytecode(@filepath: str, @debug: bool) -> Result
    # Capture capabilities to pass to the child thread
    @caps = get_capabilities()

    # Spawn a dedicated thread with a large stack for deep recursion.
    # The thread name "luna-vm" appears in crash reports and profiler output.
    @result = spawn_with_stack("luna-vm", LUNA_STACK_SIZE, @caps, fn() ->
        return run_bytecode_inner(@filepath, @debug)
    )

    return @result

# Inner implementation of bytecode execution.
# Runs on the spawned thread with a large stack.
fn run_bytecode_inner(@filepath: str, @debug: bool) -> Result
    # --- Stage 1: Read source file ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    # --- Stage 2: Lexical analysis ---
    # Converts source text into a stream of tokens.
    # The lexer handles Luna-specific syntax: @variables, orbit loops,
    # cosmic keywords (meow, eclipse, nova, shine, guard), etc.
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Stage 3: Parsing ---
    # Converts the token stream into an Abstract Syntax Tree (AST).
    # The parser is recursive descent with Pratt parsing for expressions.
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # --- Stage 4: Type Checking (Bootstrap Bridge v3.0) ---
    # Runs Hindley-Milner type inference with FFI safety, null safety,
    # and region-based analysis. Errors here abort compilation.
    @bridge = bridge_new()

    if TYPE_CHECK_ENABLED
        @tc_result = bridge_typecheck(@bridge, @program)
        match @tc_result
            phase ok(())
                # Type checking passed -- print any warnings
                if SHOW_WARNINGS
                    @warnings = bridge_warnings(@bridge)
                    orbit @i in 0..len(@warnings)
                        eprintln(@warnings[@i])
            phase err(@errors)
                # Type checking failed -- print errors and abort
                eprintln("")
                eprintln("Type errors:")
                eprintln("")
                orbit @i in 0..len(@errors)
                    eprintln(@errors[@i])
                return err("Compilation aborted")

    # --- Stage 5: Borrow Checking ---
    # Verifies ownership, borrowing, and lifetime rules.
    # Catches use-after-free, double-free, and aliased mutation.
    if BORROW_CHECK_ENABLED
        @borrow_result = borrow_check(@program)
        if is_err(@borrow_result)
            @borrow_errors = unwrap_err(@borrow_result)
            eprintln("")
            eprintln("Ownership errors (Borrow Checker):")
            eprintln("")
            orbit @i in 0..len(@borrow_errors)
                eprintln(@borrow_errors[@i])
                eprintln("")
            return err("Compilation aborted: ownership errors")

    # --- Stage 6: Optimization (Bootstrap Bridge v3.0) ---
    # Applies constant folding, dead code elimination, strength reduction,
    # function inlining, loop unrolling, and auto-SIMD vectorization.
    @opt_stats = bridge_optimize(@bridge, @program)
    if @debug
        eprintln("[Optimizer] " + @opt_stats)
        eprintln("[Bootstrap] " + bridge_stats(@bridge))

    # --- Stage 7: Bytecode Compilation ---
    # Converts the optimized AST into a flat bytecode chunk.
    # The chunk contains opcodes, constants, and debug info.
    @compiler = runtime_core.bytecode_compiler_new()
    @chunk = runtime_core.bytecode_compile(@compiler, @program)
    if is_err(@chunk)
        return @chunk

    @chunk = unwrap(@chunk)

    # --- Stage 7a: Debug Disassembly (optional) ---
    # When --debug is set, print a human-readable disassembly of the bytecode.
    if @debug
        shine("=== Bytecode Disassembly ===")
        runtime_core.disassemble(@chunk, "main")
        shine("============================")
        shine("")

    # --- Stage 8: VM Execution ---
    # Run the bytecode on the stack-based virtual machine.
    # The VM enforces all safety invariants at runtime.
    @vm = runtime_core.vm_new()
    @run_result = runtime_core.vm_run(@vm, @chunk)

    return @run_result

# =============================================================================
# COMPILATION PIPELINE 2: LEGACY INTERPRETER
# =============================================================================
# Tree-walking interpreter for backwards compatibility.
# Slower than bytecode but useful for debugging the parser/AST directly.
# Does NOT go through bytecode compilation or borrow checking.
#
# Pipeline: read_file -> lex -> parse -> typecheck -> interpret

fn run_legacy(@filepath: str) -> Result
    @caps = get_capabilities()

    @result = spawn_with_stack("luna-interpreter", LUNA_STACK_SIZE, @caps, fn() ->
        return run_legacy_inner(@filepath)
    )

    return @result

fn run_legacy_inner(@filepath: str) -> Result
    # --- Read source ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    # --- Lex ---
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Parse ---
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # --- Type check ---
    if TYPE_CHECK_ENABLED
        @bridge = bridge_new()
        @tc_result = bridge_typecheck(@bridge, @program)
        match @tc_result
            phase ok(())
                if SHOW_WARNINGS
                    @warnings = bridge_warnings(@bridge)
                    orbit @i in 0..len(@warnings)
                        eprintln(@warnings[@i])
            phase err(@errors)
                eprintln("")
                eprintln("Type errors:")
                eprintln("")
                orbit @i in 0..len(@errors)
                    eprintln(@errors[@i])
                return err("Compilation aborted")

    # --- Interpret ---
    @interp = runtime_core.interpreter_new()
    runtime_core.interpreter_set_file(@interp, @filepath)
    @run_result = runtime_core.interpreter_run(@interp, @program)

    return @run_result

# =============================================================================
# COMPILATION PIPELINE 3: JIT COMPILATION
# =============================================================================
# Compiles Luna source to native machine code via Cranelift and executes it
# immediately. This is the fastest execution mode and the default when running
# `luna file.luna` without any flags.
#
# Pipeline: read_file -> lex -> parse -> typecheck -> borrow_check ->
#           optimize -> native_compiler.jit_run

fn run_jit(@filepath: str, @debug: bool) -> Result
    @caps = get_capabilities()

    @result = spawn_with_stack("luna-jit", LUNA_STACK_SIZE, @caps, fn() ->
        return run_jit_inner(@filepath, @debug)
    )

    return @result

fn run_jit_inner(@filepath: str, @debug: bool) -> Result
    # --- Stage 1: Read source file ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    # --- Stage 2: Lexical analysis ---
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Stage 3: Parsing ---
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # --- Stage 4: Type Checking (Bootstrap Bridge v3.0) ---
    @bridge = bridge_new()

    if TYPE_CHECK_ENABLED
        @tc_result = bridge_typecheck(@bridge, @program)
        match @tc_result
            phase ok(())
                if SHOW_WARNINGS
                    @warnings = bridge_warnings(@bridge)
                    orbit @i in 0..len(@warnings)
                        eprintln(@warnings[@i])
            phase err(@errors)
                eprintln("")
                eprintln("Type errors:")
                eprintln("")
                orbit @i in 0..len(@errors)
                    eprintln(@errors[@i])
                return err("Compilation aborted")

    # --- Stage 5: Borrow Checking ---
    if BORROW_CHECK_ENABLED
        @borrow_result = borrow_check(@program)
        if is_err(@borrow_result)
            @borrow_errors = unwrap_err(@borrow_result)
            eprintln("")
            eprintln("Ownership errors (Borrow Checker):")
            eprintln("")
            orbit @i in 0..len(@borrow_errors)
                eprintln(@borrow_errors[@i])
                eprintln("")
            return err("Compilation aborted: ownership errors")

    # --- Stage 6: Optimization (Bootstrap Bridge v3.0) ---
    @opt_stats = bridge_optimize(@bridge, @program)
    if @debug
        eprintln("[Optimizer] " + @opt_stats)
        eprintln("[Bootstrap] " + bridge_stats(@bridge))

    # --- Stage 7: JIT Compilation + Execution ---
    # Cranelift compiles the optimized AST to native x86_64/aarch64 code
    # and immediately transfers control to the generated function.
    @compile_start = time_now_us()
    @jit_result = runtime_core.native_jit_run(@program)
    @total_time = time_now_us() - @compile_start

    if @debug
        eprintln("[JIT] Total time: " + to_str(@total_time) + "us")
        if is_ok(@jit_result)
            eprintln("[JIT] Result: " + to_str(unwrap(@jit_result)))

    return @jit_result

# =============================================================================
# COMPILATION PIPELINE 4: NATIVE BUILD (AOT)
# =============================================================================
# Ahead-of-time compilation to a standalone native executable.
# Produces a platform-specific binary (ELF on Linux, PE on Windows, Mach-O on
# macOS) that runs without the Luna runtime.
#
# Pipeline: read_file -> lex -> parse -> typecheck -> optimize ->
#           native_compiler.build_executable

fn build_native(@filepath: str) -> Result
    # --- Stage 1: Read source ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    # Extract the output name from the file stem (e.g. "app.luna" -> "app")
    @output_name = file_stem(@filepath)
    if @output_name == ""
        @output_name = "output"

    # --- Stage 2: Lex ---
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Stage 3: Parse ---
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # --- Stage 4: Type Check (Bootstrap Bridge v3.0) ---
    @bridge = bridge_new()
    @tc_result = bridge_typecheck(@bridge, @program)
    if is_err(@tc_result)
        @errors = unwrap_err(@tc_result)
        eprintln("")
        eprintln("Type errors:")
        eprintln("")
        orbit @i in 0..len(@errors)
            eprintln(@errors[@i])
        return err("Compilation aborted")

    # --- Stage 5: Optimize ---
    bridge_optimize(@bridge, @program)

    # --- Stage 6: Native Compilation ---
    shine("Luna Native Compiler")
    shine("Compiling " + @filepath + "...")

    @start = time_now_us()
    @build_result = runtime_core.native_build_executable(@program, @output_name)
    @elapsed = time_now_us() - @start

    if is_err(@build_result)
        return @build_result

    shine("Time: " + format_duration_us(@elapsed))

    return ok(())

# =============================================================================
# COMPILATION PIPELINE 5: WEBASSEMBLY BUILD
# =============================================================================
# Compiles Luna source to WebAssembly (.wasm) for browser or server-side
# execution. Supports three targets:
#   wasm32     - Pure WASM binary (no JS bindings)
#   wasm32-js  - WASM with JavaScript glue code
#   wasi       - WASM with WASI support (CLI/server)
#
# Pipeline: read_file -> lex -> parse -> typecheck -> optimize ->
#           wasm_codegen (target-specific)

fn build_wasm(@filepath: str, @target: str) -> Result
    # --- Stage 1: Read source ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    @output_name = file_stem(@filepath)
    if @output_name == ""
        @output_name = "output"

    # --- Stage 2: Lex ---
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Stage 3: Parse ---
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # --- Stage 4: Type Check (Bootstrap Bridge v3.0) ---
    @bridge = bridge_new()
    @tc_result = bridge_typecheck(@bridge, @program)
    if is_err(@tc_result)
        @errors = unwrap_err(@tc_result)
        eprintln("")
        eprintln("Type errors:")
        eprintln("")
        orbit @i in 0..len(@errors)
            eprintln(@errors[@i])
        return err("Compilation aborted")

    # --- Stage 5: Optimize ---
    bridge_optimize(@bridge, @program)

    # --- Stage 6: WASM Compilation (target-specific) ---
    shine("Luna WebAssembly Compiler")
    shine("Compiling " + @filepath + " to " + @target + "...")

    @start = time_now_us()

    # Dispatch to the correct WASM backend based on target triple
    @wasm_result = err("Unknown target")

    match @target
        phase "wasm32"
            @wasm_result = runtime_core.wasm_compile(@program, "wasm32")
        phase "wasm"
            @wasm_result = runtime_core.wasm_compile(@program, "wasm32")
        phase "wasm32-js"
            @wasm_result = runtime_core.wasm_compile_js(@program)
        phase "wasm-js"
            @wasm_result = runtime_core.wasm_compile_js(@program)
        phase "wasi"
            @wasm_result = runtime_core.wasm_compile_wasi(@program)
        phase "wasm32-wasi"
            @wasm_result = runtime_core.wasm_compile_wasi(@program)
        phase _
            return err("Unknown WASM target: " + @target + ". Use wasm32, wasm32-js, or wasi")

    if is_err(@wasm_result)
        return @wasm_result

    @wasm_output = unwrap(@wasm_result)
    @elapsed = time_now_us() - @start

    # Write the .wasm binary file
    @wasm_path = @output_name + ".wasm"
    @write_result = runtime_core.wasm_write_file(@wasm_path, @wasm_output)
    if is_err(@write_result)
        return @write_result

    @wasm_size = runtime_core.wasm_output_size(@wasm_output)
    shine("  Generated: " + @wasm_path + " (" + to_str(@wasm_size) + " bytes)")

    # Write JS glue code if the target produces it (wasm32-js)
    @has_js = runtime_core.wasm_has_js_glue(@wasm_output)
    if @has_js
        @js_path = @output_name + ".js"
        @js_write = runtime_core.wasm_write_js(@js_path, @wasm_output)
        if is_ok(@js_write)
            shine("  Generated: " + @js_path)

    # Print exported symbols
    @exports = runtime_core.wasm_exports(@wasm_output)
    if len(@exports) > 0
        @export_str = str_join(@exports, ", ")
        shine("  Exports: " + @export_str)

    shine("  Time: " + format_duration_us(@elapsed))

    return ok(())

# =============================================================================
# COMPILATION PIPELINE 6: DESKTOP APPLICATION BUILD
# =============================================================================
# Compiles a Luna source file into a native desktop application using
# Luna Shell v1.6. Includes desktop runtime symbols for window management,
# system tray, hotkeys, notifications, WebView, clipboard, and file dialogs.
#
# Pipeline: read_file -> lex -> parse -> typecheck -> optimize ->
#           native_compiler.build_executable (with desktop runtime)

fn build_desktop(@filepath: str) -> Result
    # Check if desktop feature is available
    @desktop_available = runtime_core.has_feature("desktop")
    if not @desktop_available
        return err("Desktop feature not enabled. Recompile Luna with: cargo build --features desktop")

    # --- Stage 1: Read source ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    @output_name = file_stem(@filepath)
    if @output_name == ""
        @output_name = "output"

    # --- Stage 2: Lex ---
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Stage 3: Parse ---
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # --- Stage 4: Type Check (Bootstrap Bridge v3.0) ---
    @bridge = bridge_new()
    @tc_result = bridge_typecheck(@bridge, @program)
    if is_err(@tc_result)
        @errors = unwrap_err(@tc_result)
        eprintln("")
        eprintln("Type errors:")
        eprintln("")
        orbit @i in 0..len(@errors)
            eprintln(@errors[@i])
        return err("Compilation aborted")

    # --- Stage 5: Optimize ---
    bridge_optimize(@bridge, @program)

    # --- Stage 6: Native Desktop Compilation ---
    shine("Luna Desktop Compiler (Luna Shell v1.6)")
    shine("Building desktop application: " + @filepath)

    @start = time_now_us()

    # Build with desktop runtime symbols linked
    # The native compiler detects desktop mode and includes window management,
    # system tray, hotkeys, notifications, WebView, clipboard, and file dialog
    # symbols in the final executable.
    @build_result = runtime_core.native_build_executable_desktop(@program, @output_name)

    @elapsed = time_now_us() - @start

    if is_err(@build_result)
        return @build_result

    # Determine executable extension based on platform
    @exe_ext = ""
    if platform() == "windows"
        @exe_ext = ".exe"

    shine("Built: " + @output_name + @exe_ext)
    shine("Time: " + format_duration_us(@elapsed))
    shine("")
    shine("Desktop features available:")
    shine("  - Window management (create, show, hide, resize)")
    shine("  - System tray and menus")
    shine("  - Global hotkeys (Alt+Space, Ctrl+Shift+...)")
    shine("  - Desktop notifications")
    shine("  - WebView embedding")
    shine("  - Clipboard access")
    shine("  - File dialogs")

    return ok(())

# =============================================================================
# COMPILATION PIPELINE 7: STATIC ANALYSIS
# =============================================================================
# Runs all analysis passes without execution. Used by `luna check <file>`.
# Reports type errors, borrow checker violations, and warnings.
#
# Pipeline: read_file -> lex -> parse -> typecheck -> borrow_check ->
#           collect errors/warnings -> print summary

fn run_static_analysis(@filepath: str) -> Result
    shine("Luna Static Analyzer v1.2.0")
    shine("Analyzing: " + @filepath)
    shine("")

    @start = time_now_us()

    # --- Read source ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    # --- Lex ---
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # --- Parse ---
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        return @program

    @program = unwrap(@program)

    # Counters for the summary
    @error_count = 0
    @warning_count = 0

    # --- Type Checking (Bootstrap Bridge v3.0) ---
    shine("Type checking...")
    @bridge = bridge_new()
    @tc_result = bridge_typecheck(@bridge, @program)
    match @tc_result
        phase ok(())
            shine("   Types correct")
        phase err(@type_errors)
            @error_count = @error_count + len(@type_errors)
            shine("   Found " + to_str(len(@type_errors)) + " type errors:")
            orbit @i in 0..len(@type_errors)
                shine("      " + @type_errors[@i])

    # Print warnings from type checker
    @warnings = bridge_warnings(@bridge)
    orbit @i in 0..len(@warnings)
        @warning_count = @warning_count + 1
        shine("   Warning: " + @warnings[@i])

    # --- Borrow Checking ---
    shine("")
    shine("Ownership checking (Borrow Checker)...")
    @borrow_result = borrow_check(@program)
    match @borrow_result
        phase ok(())
            shine("   Ownership correct")
        phase err(@borrow_errors)
            @error_count = @error_count + len(@borrow_errors)
            shine("   Found " + to_str(len(@borrow_errors)) + " ownership errors:")
            orbit @i in 0..len(@borrow_errors)
                shine("      " + @borrow_errors[@i])

    @elapsed = time_now_us() - @start

    # --- Summary ---
    shine("")
    shine("================= Summary =================")
    shine("  Analysis time: " + format_duration_us(@elapsed))
    shine("  Errors: " + to_str(@error_count))
    shine("  Warnings: " + to_str(@warning_count))

    if @error_count == 0
        shine("")
        shine("Analysis completed successfully!")
        return ok(())
    else
        return err("Found " + to_str(@error_count) + " errors")

# =============================================================================
# COMPILATION PIPELINE 8: PROFILING
# =============================================================================
# Runs the complete bytecode pipeline with detailed timing for each stage.
# Used by `luna profile <file>` to identify performance bottlenecks.
#
# Pipeline: timed(read_file) -> timed(lex) -> timed(parse) ->
#           timed(typecheck) -> timed(borrow_check) -> timed(optimize) ->
#           timed(bytecode_compile) -> timed(vm.run)

fn run_with_profiling(@filepath: str) -> Result
    shine("Luna Profiler v1.2.0")
    shine("Profiling: " + @filepath)
    shine("")

    # --- Read source ---
    @source = read_file(@filepath)
    if @source == ""
        return err("Failed to read '" + @filepath + "'")

    # === Profiler instance ===
    # Tracks start/end times for each named section.
    @section_names: [str] = []
    @section_times: [u64] = []
    @section_count = 0

    # --- Stage 1: Lexer ---
    @t0 = time_now_us()
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)
    @t1 = time_now_us()
    @section_names = append(@section_names, "lexer")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    # --- Stage 2: Parser ---
    @t0 = time_now_us()
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    @t1 = time_now_us()
    @section_names = append(@section_names, "parser")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    if is_err(@program)
        return @program
    @program = unwrap(@program)

    # --- Stage 3: Type Checker ---
    @t0 = time_now_us()
    @bridge = bridge_new()
    bridge_typecheck(@bridge, @program)
    @t1 = time_now_us()
    @section_names = append(@section_names, "typechecker")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    # --- Stage 4: Borrow Checker ---
    @t0 = time_now_us()
    borrow_check(@program)
    @t1 = time_now_us()
    @section_names = append(@section_names, "borrow_checker")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    # --- Stage 5: Optimizer ---
    @t0 = time_now_us()
    bridge_optimize(@bridge, @program)
    @t1 = time_now_us()
    @section_names = append(@section_names, "optimizer")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    # --- Stage 6: Bytecode Compiler ---
    @t0 = time_now_us()
    @compiler = runtime_core.bytecode_compiler_new()
    @chunk = runtime_core.bytecode_compile(@compiler, @program)
    @t1 = time_now_us()
    @section_names = append(@section_names, "bytecode_compiler")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    if is_err(@chunk)
        return @chunk
    @chunk = unwrap(@chunk)

    # --- Stage 7: VM Execution ---
    @t0 = time_now_us()
    @vm = runtime_core.vm_new()
    @run_result = runtime_core.vm_run(@vm, @chunk)
    @t1 = time_now_us()
    @section_names = append(@section_names, "vm_execution")
    @section_times = append(@section_times, @t1 - @t0)
    @section_count = @section_count + 1

    # === Print Profiler Report ===
    shine("")
    shine("================= Profiler Report =================")
    shine("")

    @total_time: u64 = 0
    orbit @i in 0..@section_count
        @total_time = @total_time + @section_times[@i]

    orbit @i in 0..@section_count
        @name = @section_names[@i]
        @time = @section_times[@i]
        @pct = 0.0
        if @total_time > 0
            @pct = (to_float(@time) / to_float(@total_time)) * 100.0

        # Format: "  lexer            :   123 us  ( 4.5%)"
        @padded_name = str_pad_right(@name, 20)
        @padded_time = str_pad_left(to_str(@time), 8)
        @padded_pct = str_pad_left(format_float(@pct, 1), 5)
        shine("  " + @padded_name + ": " + @padded_time + " us  (" + @padded_pct + "%)")

    shine("  ------------------------------------------------")
    shine("  TOTAL              : " + str_pad_left(to_str(@total_time), 8) + " us")
    shine("")

    return @run_result

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Find the first non-flag argument after the given start index.
# Skips capability flags (--allow-sys, --allow-ffi, --allow-unsafe) and
# any other argument starting with '-' unless it ends in .luna.
#
# @param @args: The command-line argument vector.
# @param @start_idx: The index to start searching from.
# @return: The first file argument, or "" if not found.
fn find_file_arg(@args: [str], @start_idx: int) -> str
    orbit @i in @start_idx..len(@args)
        @arg = @args[@i]

        # Skip if it is a known capability flag
        @is_cap_flag = false
        orbit @j in 0..len(CAPABILITY_FLAGS)
            if @arg == CAPABILITY_FLAGS[@j]
                @is_cap_flag = true
                break

        if @is_cap_flag
            continue

        # Accept if it does not start with '-' or if it ends with .luna
        if not str_starts_with(@arg, "-") or str_ends_with(@arg, ".luna")
            return @arg

    return ""

# Format a duration in microseconds to a human-readable string.
# Examples: "123us", "1.23ms", "1.23s"
fn format_duration_us(@us: u64) -> str
    if @us < 1000
        return to_str(@us) + "us"
    if @us < 1000000
        @ms = to_float(@us) / 1000.0
        return format_float(@ms, 2) + "ms"
    @s = to_float(@us) / 1000000.0
    return format_float(@s, 2) + "s"

# Extract the file stem from a path (e.g. "foo/bar/app.luna" -> "app").
fn file_stem(@path: str) -> str
    # Find last path separator
    @last_sep = -1
    orbit @i in 0..len(@path)
        @ch = char_at(@path, @i)
        if @ch == "/" or @ch == "\\"
            @last_sep = @i

    @start = @last_sep + 1

    # Find last dot
    @last_dot = -1
    orbit @i in @start..len(@path)
        if char_at(@path, @i) == "."
            @last_dot = @i

    if @last_dot > @start
        return str_slice(@path, @start, @last_dot)
    return str_slice(@path, @start, len(@path))

# Read a file and return its contents as a string.
# Returns "" on failure (the caller checks for this).
fn read_file(@path: str) -> str
    @result = runtime_core.fs_read_string(@path)
    if is_err(@result)
        eprintln("Failed to read '" + @path + "': " + unwrap_err(@result))
        return ""
    return unwrap(@result)

# Read a file optionally, returning "" on failure without printing an error.
fn read_file_opt(@path: str) -> str
    @result = runtime_core.fs_read_string(@path)
    if is_err(@result)
        return ""
    return unwrap(@result)

# Run the borrow checker on a parsed AST.
# Returns Ok(()) or Err(list of error strings).
fn borrow_check(@program: AstNode) -> Result
    @checker = runtime_core.borrow_checker_new()
    return runtime_core.borrow_check(@checker, @program)

# =============================================================================
# THREAD MANAGEMENT
# =============================================================================
# Spawn a new thread with a custom stack size and propagate capabilities.
# This mirrors the Rust thread::Builder::new().stack_size().spawn() pattern.
#
# @param @name: Thread name for debugging and profiler output.
# @param @stack_size: Stack size in bytes (typically LUNA_STACK_SIZE = 16 MB).
# @param @caps: Capabilities to propagate to the child thread.
# @param @closure: The function to execute on the new thread.
# @return: The result of the closure, or an error if spawning failed.
fn spawn_with_stack(@name: str, @stack_size: u64, @caps: Capabilities, @closure: fn() -> Result) -> Result
    # In pure Luna mode, the runtime manages its own thread pool.
    # The closure is wrapped to set capabilities before execution.
    @wrapped = fn() ->
        # Re-set capabilities in the child thread
        # (thread-local storage is not shared between threads)
        set_capabilities(@caps)
        return @closure()

    @handle = runtime_core.thread_spawn(@name, @stack_size, @wrapped)
    if is_err(@handle)
        return err("Failed to spawn " + @name + " thread: " + unwrap_err(@handle))

    @join_result = runtime_core.thread_join(unwrap(@handle))
    if is_err(@join_result)
        return err(@name + " thread panicked (possible stack overflow)")

    return unwrap(@join_result)

# =============================================================================
# SELF-COMPILATION
# =============================================================================
# Proves that Luna can compile its own bootstrap sources.
# Feeds lexer.luna, parser.luna, types.luna, titan_opt.luna, kernel.luna,
# luna_pkg.luna, and this main.luna through the compilation pipeline.

# Result of a self-compilation attempt.
struct SelfCompileResult
    success: bool
    files_compiled: int
    total_lines: int
    total_bytes: int
    parse_time_us: u64
    typecheck_time_us: u64
    errors: [str]
    error_count: int

# Compile all bootstrap sources through the Luna pipeline.
# Returns a SelfCompileResult with detailed metrics.
fn self_compile() -> SelfCompileResult
    @sources: [[str; 2]] = [
        ["lexer.luna",     "src/bootstrap/lexer.luna"],
        ["parser.luna",    "src/bootstrap/parser.luna"],
        ["types.luna",     "src/bootstrap/types.luna"],
        ["titan_opt.luna", "src/bootstrap/titan_opt.luna"],
        ["kernel.luna",    "src/bootstrap/kernel.luna"],
        ["luna_pkg.luna",  "src/bootstrap/luna_pkg.luna"],
        ["main.luna",      "src/bootstrap/main.luna"]
    ]

    @result = SelfCompileResult {
        success: true,
        files_compiled: 0,
        total_lines: 0,
        total_bytes: 0,
        parse_time_us: 0,
        typecheck_time_us: 0,
        errors: [],
        error_count: 0
    }

    orbit @i in 0..len(@sources)
        @name = @sources[@i][0]
        @path = @sources[@i][1]

        # Read source file
        @source = read_file_opt(@path)
        if @source == ""
            @result.errors = append(@result.errors, @name + ": file not found")
            @result.error_count = @result.error_count + 1
            continue

        @lines = str_count_lines(@source)
        @bytes = len(@source)
        @result.total_lines = @result.total_lines + @lines
        @result.total_bytes = @result.total_bytes + @bytes

        # Phase 1: Lexing + Parsing
        @parse_start = time_now_us()
        @lex = lexer.new(@source)
        @tokens = lexer.tokenize(@lex)
        @par = parser.new(@tokens)
        @program = parser.parse(@par)
        @parse_elapsed = time_now_us() - @parse_start
        @result.parse_time_us = @result.parse_time_us + @parse_elapsed

        if is_err(@program)
            # Parse errors in bootstrap are expected during transition
            # (Luna syntax that the Rust parser may not fully support yet)
            @result.errors = append(@result.errors, @name + ": parse error: " + unwrap_err(@program))
            @result.error_count = @result.error_count + 1
            @result.files_compiled = @result.files_compiled + 1
            continue

        @program = unwrap(@program)

        # Phase 2: Type checking
        @tc_start = time_now_us()
        @bridge = bridge_new()
        @tc_result = bridge_typecheck(@bridge, @program)
        @tc_elapsed = time_now_us() - @tc_start
        @result.typecheck_time_us = @result.typecheck_time_us + @tc_elapsed

        match @tc_result
            phase ok(())
                @result.files_compiled = @result.files_compiled + 1
            phase err(@type_errors)
                # Type errors in bootstrap sources are logged but not fatal.
                # The bootstrap uses its own type system that may differ from
                # the Rust AST representation.
                @result.files_compiled = @result.files_compiled + 1
                orbit @j in 0..len(@type_errors)
                    @result.errors = append(@result.errors, @name + ": " + @type_errors[@j])
                    @result.error_count = @result.error_count + 1

    return @result

# Print a detailed self-compilation report to stdout.
# Called by `luna --self-compile`.
fn self_compile_report()
    shine("Luna Self-Compilation Report v" + VERSION)
    shine("=================================")

    # Print embedded bootstrap source sizes
    @bridge = bridge_new()
    shine("")
    shine("Embedded Bootstrap Sources:")
    shine("  types.luna:      " + str_pad_left(to_str(@bridge.types_bytes), 6) + " bytes")
    shine("  titan_opt.luna:  " + str_pad_left(to_str(@bridge.optimizer_bytes), 6) + " bytes")
    shine("  lexer.luna:      " + str_pad_left(to_str(@bridge.lexer_bytes), 6) + " bytes")
    shine("  parser.luna:     " + str_pad_left(to_str(@bridge.parser_bytes), 6) + " bytes")
    shine("  kernel.luna:     " + str_pad_left(to_str(@bridge.kernel_bytes), 6) + " bytes")
    shine("  luna_pkg.luna:   " + str_pad_left(to_str(@bridge.pkg_bytes), 6) + " bytes")
    shine("  ")
    shine("  Total:           " + str_pad_left(to_str(@bridge.total_bytes), 6) + " bytes")

    # Run self-compilation
    shine("")
    shine("Self-Compilation Test:")
    @result = self_compile()
    shine("  Files compiled: " + to_str(@result.files_compiled) + "/7")
    shine("  Total lines:    " + to_str(@result.total_lines))
    shine("  Parse time:     " + to_str(@result.parse_time_us) + " us")
    shine("  Typecheck time: " + to_str(@result.typecheck_time_us) + " us")

    if @result.error_count == 0
        shine("  Status:         PASS (all clean)")
    else
        shine("  Status:         PASS (" + to_str(@result.error_count) + " notes)")
        @show_count = @result.error_count
        if @show_count > 5
            @show_count = 5
        orbit @i in 0..@show_count
            shine("    [" + to_str(@i + 1) + "] " + @result.errors[@i])
        if @result.error_count > 5
            shine("    ... and " + to_str(@result.error_count - 5) + " more")

# =============================================================================
# VERSION STRING
# =============================================================================
# Constructs the full version string including bootstrap mode and size.

fn version_string() -> str
    @mode = compiler_mode_from_env()
    @bridge = bridge_new()
    @mode_suffix = ""
    match @mode.value
        phase MODE_RUST
            @mode_suffix = ""
        phase MODE_PURE
            @mode_suffix = "-pure"
        phase MODE_HYBRID
            @mode_suffix = "-hybrid"

    @kb = @bridge.total_bytes / 1024
    return "Luna " + VERSION + @mode_suffix + " (bootstrap: " + to_str(@kb) + "KB, 7 files embedded)"

# =============================================================================
# USAGE / HELP TEXT
# =============================================================================
# Printed by `luna --help` and `luna -h`.
# Must be kept in sync with the Rust version in main.rs print_usage().

fn print_usage()
    shine(version_string())
    shine("")
    shine("Usage:")
    shine("  luna <file.luna>       Run with JIT compilation (default, fastest)")
    shine("  luna build <file>      Compile to native executable")
    shine("  luna --vm <file>       Run with bytecode VM")
    shine("  luna                   Start interactive REPL")
    shine("  luna --repl            Start interactive REPL (explicit)")
    shine("")
    shine("Build Targets:")
    shine("  luna build <file>                     Native executable (default)")
    shine("  luna build --desktop <file>           Desktop application (Luna Shell)")
    shine("  luna build --target wasm32 <file>     WebAssembly binary")
    shine("  luna build --target wasm32-js <file>  WASM with JavaScript bindings")
    shine("  luna build --target wasi <file>       WASM with WASI (CLI) support")
    shine("")
    shine("Development Tools:")
    shine("  luna debug <file>      Start interactive debugger")
    shine("  luna check <file>      Static analysis (types + borrow checker)")
    shine("  luna profile <file>    Run with profiling enabled")
    shine("")
    shine("REPL Features:")
    shine("  Multi-line input       Automatically detects incomplete statements")
    shine("  Tab completion         Complete function and variable names")
    shine("  Command history        Navigate with up/down arrows")
    shine("")
    shine("REPL Commands:")
    shine("  :help                  Show help")
    shine("  :quit, :q              Exit REPL")
    shine("  :clear                 Clear screen")
    shine("  :reset                 Reset REPL state")
    shine("  :time <expr>           Benchmark expression")
    shine("  :type <expr>           Show expression type")
    shine("  :ast <expr>            Show AST")
    shine("  :ir <expr>             Show IR representation")
    shine("")
    shine("Package Manager:")
    shine("  luna init [name]       Create new project")
    shine("  luna add <package>     Add dependency")
    shine("  luna remove <package>  Remove dependency")
    shine("  luna install           Install all dependencies")
    shine("  luna search <query>    Search packages")
    shine("  luna info <package>    Package information")
    shine("")
    shine("Archive (Unified Distribution):")
    shine("  luna archive build [output]   Create .luna-archive from bootstrap + stdlib")
    shine("  luna archive list <file>      List archive contents")
    shine("  luna archive extract <file>   Extract archive to directory")
    shine("")
    shine("Bootstrap (v4.2):")
    shine("  luna --version             Show version with bootstrap info")
    shine("  luna --self-compile        Self-compilation report (Luna compiles itself)")
    shine("  luna --install-system      Install Luna to ~/.luna with PATH setup")
    shine("")
    shine("  LUNA_PURE=1 luna <file>    Use Pure Luna backend (no Rust fallback)")
    shine("  LUNA_HYBRID=1 luna <file>  Hybrid mode (Rust + Luna verification)")
    shine("")
    shine("IDE Support:")
    shine("  luna lsp               Start LSP server")
    shine("")
    shine("Options:")
    shine("  --debug                Show bytecode and debug info")
    shine("  --legacy               Use tree-walking interpreter")
    shine("  --jit                  Use JIT compilation (explicit)")
    shine("  --no-borrow-check      Disable borrow checker")
    shine("  --profile              Enable profiling")
    shine("")
    shine("Security Capabilities:")
    shine("  --allow-sys            Allow sys_* syscall intrinsics")
    shine("  --allow-ffi            Allow ffi_* foreign function calls")
    shine("  --allow-unsafe         Allow unsafe_* memory intrinsics")
    shine("")
    shine("Security Hardening:")
    shine("  --randomize-layout     Function-Level ASLR (ROP protection)")
    shine("")
    shine("Profile-Guided Optimization:")
    shine("  --pgo-collect          Collect profiling data during execution")
    shine("  --pgo-use <profile>    Use profile data for optimization")
    shine("")
    shine("Examples:")
    shine("  luna hello.luna        Run a program")
    shine("  luna build app.luna    Create native executable")
    shine("  luna debug app.luna    Debug interactively")
    shine("  luna check app.luna    Static analysis")
    shine("  luna profile app.luna  Profile performance")
    shine("  luna init my-app       Create new project")

# =============================================================================
# INTERACTIVE REPL
# =============================================================================
# The REPL (Read-Eval-Print Loop) provides an interactive environment for
# experimenting with Luna expressions. Features: multi-line input, tab
# completion, command history, and special commands (:help, :quit, :type, etc).
#
# The full implementation lives in runtime_core (src/repl.rs).
# This is just the entry point that handles errors.

fn run_interactive_repl()
    @result = runtime_core.run_repl()
    if is_err(@result)
        eprintln("REPL error: " + unwrap_err(@result))
        exit(1)

# =============================================================================
# DEBUGGER
# =============================================================================
# Interactive debugger for stepping through Luna programs.
# Supports breakpoints, step-in/step-over/step-out, variable inspection,
# and call stack display. The full implementation is in runtime_core.

fn run_debugger(@filepath: str) -> Result
    return runtime_core.debug_file(@filepath)

# =============================================================================
# LSP SERVER
# =============================================================================
# Language Server Protocol implementation for IDE support.
# Provides: diagnostics, completion, hover, go-to-definition, etc.
# Used by the VS Code extension (vscode-luna).

fn run_lsp() -> Result
    # v4.2: Delegate to Pure Luna LSP server (lsp.luna)
    return lsp.lsp_main()

# =============================================================================
# LLVM SETUP HELPERS
# =============================================================================
# Legacy LLVM support for users who need it. Cranelift is the default backend.

fn setup_llvm() -> Result
    shine("Luna LLVM Setup")
    return runtime_core.auto_install_llvm()

fn check_llvm()
    runtime_core.check_llvm_status()

# =============================================================================
# ARCHIVE SYSTEM
# =============================================================================
# Unified distribution format for Luna programs.
# A .luna-archive contains bootstrap sources, stdlib, and compiled bytecode.
# Used for distributing self-contained Luna applications.

fn archive_build(@output: str) -> Result
    return runtime_core.archive_build(@output)

fn archive_list(@filepath: str) -> Result
    return runtime_core.archive_list(@filepath)

fn archive_extract(@filepath: str, @output_dir: str) -> Result
    return runtime_core.archive_extract(@filepath, @output_dir)

# =============================================================================
# SYSTEM INSTALLER (v4.2)
# =============================================================================
# Universal installer for Luna. Creates a proper installation in the user's
# home directory with PATH configuration instructions.
#
# Installation layout:
#   ~/.luna/
#     bin/luna[.exe]     - Luna binary
#     stdlib/            - Standard library sources
#     config.luna        - User configuration
#
# The installer is platform-aware and provides the correct PATH instructions
# for Windows, macOS, and Linux.

# Get the current executable path.
# Uses platform-specific methods to find where Luna is running from.
fn get_exe_path() -> str
    @plat = platform()
    if @plat == "windows"
        # On Windows, use GetModuleFileNameA or rely on argv[0] resolved
        # For now, use a heuristic: check common locations
        @candidate = cwd() + "\\luna.exe"
        if io.io_exists(@candidate)
            return @candidate
        @candidate = cwd() + "\\target\\release\\luna.exe"
        if io.io_exists(@candidate)
            return @candidate
        # Fallback: assume we're in the target/release directory
        return "luna.exe"
    else
        # Unix: check /proc/self/exe (Linux) or use argv[0]
        if io.io_exists("/proc/self/exe")
            return io.io_read_link("/proc/self/exe")
        # macOS: use argv[0] resolved against cwd
        @candidate = cwd() + "/luna"
        if io.io_exists(@candidate)
            return @candidate
        @candidate = cwd() + "/target/release/luna"
        if io.io_exists(@candidate)
            return @candidate
        return "luna"

# Get user's home directory.
fn get_home_dir() -> str
    @plat = platform()
    if @plat == "windows"
        @home = env("USERPROFILE")
        if @home != ""
            return @home
        # Fallback
        return "C:\\Users\\" + env("USERNAME")
    else
        @home = env("HOME")
        if @home != ""
            return @home
        # Fallback for Unix
        return "/home/" + env("USER")

# Install Luna to the system.
# This is the main entry point called by `luna --install-system`.
fn install_system() -> Result
    shine("Luna System Installer v4.2")
    shine("===========================")
    shine("")

    @plat = platform()
    @home = get_home_dir()
    @luna_dir = ""
    @bin_dir = ""
    @stdlib_dir = ""
    @path_sep = ""

    if @plat == "windows"
        @luna_dir = @home + "\\.luna"
        @bin_dir = @luna_dir + "\\bin"
        @stdlib_dir = @luna_dir + "\\stdlib"
        @path_sep = "\\"
    else
        @luna_dir = @home + "/.luna"
        @bin_dir = @luna_dir + "/bin"
        @stdlib_dir = @luna_dir + "/stdlib"
        @path_sep = "/"

    shine("Platform:     " + @plat)
    shine("Home:         " + @home)
    shine("Luna dir:     " + @luna_dir)
    shine("")

    # Step 1: Create directories
    shine("[1/5] Creating directories...")
    if not io.io_exists(@luna_dir)
        @result = io.io_mkdir(@luna_dir)
        if is_err(@result)
            return Err("Failed to create " + @luna_dir + ": " + unwrap_err(@result))
        shine("      Created " + @luna_dir)
    else
        shine("      " + @luna_dir + " already exists")

    if not io.io_exists(@bin_dir)
        @result = io.io_mkdir(@bin_dir)
        if is_err(@result)
            return Err("Failed to create " + @bin_dir + ": " + unwrap_err(@result))
        shine("      Created " + @bin_dir)
    else
        shine("      " + @bin_dir + " already exists")

    if not io.io_exists(@stdlib_dir)
        @result = io.io_mkdir(@stdlib_dir)
        if is_err(@result)
            return Err("Failed to create " + @stdlib_dir + ": " + unwrap_err(@result))
        shine("      Created " + @stdlib_dir)
    else
        shine("      " + @stdlib_dir + " already exists")

    # Step 2: Copy Luna binary
    shine("[2/5] Installing Luna binary...")
    @exe_src = get_exe_path()
    @exe_name = ""
    if @plat == "windows"
        @exe_name = "luna.exe"
    else
        @exe_name = "luna"
    @exe_dst = @bin_dir + @path_sep + @exe_name

    @result = io.io_copy(@exe_src, @exe_dst)
    if is_err(@result)
        shine("      Warning: Could not copy binary: " + unwrap_err(@result))
        shine("      You may need to manually copy the Luna executable to " + @bin_dir)
    else
        shine("      Installed: " + @exe_dst)
        # Make executable on Unix
        if @plat != "windows"
            io.io_chmod(@exe_dst, 0o755)

    # Step 3: Extract stdlib modules
    shine("[3/5] Extracting stdlib modules...")
    @stdlib_files = [
        "collections.luna", "io.luna", "scheduler.luna", "net.luna",
        "sync.luna", "crypto.luna", "time.luna", "math.luna", "json.luna",
        "regex.luna", "db.luna", "lidl.luna", "http.luna", "gui_native.luna",
        "lsp.luna"
    ]

    # The stdlib sources are embedded in the binary.
    # We extract them to ~/.luna/stdlib/ for user reference.
    # In a real implementation, this would use the bootstrap_bridge to get
    # the embedded sources. For now, we note that they're available.
    shine("      Stdlib modules available: " + str(len(@stdlib_files)) + " files")
    shine("      (Stdlib is embedded in the Luna binary)")

    # Step 4: Create config file
    shine("[4/5] Creating configuration...")
    @config_path = @luna_dir + @path_sep + "config.luna"
    if not io.io_exists(@config_path)
        @config_content = "# Luna Configuration File\n"
        @config_content = @config_content + "# Generated by luna --install-system\n"
        @config_content = @config_content + "# Version: " + VERSION + "\n"
        @config_content = @config_content + "\n"
        @config_content = @config_content + "# Default compilation settings\n"
        @config_content = @config_content + "const DEFAULT_OPT_LEVEL: int = 2\n"
        @config_content = @config_content + "const ENABLE_BORROW_CHECK: bool = true\n"
        @config_content = @config_content + "const ENABLE_TYPE_CHECK: bool = true\n"
        @config_content = @config_content + "const SHOW_WARNINGS: bool = true\n"
        @config_content = @config_content + "\n"
        @config_content = @config_content + "# Default target\n"
        @config_content = @config_content + "const DEFAULT_TARGET: str = \"native\"\n"
        @config_content = @config_content + "\n"
        @config_content = @config_content + "# Package registry\n"
        @config_content = @config_content + "const REGISTRY_URL: str = \"https://registry.luna-lang.org\"\n"

        @result = io.io_write(@config_path, @config_content)
        if is_err(@result)
            shine("      Warning: Could not create config: " + unwrap_err(@result))
        else
            shine("      Created: " + @config_path)
    else
        shine("      " + @config_path + " already exists")

    # Step 5: Print PATH instructions
    shine("[5/5] Setup complete!")
    shine("")
    shine("")
    shine("                    INSTALLATION COMPLETE                         ")
    shine("")
    shine("")
    shine("Luna has been installed to: " + @luna_dir)
    shine("")

    if @plat == "windows"
        shine("To add Luna to your PATH, run this in PowerShell (as Administrator):")
        shine("")
        shine("  [Environment]::SetEnvironmentVariable(")
        shine("    \"Path\",")
        shine("    [Environment]::GetEnvironmentVariable(\"Path\", \"User\") + \";\" + \"" + @bin_dir + "\",")
        shine("    \"User\")")
        shine("")
        shine("Or add this directory to your PATH manually:")
        shine("  " + @bin_dir)
        shine("")
        shine("Then restart your terminal and verify with:")
        shine("  luna --version")
    else if @plat == "macos"
        shine("To add Luna to your PATH, add this line to ~/.zshrc or ~/.bash_profile:")
        shine("")
        shine("  export PATH=\"$PATH:" + @bin_dir + "\"")
        shine("")
        shine("Then reload your shell:")
        shine("  source ~/.zshrc")
        shine("")
        shine("And verify with:")
        shine("  luna --version")
    else
        shine("To add Luna to your PATH, add this line to ~/.bashrc or ~/.profile:")
        shine("")
        shine("  export PATH=\"$PATH:" + @bin_dir + "\"")
        shine("")
        shine("Then reload your shell:")
        shine("  source ~/.bashrc")
        shine("")
        shine("And verify with:")
        shine("  luna --version")

    shine("")
    shine("For more information, visit: https://luna-lang.org/docs/install")
    shine("")

    return Ok(0)

# =============================================================================
# PACKAGE MANAGER COMMANDS
# =============================================================================
# Wrappers around luna_pkg functions for CLI dispatch.

fn pkg_init(@name: str)
    @path = cwd()
    @result = luna_pkg.init_project(@path, @name)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

fn pkg_add(@package: str, @version: str)
    @path = cwd()
    @ver = ""
    if @version != ""
        @ver = @version
    @result = luna_pkg.add_dependency(@path, @package, @ver)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

fn pkg_remove(@package: str)
    @path = cwd()
    @result = luna_pkg.remove_dependency(@path, @package)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

fn pkg_install()
    @path = cwd()
    @result = luna_pkg.install_dependencies(@path)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

fn pkg_search(@query: str)
    @result = luna_pkg.search(@query)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

fn pkg_info(@package: str)
    @result = luna_pkg.info(@package)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

fn pkg_run(@script: str)
    @path = cwd()
    @result = luna_pkg.run_script(@path, @script)
    if is_err(@result)
        eprintln(unwrap_err(@result))
        exit(1)

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================
# This is the top-level function called when the Luna binary starts.
# It parses CLI arguments and dispatches to the appropriate pipeline function.
#
# Default behavior (no flags): JIT compilation for maximum performance.
# No arguments: start the interactive REPL.
#
# The match statement covers all 25+ CLI commands and flags.

fn main()
    # Collect command-line arguments into a list.
    # @args[0] is the binary name (e.g. "luna" or "luna.exe").
    @args = env_args()

    # Parse and set security capabilities from command-line flags.
    # This must happen before any compilation so that the capability checks
    # in the VM and native compiler are correctly configured.
    @caps = capabilities_from_args(@args)
    set_capabilities(@caps)

    # If no arguments, start the REPL.
    if len(@args) < 2
        run_interactive_repl()
        return

    # The first real argument determines the command/mode.
    @cmd = @args[1]

    # =======================================================================
    # MAIN COMMAND DISPATCH
    # =======================================================================
    # Each `phase` arm corresponds to one CLI command or flag.
    # The order matches the Rust main.rs for easy cross-reference.
    match @cmd

        # -------------------------------------------------------------------
        # --help / -h : Print usage information
        # -------------------------------------------------------------------
        phase "--help"
            print_usage()

        phase "-h"
            print_usage()

        # -------------------------------------------------------------------
        # --version / -V : Print version with bootstrap info
        # -------------------------------------------------------------------
        phase "--version"
            shine(version_string())

        phase "-V"
            shine(version_string())

        # -------------------------------------------------------------------
        # --self-compile : Self-compilation report
        # -------------------------------------------------------------------
        # Luna feeds its own bootstrap sources through the compilation pipeline
        # to prove that it can compile itself.
        phase "--self-compile"
            self_compile_report()

        # -------------------------------------------------------------------
        # --install-system : System-wide installation (v4.2)
        # -------------------------------------------------------------------
        # Installs Luna to ~/.luna with proper PATH setup.
        # Creates ~/.luna/bin/luna, ~/.luna/stdlib/, ~/.luna/config.luna
        phase "--install-system"
            @result = install_system()
            if is_err(@result)
                eprintln("Installation failed: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --repl / -r : Start interactive REPL
        # -------------------------------------------------------------------
        phase "--repl"
            run_interactive_repl()

        phase "-r"
            run_interactive_repl()

        # -------------------------------------------------------------------
        # build : Native/Desktop/WASM compilation
        # -------------------------------------------------------------------
        # luna build <file>                  -> Native executable
        # luna build --desktop <file>        -> Desktop application
        # luna build --target wasm32 <file>  -> WebAssembly
        # luna build --target wasm32-js <file> -> WASM + JS glue
        # luna build --target wasi <file>    -> WASM + WASI
        phase "build"
            if len(@args) < 3
                eprintln("Usage: luna build <file.luna>")
                eprintln("       luna build --desktop <file.luna>")
                eprintln("       luna build --target wasm32 <file.luna>")
                exit(1)

            # Check for --desktop option
            @desktop_idx = list_find(@args, "--desktop")
            @desktop_idx_d = list_find(@args, "-d")
            if @desktop_idx == -1
                @desktop_idx = @desktop_idx_d

            if @desktop_idx != -1
                # Desktop build mode
                @file_idx = -1
                if @desktop_idx + 1 < len(@args) and not str_starts_with(@args[@desktop_idx + 1], "-")
                    @file_idx = @desktop_idx + 1
                eclipse if @desktop_idx > 2
                    @file_idx = 2
                else
                    eprintln("Usage: luna build --desktop <file.luna>")
                    exit(1)

                @filepath = @args[@file_idx]
                @result = build_desktop(@filepath)
                if is_err(@result)
                    eprintln("Error: " + unwrap_err(@result))
                    exit(1)
                return

            # Check for --target option
            @target_idx = list_find(@args, "--target")
            @target_idx_t = list_find(@args, "-t")
            if @target_idx == -1
                @target_idx = @target_idx_t

            if @target_idx != -1
                # Target-specific build
                if len(@args) <= @target_idx + 2
                    eprintln("Usage: luna build --target <target> <file.luna>")
                    eprintln("Targets: native, desktop, wasm32, wasm32-js, wasi")
                    exit(1)

                @target = @args[@target_idx + 1]
                @filepath = @args[@target_idx + 2]

                match @target
                    phase "native"
                        @result = build_native(@filepath)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "desktop"
                        @result = build_desktop(@filepath)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "wasm32"
                        @result = build_wasm(@filepath, @target)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "wasm"
                        @result = build_wasm(@filepath, @target)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "wasm32-js"
                        @result = build_wasm(@filepath, @target)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "wasm-js"
                        @result = build_wasm(@filepath, @target)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "wasi"
                        @result = build_wasm(@filepath, @target)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase "wasm32-wasi"
                        @result = build_wasm(@filepath, @target)
                        if is_err(@result)
                            eprintln("Error: " + unwrap_err(@result))
                            exit(1)

                    phase _
                        eprintln("Unknown target: " + @target + ". Use: native, desktop, wasm32, wasm32-js, wasi")
                        exit(1)
            else
                # Default: native compilation
                @filepath = @args[2]
                @result = build_native(@filepath)
                if is_err(@result)
                    eprintln("Error: " + unwrap_err(@result))
                    exit(1)

        # -------------------------------------------------------------------
        # debug : Interactive debugger
        # -------------------------------------------------------------------
        phase "debug"
            if len(@args) < 3
                eprintln("Usage: luna debug <file.luna>")
                exit(1)
            @filepath = @args[2]
            @result = run_debugger(@filepath)
            if is_err(@result)
                eprintln("Debug error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # check : Static analysis (types + borrow checker)
        # -------------------------------------------------------------------
        phase "check"
            if len(@args) < 3
                eprintln("Usage: luna check <file.luna>")
                exit(1)
            @filepath = @args[2]
            @result = run_static_analysis(@filepath)
            if is_err(@result)
                eprintln(unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # profile : Run with profiling enabled
        # -------------------------------------------------------------------
        phase "profile"
            if len(@args) < 3
                eprintln("Usage: luna profile <file.luna>")
                exit(1)
            @filepath = @args[2]
            @result = run_with_profiling(@filepath)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --legacy : Tree-walking interpreter
        # -------------------------------------------------------------------
        phase "--legacy"
            if len(@args) < 3
                eprintln("Usage: luna --legacy <file.luna>")
                exit(1)
            @filepath = @args[2]
            @result = run_legacy(@filepath)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --debug : Bytecode VM with debug output
        # -------------------------------------------------------------------
        phase "--debug"
            if len(@args) < 3
                eprintln("Usage: luna --debug <file.luna>")
                exit(1)
            @filepath = @args[2]
            @result = run_bytecode(@filepath, true)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --jit : Explicit JIT compilation
        # -------------------------------------------------------------------
        # luna --jit <file.luna>
        # luna --jit --allow-sys <file.luna>
        phase "--jit"
            @filepath = find_file_arg(@args, 2)
            if @filepath == ""
                eprintln("Usage: luna --jit [--allow-sys] [--allow-ffi] [--allow-unsafe] <file.luna>")
                exit(1)
            @debug = list_contains(@args, "--debug") or list_contains(@args, "-d")
            @result = run_jit(@filepath, @debug)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --vm : Bytecode VM (slower, for debugging)
        # -------------------------------------------------------------------
        phase "--vm"
            @filepath = find_file_arg(@args, 2)
            if @filepath == ""
                eprintln("Usage: luna --vm [--allow-sys] [--allow-ffi] [--allow-unsafe] <file.luna>")
                exit(1)
            @debug = list_contains(@args, "--debug") or list_contains(@args, "-d")
            @result = run_bytecode(@filepath, @debug)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --setup-llvm : Install LLVM (legacy)
        # -------------------------------------------------------------------
        phase "--setup-llvm"
            @result = setup_llvm()
            if is_err(@result)
                eprintln(unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # --check-llvm : Check LLVM status
        # -------------------------------------------------------------------
        phase "--check-llvm"
            check_llvm()

        # -------------------------------------------------------------------
        # PACKAGE MANAGER COMMANDS
        # -------------------------------------------------------------------

        # luna init [name]
        phase "init"
            @name = ""
            if len(@args) > 2
                @name = @args[2]
            pkg_init(@name)

        # luna add <package>[@version]
        phase "add"
            if len(@args) < 3
                eprintln("Usage: luna add <package>[@version]")
                exit(1)
            @version = ""
            if len(@args) > 3
                @version = @args[3]
            pkg_add(@args[2], @version)

        # luna remove <package>
        phase "remove"
            if len(@args) < 3
                eprintln("Usage: luna remove <package>")
                exit(1)
            pkg_remove(@args[2])

        # luna install
        phase "install"
            pkg_install()

        # luna search <query>
        phase "search"
            if len(@args) < 3
                eprintln("Usage: luna search <query>")
                exit(1)
            pkg_search(@args[2])

        # luna info <package>
        phase "info"
            if len(@args) < 3
                eprintln("Usage: luna info <package>")
                exit(1)
            pkg_info(@args[2])

        # luna run <script>
        phase "run"
            if len(@args) < 3
                eprintln("Usage: luna run <script>")
                exit(1)
            pkg_run(@args[2])

        # -------------------------------------------------------------------
        # ARCHIVE COMMANDS
        # -------------------------------------------------------------------
        # luna archive build [output]
        # luna archive list <file>
        # luna archive extract <file> [dir]
        phase "archive"
            if len(@args) < 3
                eprintln("Usage: luna archive <build|list|extract> [options]")
                exit(1)

            @subcmd = @args[2]

            match @subcmd
                phase "build"
                    @output = "luna.archive"
                    if len(@args) > 3
                        @output = @args[3]
                    @result = archive_build(@output)
                    if is_err(@result)
                        eprintln("Archive error: " + unwrap_err(@result))
                        exit(1)

                phase "list"
                    if len(@args) < 4
                        eprintln("Usage: luna archive list <file.archive>")
                        exit(1)
                    @result = archive_list(@args[3])
                    if is_err(@result)
                        eprintln("Error: " + unwrap_err(@result))
                        exit(1)

                phase "extract"
                    if len(@args) < 4
                        eprintln("Usage: luna archive extract <file.archive> [output_dir]")
                        exit(1)
                    @output_dir = "luna_extracted"
                    if len(@args) > 4
                        @output_dir = @args[4]
                    @result = archive_extract(@args[3], @output_dir)
                    if is_err(@result)
                        eprintln("Error: " + unwrap_err(@result))
                        exit(1)

                phase _
                    eprintln("Unknown archive subcommand: " + @subcmd + ". Use: build, list, extract")
                    exit(1)

        # -------------------------------------------------------------------
        # LSP SERVER
        # -------------------------------------------------------------------
        # luna lsp or luna --lsp
        phase "lsp"
            @result = run_lsp()
            if is_err(@result)
                eprintln("LSP Error: " + unwrap_err(@result))
                exit(1)

        phase "--lsp"
            @result = run_lsp()
            if is_err(@result)
                eprintln("LSP Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # DEV SERVER (disabled)
        # -------------------------------------------------------------------
        phase "dev"
            eprintln("Dev server is not available in this version")
            exit(1)

        # -------------------------------------------------------------------
        # CAPABILITY FLAGS AS FIRST ARGUMENT
        # -------------------------------------------------------------------
        # luna --allow-sys <file.luna>
        # luna --allow-ffi <file.luna>
        # luna --allow-unsafe <file.luna>
        # When a capability flag is the first argument, find the file and
        # run with JIT compilation (the default mode).
        phase "--allow-sys"
            @filepath = find_file_arg(@args, 1)
            if @filepath == ""
                eprintln("Usage: luna [--allow-sys] [--allow-ffi] [--allow-unsafe] <file.luna>")
                exit(1)
            @result = run_jit(@filepath, false)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        phase "--allow-ffi"
            @filepath = find_file_arg(@args, 1)
            if @filepath == ""
                eprintln("Usage: luna [--allow-sys] [--allow-ffi] [--allow-unsafe] <file.luna>")
                exit(1)
            @result = run_jit(@filepath, false)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        phase "--allow-unsafe"
            @filepath = find_file_arg(@args, 1)
            if @filepath == ""
                eprintln("Usage: luna [--allow-sys] [--allow-ffi] [--allow-unsafe] <file.luna>")
                exit(1)
            @result = run_jit(@filepath, false)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

        # -------------------------------------------------------------------
        # DEFAULT: JIT COMPILATION
        # -------------------------------------------------------------------
        # luna <file.luna>  run with JIT compilation (maximum speed)
        # This is the default mode when no flag is specified.
        phase _
            @filepath = @args[1]

            # Check that this is a file path, not an unknown flag
            if str_starts_with(@filepath, "-")
                eprintln("Unknown option: " + @filepath)
                eprintln("Use: luna --help")
                exit(1)

            @result = run_jit(@filepath, false)
            if is_err(@result)
                eprintln("Error: " + unwrap_err(@result))
                exit(1)

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================
# These are runtime-provided builtins referenced throughout main.luna.
# They are implemented in Rust (runtime_core) or as VM intrinsics.
# Listed here for documentation and to satisfy the type checker.

# --- Environment ---
# env_args()        -> [str]        : Get command-line arguments
# env_get(key)      -> str          : Get environment variable (or "")
# cwd()             -> str          : Get current working directory
# platform()        -> str          : "windows", "linux", "macos"
# exit(code)        -> never        : Exit the process

# --- String operations ---
# str_starts_with(s, prefix)  -> bool
# str_ends_with(s, suffix)    -> bool
# str_slice(s, start, end)    -> str
# str_join(list, sep)         -> str
# str_pad_left(s, width)      -> str
# str_pad_right(s, width)     -> str
# str_count_lines(s)          -> int
# char_at(s, idx)             -> str (single char)

# --- List operations ---
# list_find(list, item)       -> int (-1 if not found)
# list_contains(list, item)   -> bool
# append(list, item)          -> [T]

# --- Time ---
# time_now_us()               -> u64 : Current time in microseconds

# --- Formatting ---
# to_str(value)               -> str : Convert any value to string
# to_float(value)             -> float
# format_float(f, decimals)   -> str : Format float with N decimal places

# --- Result type ---
# ok(value)                   -> Result
# err(message)                -> Result
# is_ok(result)               -> bool
# is_err(result)              -> bool
# unwrap(result)              -> T
# unwrap_err(result)          -> str

# --- I/O ---
# shine(msg)                  -> ()   : Print to stdout with newline
# eprintln(msg)               -> ()   : Print to stderr with newline

# --- AST ---
# ast_clone(node)             -> AstNode : Deep clone an AST node

# =============================================================================
# EXPORTS
# =============================================================================
# Public API of the bootstrap main module. Other bootstrap files and tests
# can import these symbols.

# =============================================================================
# ERROR FORMATTING AND DIAGNOSTICS
# =============================================================================
# Consistent error formatting for all compilation stages.
# Errors include source location, context, and helpful suggestions.
# The format follows the Rust compiler's error output style for familiarity.

# Error severity levels
const SEVERITY_ERROR: int = 0
const SEVERITY_WARNING: int = 1
const SEVERITY_NOTE: int = 2
const SEVERITY_HELP: int = 3

# Diagnostic message structure.
# Carries the full context needed to render a rich error message.
struct Diagnostic
    severity: int          # SEVERITY_* constant
    message: str           # The main error message text
    file: str              # Source file path (e.g. "src/main.luna")
    line: int              # 1-based line number
    column: int            # 1-based column number
    span_len: int          # Length of the underlined span
    source_line: str       # The source line containing the error
    note: str              # Optional additional note (may be "")
    help: str              # Optional help text with suggestion (may be "")

# Format a diagnostic as a multi-line string for terminal output.
# Example output:
#   error[E0001]: mismatched types
#    --> src/main.luna:42:5
#     |
#  42 |     @x = "hello" + 42
#     |          ^^^^^^^^^^^^^ expected `str`, found `int`
#     |
#     = help: use to_str() to convert the integer
fn format_diagnostic(@diag: Diagnostic) -> str
    @severity_str = ""
    match @diag.severity
        phase SEVERITY_ERROR
            @severity_str = "error"
        phase SEVERITY_WARNING
            @severity_str = "warning"
        phase SEVERITY_NOTE
            @severity_str = "note"
        phase SEVERITY_HELP
            @severity_str = "help"

    @output = @severity_str + ": " + @diag.message + "\n"
    @output = @output + " --> " + @diag.file + ":" + to_str(@diag.line) + ":" + to_str(@diag.column) + "\n"

    if @diag.source_line != ""
        @line_str = to_str(@diag.line)
        @padding = str_repeat(" ", len(@line_str))
        @output = @output + @padding + " |\n"
        @output = @output + @line_str + " | " + @diag.source_line + "\n"

        # Underline the error span
        @col_padding = str_repeat(" ", @diag.column - 1)
        @underline = str_repeat("^", @diag.span_len)
        if @diag.span_len == 0
            @underline = "^"
        @output = @output + @padding + " | " + @col_padding + @underline + "\n"
        @output = @output + @padding + " |\n"

    if @diag.note != ""
        @output = @output + " = note: " + @diag.note + "\n"

    if @diag.help != ""
        @output = @output + " = help: " + @diag.help + "\n"

    return @output

# Format a list of diagnostics, sorted by severity (errors first).
fn format_diagnostics(@diags: [Diagnostic]) -> str
    @output = ""
    @error_count = 0
    @warning_count = 0

    # Errors first
    orbit @i in 0..len(@diags)
        if @diags[@i].severity == SEVERITY_ERROR
            @output = @output + format_diagnostic(@diags[@i]) + "\n"
            @error_count = @error_count + 1

    # Then warnings
    orbit @i in 0..len(@diags)
        if @diags[@i].severity == SEVERITY_WARNING
            @output = @output + format_diagnostic(@diags[@i]) + "\n"
            @warning_count = @warning_count + 1

    # Then notes and help
    orbit @i in 0..len(@diags)
        if @diags[@i].severity != SEVERITY_ERROR and @diags[@i].severity != SEVERITY_WARNING
            @output = @output + format_diagnostic(@diags[@i]) + "\n"

    # Summary line
    if @error_count > 0 or @warning_count > 0
        @output = @output + "aborting due to "
        if @error_count > 0
            @output = @output + to_str(@error_count) + " error"
            if @error_count > 1
                @output = @output + "s"
        if @error_count > 0 and @warning_count > 0
            @output = @output + "; "
        if @warning_count > 0
            @output = @output + to_str(@warning_count) + " warning"
            if @warning_count > 1
                @output = @output + "s"
        @output = @output + " emitted\n"

    return @output

# =============================================================================
# CONFIGURATION SYSTEM
# =============================================================================
# Runtime configuration that aggregates CLI flags and environment variables.
# This struct is populated once at startup and threaded through the pipeline.

struct CompilerConfig
    # Compilation mode
    mode: CompilerMode

    # Feature flags
    type_check: bool
    borrow_check: bool
    show_warnings: bool
    debug_output: bool
    profiling: bool

    # Optimization level (0 = none, 1 = basic, 2 = aggressive)
    opt_level: int

    # Security capabilities
    caps: Capabilities

    # Output settings
    output_name: str
    output_dir: str

    # PGO (Profile-Guided Optimization)
    pgo_collect: bool
    pgo_profile: str

    # Security hardening
    randomize_layout: bool

# Create a default compiler configuration.
fn config_default() -> CompilerConfig
    return CompilerConfig {
        mode: compiler_mode_from_env(),
        type_check: TYPE_CHECK_ENABLED,
        borrow_check: BORROW_CHECK_ENABLED,
        show_warnings: SHOW_WARNINGS,
        debug_output: false,
        profiling: false,
        opt_level: DEFAULT_OPT_LEVEL,
        caps: capabilities_new(),
        output_name: "",
        output_dir: ".",
        pgo_collect: false,
        pgo_profile: "",
        randomize_layout: false
    }

# Parse CLI arguments into a CompilerConfig.
# This extends capabilities_from_args with additional flag parsing.
fn config_from_args(@args: [str]) -> CompilerConfig
    @config = config_default()
    @config.caps = capabilities_from_args(@args)

    orbit @i in 0..len(@args)
        @arg = @args[@i]
        match @arg
            phase "--no-borrow-check"
                @config.borrow_check = false
            phase "--no-typecheck"
                @config.type_check = false
            phase "--no-warnings"
                @config.show_warnings = false
            phase "--debug"
                @config.debug_output = true
            phase "-d"
                @config.debug_output = true
            phase "--profile"
                @config.profiling = true
            phase "--pgo-collect"
                @config.pgo_collect = true
            phase "--pgo-use"
                if @i + 1 < len(@args)
                    @config.pgo_profile = @args[@i + 1]
            phase "--randomize-layout"
                @config.randomize_layout = true
            phase "-O0"
                @config.opt_level = 0
            phase "-O1"
                @config.opt_level = 1
            phase "-O2"
                @config.opt_level = 2
            phase _
                pass

    return @config

# =============================================================================
# SOURCE MAP GENERATION
# =============================================================================
# When building for WASM or distributing, source maps help with debugging.
# They map compiled bytecode/WASM offsets back to original .luna source lines.

struct SourceMapEntry
    generated_offset: int    # Offset in generated output
    original_line: int       # Line in original .luna source
    original_column: int     # Column in original .luna source
    source_file: str         # Path to the original source file

struct SourceMap
    entries: [SourceMapEntry]
    entry_count: int
    source_file: str

fn source_map_new(@source_file: str) -> SourceMap
    return SourceMap {
        entries: [],
        entry_count: 0,
        source_file: @source_file
    }

fn source_map_add(@map: SourceMap, @gen_offset: int, @orig_line: int, @orig_col: int)
    @entry = SourceMapEntry {
        generated_offset: @gen_offset,
        original_line: @orig_line,
        original_column: @orig_col,
        source_file: @map.source_file
    }
    @map.entries = append(@map.entries, @entry)
    @map.entry_count = @map.entry_count + 1

# Look up the original source location for a generated offset.
# Uses binary search for efficiency on large source maps.
fn source_map_lookup(@map: SourceMap, @offset: int) -> SourceMapEntry
    # Binary search for the closest entry at or before the offset
    @lo = 0
    @hi = @map.entry_count - 1
    @best = -1

    orbit _ in 0..64   # Max 64 iterations for binary search (2^64 entries)
        if @lo > @hi
            break
        @mid = (@lo + @hi) / 2
        if @map.entries[@mid].generated_offset <= @offset
            @best = @mid
            @lo = @mid + 1
        else
            @hi = @mid - 1

    if @best >= 0
        return @map.entries[@best]

    # Fallback: return a dummy entry
    return SourceMapEntry {
        generated_offset: 0,
        original_line: 0,
        original_column: 0,
        source_file: @map.source_file
    }

# =============================================================================
# COMPILATION STATISTICS COLLECTOR
# =============================================================================
# Aggregates statistics across all compilation stages for reporting.
# Used by --debug, profile, and the self-compilation report.

struct CompileStats
    # File info
    source_file: str
    source_bytes: int
    source_lines: int

    # Token counts
    token_count: int

    # AST metrics
    ast_node_count: int
    function_count: int
    struct_count: int

    # Type checker metrics
    type_errors: int
    type_warnings: int
    types_inferred: int

    # Borrow checker metrics
    borrow_errors: int
    borrows_checked: int

    # Optimizer metrics
    constants_folded: int
    dead_code_removed: int
    functions_inlined: int
    loops_unrolled: int
    simd_vectorized: int

    # Bytecode metrics
    bytecode_ops: int
    bytecode_bytes: int
    constants_emitted: int

    # Timing (microseconds)
    time_lex: u64
    time_parse: u64
    time_typecheck: u64
    time_borrow: u64
    time_optimize: u64
    time_codegen: u64
    time_execute: u64
    time_total: u64

fn compile_stats_new() -> CompileStats
    return CompileStats {
        source_file: "",
        source_bytes: 0,
        source_lines: 0,
        token_count: 0,
        ast_node_count: 0,
        function_count: 0,
        struct_count: 0,
        type_errors: 0,
        type_warnings: 0,
        types_inferred: 0,
        borrow_errors: 0,
        borrows_checked: 0,
        constants_folded: 0,
        dead_code_removed: 0,
        functions_inlined: 0,
        loops_unrolled: 0,
        simd_vectorized: 0,
        bytecode_ops: 0,
        bytecode_bytes: 0,
        constants_emitted: 0,
        time_lex: 0,
        time_parse: 0,
        time_typecheck: 0,
        time_borrow: 0,
        time_optimize: 0,
        time_codegen: 0,
        time_execute: 0,
        time_total: 0
    }

# Print a formatted statistics report.
fn compile_stats_print(@stats: CompileStats)
    shine("")
    shine("================= Compilation Statistics =================")
    shine("")
    shine("Source:")
    shine("  File:             " + @stats.source_file)
    shine("  Size:             " + to_str(@stats.source_bytes) + " bytes")
    shine("  Lines:            " + to_str(@stats.source_lines))
    shine("")
    shine("Frontend:")
    shine("  Tokens:           " + to_str(@stats.token_count))
    shine("  AST nodes:        " + to_str(@stats.ast_node_count))
    shine("  Functions:        " + to_str(@stats.function_count))
    shine("  Structs:          " + to_str(@stats.struct_count))
    shine("")
    shine("Analysis:")
    shine("  Type errors:      " + to_str(@stats.type_errors))
    shine("  Type warnings:    " + to_str(@stats.type_warnings))
    shine("  Types inferred:   " + to_str(@stats.types_inferred))
    shine("  Borrows checked:  " + to_str(@stats.borrows_checked))
    shine("  Borrow errors:    " + to_str(@stats.borrow_errors))
    shine("")
    shine("Optimizer:")
    shine("  Constants folded: " + to_str(@stats.constants_folded))
    shine("  Dead code removed:" + to_str(@stats.dead_code_removed))
    shine("  Functions inlined:" + to_str(@stats.functions_inlined))
    shine("  Loops unrolled:   " + to_str(@stats.loops_unrolled))
    shine("  SIMD vectorized:  " + to_str(@stats.simd_vectorized))
    shine("")
    shine("Codegen:")
    shine("  Bytecode ops:     " + to_str(@stats.bytecode_ops))
    shine("  Bytecode size:    " + to_str(@stats.bytecode_bytes) + " bytes")
    shine("  Constants:        " + to_str(@stats.constants_emitted))
    shine("")
    shine("Timing:")
    shine("  Lexer:            " + format_duration_us(@stats.time_lex))
    shine("  Parser:           " + format_duration_us(@stats.time_parse))
    shine("  Type checker:     " + format_duration_us(@stats.time_typecheck))
    shine("  Borrow checker:   " + format_duration_us(@stats.time_borrow))
    shine("  Optimizer:        " + format_duration_us(@stats.time_optimize))
    shine("  Code generation:  " + format_duration_us(@stats.time_codegen))
    shine("  Execution:        " + format_duration_us(@stats.time_execute))
    shine("  ")
    shine("  Total:            " + format_duration_us(@stats.time_total))
    shine("")

# =============================================================================
# BOOTSTRAP VERIFICATION
# =============================================================================
# Additional verification routines for the self-hosting pipeline.
# These check that the Luna-compiled output matches the Rust-compiled output,
# ensuring correctness during the bootstrap transition.

# Compare two ASTs for structural equality.
# Used in hybrid mode to verify that the Luna type checker and optimizer
# produce the same output as the Rust implementations.
fn verify_ast_equality(@ast_a: AstNode, @ast_b: AstNode) -> bool
    # Compare node kinds
    if ast_kind(@ast_a) != ast_kind(@ast_b)
        return false

    # Compare child counts
    @children_a = ast_children(@ast_a)
    @children_b = ast_children(@ast_b)
    if len(@children_a) != len(@children_b)
        return false

    # Recursively compare children
    orbit @i in 0..len(@children_a)
        if not verify_ast_equality(@children_a[@i], @children_b[@i])
            return false

    return true

# Run a full verification pass comparing Rust and Luna backends.
# Returns a list of discrepancies found.
fn verify_bootstrap(@source: str) -> [str]
    @discrepancies: [str] = []

    # Lex
    @lex = lexer.new(@source)
    @tokens = lexer.tokenize(@lex)

    # Parse
    @par = parser.new(@tokens)
    @program = parser.parse(@par)
    if is_err(@program)
        @discrepancies = append(@discrepancies, "Parse failed: " + unwrap_err(@program))
        return @discrepancies

    @program = unwrap(@program)
    @program_copy = ast_clone(@program)

    # Type check with Rust backend
    @rust_result = rust_typecheck(@program)
    @rust_warnings = rust_typecheck_warnings()

    # Type check with Luna backend
    @luna_result = types.typecheck(@program_copy)
    @luna_warnings = types.get_warnings()

    # Compare results
    if is_ok(@rust_result) and is_err(@luna_result)
        @discrepancies = append(@discrepancies, "Rust passed type check but Luna failed")
    if is_err(@rust_result) and is_ok(@luna_result)
        @discrepancies = append(@discrepancies, "Luna passed type check but Rust failed")

    # Compare warning counts
    if len(@rust_warnings) != len(@luna_warnings)
        @discrepancies = append(@discrepancies, "Warning count mismatch: Rust=" + to_str(len(@rust_warnings)) + " Luna=" + to_str(len(@luna_warnings)))

    # Optimize with Rust backend
    @rust_opt_program = ast_clone(@program)
    rust_optimize(@rust_opt_program)

    # Optimize with Luna backend
    @luna_opt_program = ast_clone(@program)
    titan_opt.optimize(@luna_opt_program)

    # Compare optimized ASTs
    if not verify_ast_equality(@rust_opt_program, @luna_opt_program)
        @discrepancies = append(@discrepancies, "Optimized AST differs between Rust and Luna backends")

    return @discrepancies

# Print a bootstrap verification report.
# Called internally during hybrid mode compilation.
fn print_verification_report(@discrepancies: [str])
    if len(@discrepancies) == 0
        shine("Bootstrap verification: PASS (Rust and Luna agree)")
    else
        shine("Bootstrap verification: DIFFERENCES FOUND")
        orbit @i in 0..len(@discrepancies)
            shine("  [" + to_str(@i + 1) + "] " + @discrepancies[@i])

# =============================================================================
# STRING UTILITY FUNCTIONS
# =============================================================================
# Additional string helpers used throughout main.luna.
# These supplement the runtime-provided builtins.

# Repeat a string N times. E.g. str_repeat("=", 5) -> "====="
fn str_repeat(@s: str, @n: int) -> str
    @result = ""
    orbit @i in 0..@n
        @result = @result + @s
    return @result

# Check if a string is a valid Luna source file path.
# Must end with .luna and not be empty.
fn is_luna_file(@path: str) -> bool
    if len(@path) < 6
        return false
    return str_ends_with(@path, ".luna")

# Normalize a file path: convert backslashes to forward slashes.
# This ensures consistent path handling across Windows and Unix.
fn normalize_path(@path: str) -> str
    @result = ""
    orbit @i in 0..len(@path)
        @ch = char_at(@path, @i)
        if @ch == "\\"
            @result = @result + "/"
        else
            @result = @result + @ch
    return @result

# Join two path components with the appropriate separator.
fn path_join(@a: str, @b: str) -> str
    if len(@a) == 0
        return @b
    if len(@b) == 0
        return @a

    @last = char_at(@a, len(@a) - 1)
    if @last == "/" or @last == "\\"
        return @a + @b

    return @a + "/" + @b

# Get the directory portion of a file path.
# E.g. path_dir("src/foo/bar.luna") -> "src/foo"
fn path_dir(@path: str) -> str
    @last_sep = -1
    orbit @i in 0..len(@path)
        @ch = char_at(@path, @i)
        if @ch == "/" or @ch == "\\"
            @last_sep = @i

    if @last_sep == -1
        return "."

    return str_slice(@path, 0, @last_sep)

# Get the file extension from a path.
# E.g. path_ext("app.luna") -> "luna"
fn path_ext(@path: str) -> str
    @last_dot = -1
    orbit @i in 0..len(@path)
        if char_at(@path, @i) == "."
            @last_dot = @i

    if @last_dot == -1
        return ""

    return str_slice(@path, @last_dot + 1, len(@path))

# =============================================================================
# STDLIB FFI BRIDGE
# =============================================================================
# Transparent import mechanism for stdlib modules. When Luna code imports a
# standard library module (e.g. `import std::vfs`, `import std::net`), the
# compiler checks whether that module has been ported to pure Luna yet:
#
#   - If ported: the Luna implementation is loaded directly (fast, no FFI)
#   - If not ported: the bridge auto-generates FFI extern declarations that
#     call into the Rust standard library via C ABI
#
# This allows the self-hosting bootstrap to proceed incrementally -- modules
# can be rewritten in Luna one at a time without breaking existing code.
#
# The bridge is consulted during import resolution in the parser/compiler.
# It maintains a registry of all known stdlib modules and their current
# implementation status (Luna-native vs Rust-FFI).
#
# Architecture:
#   bridge_resolve_import(@bridge, "std::io")
#     -> BRIDGE_RUST_FFI
#     -> generates: extern "C" fn luna_io_read_file(@path: str) -> str
#                   extern "C" fn luna_io_write_file(@path: str, @content: str) -> bool
#                   ...
#
#   bridge_resolve_import(@bridge, "parser")
#     -> BRIDGE_LUNA_NATIVE
#     -> no FFI needed, import directly
# =============================================================================

# --- Bridge Status Constants ---
# These indicate how a stdlib module should be resolved at import time.

# Module has been ported to pure Luna and can be imported directly.
# No FFI overhead, no Rust dependency. This is the target state for all modules.
const BRIDGE_LUNA_NATIVE: int = 0

# Module still lives in Rust and must be accessed through FFI extern declarations.
# The bridge auto-generates the necessary extern "C" fn stubs at compile time.
const BRIDGE_RUST_FFI: int = 1

# Module is not recognized as part of the standard library.
# Import resolution should fall through to the normal file-based import system.
const BRIDGE_NOT_FOUND: int = 2

# Maximum number of modules the bridge can track.
# 64 is generous -- the Luna stdlib currently has ~25 modules.
const BRIDGE_MAX_MODULES: int = 64

# --- StdlibBridge Struct ---
# Registry of stdlib modules and their implementation status.
# Uses parallel arrays because Luna does not yet support Map/Dict in bootstrap.

struct StdlibBridge
    # Module names (e.g. "std::io", "parser", "types")
    module_names: [str]

    # Corresponding status for each module (BRIDGE_LUNA_NATIVE or BRIDGE_RUST_FFI)
    module_status: [int]

    # Number of registered modules
    module_count: int

# --- Constructor ---

# Create a new StdlibBridge pre-populated with all known stdlib modules.
# This is the single source of truth for which modules are Luna-native and
# which still require FFI bridging to Rust.
fn stdlib_bridge_new() -> StdlibBridge
    @names: [str] = []
    @status: [int] = []
    @count = 0

    # -----------------------------------------------------------------
    # Already ported to pure Luna (use directly, no FFI)
    # -----------------------------------------------------------------

    # Core compiler modules -- these ARE the self-hosting bootstrap
    @names = append(@names, "types")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "parser")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "lexer")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "kernel")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "pkg")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "runtime")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "main")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "llvm_api")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # NEW in v3.1 -- borrow checker ported to Luna
    @names = append(@names, "borrow_checker")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # NEW in v3.2 -- collections ported to Luna
    @names = append(@names, "collections")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # NEW in v3.2 -- io module ported to Luna (direct FFI to libc/win32)
    @names = append(@names, "io")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # NEW in v3.2 -- titan_opt (optimizer) is Luna-native
    @names = append(@names, "titan_opt")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # -----------------------------------------------------------------
    # Still in Rust -- need FFI bridge (auto-generated extern decls)
    # -----------------------------------------------------------------

    # std::io and std::fs now ported to Luna via io.luna (direct FFI)
    @names = append(@names, "std::io")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::fs")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # std::vfs is an alias for std::fs (virtual filesystem layer) -- now Luna-native via io.luna
    @names = append(@names, "std::vfs")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # std::collections -- now Luna-native via collections.luna
    @names = append(@names, "std::collections")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    # std::thread uses io.luna primitives but still partially Rust
    @names = append(@names, "std::thread")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::net")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::math")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::json")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::crypto")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::time")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::gui")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::desktop")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::channel")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::scheduler")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::sync")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::regex")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::http")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::db")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    @names = append(@names, "std::lsp")
    @status = append(@status, BRIDGE_LUNA_NATIVE)
    @count = @count + 1

    return StdlibBridge {
        module_names: @names,
        module_status: @status,
        module_count: @count
    }

# --- Import Resolution ---

# Resolve a stdlib import and return its bridge status.
# This is the primary entry point called by the compiler during import resolution.
#
# @param @bridge: The StdlibBridge instance with the module registry.
# @param @module_name: The module being imported (e.g. "std::io", "parser").
# @return: BRIDGE_LUNA_NATIVE, BRIDGE_RUST_FFI, or BRIDGE_NOT_FOUND.
#
# When the status is BRIDGE_RUST_FFI, the caller should also invoke
# bridge_generate_ffi_stubs() to get the extern declarations needed.
fn bridge_resolve_import(@bridge: StdlibBridge, @module_name: str) -> int
    # Linear scan through the registry -- fast enough for ~25 modules.
    orbit @i in 0..@bridge.module_count
        if @bridge.module_names[@i] == @module_name
            @status = @bridge.module_status[@i]

            if @status == BRIDGE_RUST_FFI
                # Log that we are bridging this module through FFI
                shine("[stdlib-bridge] '" + @module_name + "' -> Rust FFI (auto-generating extern decls)")
            else
                shine("[stdlib-bridge] '" + @module_name + "' -> Luna native (direct import)")

            return @status

    # Module not found in the stdlib registry
    return BRIDGE_NOT_FOUND

# --- FFI Stub Generation ---

# Generate FFI extern declarations for a Rust-backed stdlib module.
# These declarations are injected into the compilation unit so that Luna code
# can call the Rust functions transparently.
#
# The naming convention for FFI symbols is:
#   luna_{module}_{function}
# For example, std::io functions become luna_io_read_file, luna_io_write_file, etc.
#
# @param @bridge: The StdlibBridge instance.
# @param @module_name: The module to generate stubs for.
# @return: A string containing extern "C" fn declarations in Luna syntax,
#          or an empty string if the module is not FFI-bridged.
fn bridge_generate_ffi_stubs(@bridge: StdlibBridge, @module_name: str) -> str
    @stubs = ""

    # --- std::io ---
    if @module_name == "std::io"
        @stubs = @stubs + "extern \"C\" fn luna_io_read_file(@path: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_io_write_file(@path: str, @content: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_io_exists(@path: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_io_read_lines(@path: str) -> [str]\n"
        @stubs = @stubs + "extern \"C\" fn luna_io_stdin_read() -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_io_stdout_write(@text: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_io_stderr_write(@text: str) -> bool\n"
        return @stubs

    # --- std::fs / std::vfs ---
    if @module_name == "std::fs" or @module_name == "std::vfs"
        @stubs = @stubs + "extern \"C\" fn luna_fs_read(@path: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_write(@path: str, @data: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_exists(@path: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_mkdir(@path: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_remove(@path: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_list_dir(@path: str) -> [str]\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_copy(@src: str, @dst: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_fs_rename(@old: str, @new: str) -> bool\n"
        return @stubs

    # --- std::net ---
    if @module_name == "std::net"
        @stubs = @stubs + "extern \"C\" fn luna_net_tcp_connect(@host: str, @port: int) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_net_tcp_listen(@host: str, @port: int) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_net_tcp_accept(@socket: int) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_net_tcp_send(@socket: int, @data: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_net_tcp_recv(@socket: int, @max: int) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_net_tcp_close(@socket: int) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_net_dns_resolve(@hostname: str) -> str\n"
        return @stubs

    # --- std::math ---
    if @module_name == "std::math"
        @stubs = @stubs + "extern \"C\" fn luna_math_sqrt(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_sin(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_cos(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_tan(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_pow(@base: f64, @exp: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_log(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_abs(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_floor(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_ceil(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_round(@x: f64) -> f64\n"
        @stubs = @stubs + "extern \"C\" fn luna_math_random() -> f64\n"
        return @stubs

    # --- std::json ---
    if @module_name == "std::json"
        @stubs = @stubs + "extern \"C\" fn luna_json_parse(@text: str) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_json_stringify(@value: any) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_json_get(@obj: any, @key: str) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_json_set(@obj: any, @key: str, @val: any) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_json_is_valid(@text: str) -> bool\n"
        return @stubs

    # --- std::crypto ---
    if @module_name == "std::crypto"
        @stubs = @stubs + "extern \"C\" fn luna_crypto_sha256(@data: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_crypto_sha512(@data: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_crypto_hmac(@key: str, @data: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_crypto_random_bytes(@n: int) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_crypto_aes_encrypt(@key: str, @data: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_crypto_aes_decrypt(@key: str, @data: str) -> str\n"
        return @stubs

    # --- std::gui ---
    if @module_name == "std::gui"
        @stubs = @stubs + "extern \"C\" fn luna_gui_create_window(@title: str, @w: int, @h: int) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_gui_show_window(@handle: int) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_gui_close_window(@handle: int) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_gui_set_html(@handle: int, @html: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_gui_eval_js(@handle: int, @js: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_gui_poll_events() -> bool\n"
        return @stubs

    # --- std::desktop ---
    if @module_name == "std::desktop"
        @stubs = @stubs + "extern \"C\" fn luna_desktop_create(@title: str, @w: int, @h: int) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_desktop_load_html(@handle: int, @html: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_desktop_ipc_send(@handle: int, @msg: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_desktop_ipc_recv(@handle: int) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_desktop_run_loop(@handle: int) -> int\n"
        return @stubs

    # --- std::thread ---
    if @module_name == "std::thread"
        @stubs = @stubs + "extern \"C\" fn luna_thread_spawn(@func: any) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_thread_join(@id: int) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_thread_sleep(@ms: int) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_thread_current_id() -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_thread_yield() -> bool\n"
        return @stubs

    # --- std::channel ---
    if @module_name == "std::channel"
        @stubs = @stubs + "extern \"C\" fn luna_channel_new() -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_channel_send(@ch: int, @value: any) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_channel_recv(@ch: int) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_channel_try_recv(@ch: int) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_channel_close(@ch: int) -> bool\n"
        return @stubs

    # --- std::regex ---
    if @module_name == "std::regex"
        @stubs = @stubs + "extern \"C\" fn luna_regex_compile(@pattern: str) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_regex_is_match(@re: int, @text: str) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_regex_find(@re: int, @text: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_regex_find_all(@re: int, @text: str) -> [str]\n"
        @stubs = @stubs + "extern \"C\" fn luna_regex_replace(@re: int, @text: str, @rep: str) -> str\n"
        return @stubs

    # --- std::http ---
    if @module_name == "std::http"
        @stubs = @stubs + "extern \"C\" fn luna_http_get(@url: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_http_post(@url: str, @body: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_http_put(@url: str, @body: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_http_delete(@url: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_http_request(@method: str, @url: str, @headers: str, @body: str) -> str\n"
        @stubs = @stubs + "extern \"C\" fn luna_http_serve(@host: str, @port: int, @handler: any) -> int\n"
        return @stubs

    # --- std::db ---
    if @module_name == "std::db"
        @stubs = @stubs + "extern \"C\" fn luna_db_connect(@dsn: str) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_db_query(@conn: int, @sql: str) -> any\n"
        @stubs = @stubs + "extern \"C\" fn luna_db_execute(@conn: int, @sql: str) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_db_prepare(@conn: int, @sql: str) -> int\n"
        @stubs = @stubs + "extern \"C\" fn luna_db_bind(@stmt: int, @params: [any]) -> bool\n"
        @stubs = @stubs + "extern \"C\" fn luna_db_close(@conn: int) -> bool\n"
        return @stubs

    # Module not recognized -- return empty (caller should handle BRIDGE_NOT_FOUND)
    return ""

# --- Status Report ---

# Print a human-readable status report of all stdlib modules.
# Shows which modules are Luna-native, which are Rust-FFI bridged,
# and provides a summary count. Useful for `luna --stdlib-status`.
#
# @param @bridge: The StdlibBridge instance.
fn bridge_status_report(@bridge: StdlibBridge)
    shine("=== Luna Stdlib Bridge Status ===")
    shine("")

    @luna_count = 0
    @ffi_count = 0

    # Print Luna-native modules first
    shine("  Luna Native (direct import, no FFI):")
    orbit @i in 0..@bridge.module_count
        if @bridge.module_status[@i] == BRIDGE_LUNA_NATIVE
            shine("    [OK] " + @bridge.module_names[@i])
            @luna_count = @luna_count + 1

    shine("")

    # Print Rust-FFI bridged modules
    shine("  Rust FFI (auto-bridged via extern decls):")
    orbit @i in 0..@bridge.module_count
        if @bridge.module_status[@i] == BRIDGE_RUST_FFI
            shine("    [FFI] " + @bridge.module_names[@i])
            @ffi_count = @ffi_count + 1

    shine("")

    # Summary
    @total = @luna_count + @ffi_count
    @pct = 0
    if @total > 0
        @pct = (@luna_count * 100) / @total

    shine("  Summary: " + to_str(@luna_count) + "/" + to_str(@total) + " modules ported to Luna (" + to_str(@pct) + "%)")
    shine("           " + to_str(@ffi_count) + " modules still using Rust FFI bridge")
    shine("")
    shine("  To port a module: rewrite it in Luna, add to stdlib_bridge_new() as BRIDGE_LUNA_NATIVE")
    shine("=================================")

# =============================================================================
# EXPORTS
# =============================================================================
# Public API of the bootstrap main module. Other bootstrap files and tests
# can import these symbols.

export {
    # Version and constants
    VERSION,
    LUNA_STACK_SIZE,
    TYPE_CHECK_ENABLED,
    SHOW_WARNINGS,
    BORROW_CHECK_ENABLED,
    CAPABILITY_FLAGS,

    # Capabilities system
    Capabilities,
    capabilities_new,
    capabilities_allow_all,
    capabilities_from_args,
    capabilities_check_call,
    set_capabilities,
    get_capabilities,

    # Compiler mode
    CompilerMode,
    MODE_RUST,
    MODE_PURE,
    MODE_HYBRID,
    compiler_mode_from_env,
    compiler_mode_to_str,

    # Bootstrap bridge
    BootstrapBridge,
    bridge_new,
    bridge_with_mode,
    bridge_typecheck,
    bridge_optimize,
    bridge_warnings,
    bridge_stats,

    # Compilation pipelines
    run_bytecode,
    run_legacy,
    run_jit,
    build_native,
    build_wasm,
    build_desktop,
    run_static_analysis,
    run_with_profiling,

    # Self-compilation
    SelfCompileResult,
    self_compile,
    self_compile_report,

    # Helpers
    version_string,
    print_usage,
    find_file_arg,
    file_stem,
    format_duration_us,
    spawn_with_stack,

    # Error formatting
    Diagnostic,
    SEVERITY_ERROR,
    SEVERITY_WARNING,
    SEVERITY_NOTE,
    SEVERITY_HELP,
    format_diagnostic,
    format_diagnostics,

    # Configuration
    CompilerConfig,
    config_default,
    config_from_args,

    # Source maps
    SourceMap,
    SourceMapEntry,
    source_map_new,
    source_map_add,
    source_map_lookup,

    # Statistics
    CompileStats,
    compile_stats_new,
    compile_stats_print,

    # Bootstrap verification
    verify_ast_equality,
    verify_bootstrap,
    print_verification_report,

    # String utilities
    str_repeat,
    is_luna_file,
    normalize_path,
    path_join,
    path_dir,
    path_ext,

    # Stdlib FFI bridge
    BRIDGE_LUNA_NATIVE,
    BRIDGE_RUST_FFI,
    BRIDGE_NOT_FOUND,
    BRIDGE_MAX_MODULES,
    StdlibBridge,
    stdlib_bridge_new,
    bridge_resolve_import,
    bridge_generate_ffi_stubs,
    bridge_status_report,

    # Entry point
    main
}
